var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// .wrangler/tmp/bundle-0SN9c2/checked-fetch.js
function checkURL(request, init) {
  const url = request instanceof URL ? request : new URL(
    (typeof request === "string" ? new Request(request, init) : request).url
  );
  if (url.port && url.port !== "443" && url.protocol === "https:") {
    if (!urls.has(url.toString())) {
      urls.add(url.toString());
      console.warn(
        `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
      );
    }
  }
}
var urls;
var init_checked_fetch = __esm({
  ".wrangler/tmp/bundle-0SN9c2/checked-fetch.js"() {
    "use strict";
    urls = /* @__PURE__ */ new Set();
    __name(checkURL, "checkURL");
    globalThis.fetch = new Proxy(globalThis.fetch, {
      apply(target, thisArg, argArray) {
        const [request, init] = argArray;
        checkURL(request, init);
        return Reflect.apply(target, thisArg, argArray);
      }
    });
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// node_modules/hono/dist/compose.js
var compose;
var init_compose = __esm({
  "node_modules/hono/dist/compose.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    compose = /* @__PURE__ */ __name((middleware, onError, onNotFound) => {
      return (context, next) => {
        let index = -1;
        return dispatch(0);
        async function dispatch(i) {
          if (i <= index) {
            throw new Error("next() called multiple times");
          }
          index = i;
          let res;
          let isError = false;
          let handler;
          if (middleware[i]) {
            handler = middleware[i][0][0];
            context.req.routeIndex = i;
          } else {
            handler = i === middleware.length && next || void 0;
          }
          if (handler) {
            try {
              res = await handler(context, () => dispatch(i + 1));
            } catch (err) {
              if (err instanceof Error && onError) {
                context.error = err;
                res = await onError(err, context);
                isError = true;
              } else {
                throw err;
              }
            }
          } else {
            if (context.finalized === false && onNotFound) {
              res = await onNotFound(context);
            }
          }
          if (res && (context.finalized === false || isError)) {
            context.res = res;
          }
          return context;
        }
        __name(dispatch, "dispatch");
      };
    }, "compose");
  }
});

// node_modules/hono/dist/http-exception.js
var init_http_exception = __esm({
  "node_modules/hono/dist/http-exception.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/hono/dist/request/constants.js
var GET_MATCH_RESULT;
var init_constants = __esm({
  "node_modules/hono/dist/request/constants.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    GET_MATCH_RESULT = Symbol();
  }
});

// node_modules/hono/dist/utils/body.js
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
var parseBody, handleParsingAllValues, handleParsingNestedValues;
var init_body = __esm({
  "node_modules/hono/dist/utils/body.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_request();
    parseBody = /* @__PURE__ */ __name(async (request, options = /* @__PURE__ */ Object.create(null)) => {
      const { all = false, dot = false } = options;
      const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
      const contentType = headers.get("Content-Type");
      if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
        return parseFormData(request, { all, dot });
      }
      return {};
    }, "parseBody");
    __name(parseFormData, "parseFormData");
    __name(convertFormDataToBodyData, "convertFormDataToBodyData");
    handleParsingAllValues = /* @__PURE__ */ __name((form, key, value) => {
      if (form[key] !== void 0) {
        if (Array.isArray(form[key])) {
          ;
          form[key].push(value);
        } else {
          form[key] = [form[key], value];
        }
      } else {
        if (!key.endsWith("[]")) {
          form[key] = value;
        } else {
          form[key] = [value];
        }
      }
    }, "handleParsingAllValues");
    handleParsingNestedValues = /* @__PURE__ */ __name((form, key, value) => {
      let nestedForm = form;
      const keys = key.split(".");
      keys.forEach((key2, index) => {
        if (index === keys.length - 1) {
          nestedForm[key2] = value;
        } else {
          if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
            nestedForm[key2] = /* @__PURE__ */ Object.create(null);
          }
          nestedForm = nestedForm[key2];
        }
      });
    }, "handleParsingNestedValues");
  }
});

// node_modules/hono/dist/utils/url.js
var splitPath, splitRoutingPath, extractGroupsFromPath, replaceGroupMarks, patternCache, getPattern, tryDecode, tryDecodeURI, getPath, getPathNoStrict, mergePath, checkOptionalParameter, _decodeURI, _getQueryParam, getQueryParam, getQueryParams, decodeURIComponent_;
var init_url = __esm({
  "node_modules/hono/dist/utils/url.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    splitPath = /* @__PURE__ */ __name((path) => {
      const paths = path.split("/");
      if (paths[0] === "") {
        paths.shift();
      }
      return paths;
    }, "splitPath");
    splitRoutingPath = /* @__PURE__ */ __name((routePath) => {
      const { groups, path } = extractGroupsFromPath(routePath);
      const paths = splitPath(path);
      return replaceGroupMarks(paths, groups);
    }, "splitRoutingPath");
    extractGroupsFromPath = /* @__PURE__ */ __name((path) => {
      const groups = [];
      path = path.replace(/\{[^}]+\}/g, (match2, index) => {
        const mark = `@${index}`;
        groups.push([mark, match2]);
        return mark;
      });
      return { groups, path };
    }, "extractGroupsFromPath");
    replaceGroupMarks = /* @__PURE__ */ __name((paths, groups) => {
      for (let i = groups.length - 1; i >= 0; i--) {
        const [mark] = groups[i];
        for (let j = paths.length - 1; j >= 0; j--) {
          if (paths[j].includes(mark)) {
            paths[j] = paths[j].replace(mark, groups[i][1]);
            break;
          }
        }
      }
      return paths;
    }, "replaceGroupMarks");
    patternCache = {};
    getPattern = /* @__PURE__ */ __name((label, next) => {
      if (label === "*") {
        return "*";
      }
      const match2 = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
      if (match2) {
        const cacheKey = `${label}#${next}`;
        if (!patternCache[cacheKey]) {
          if (match2[2]) {
            patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match2[1], new RegExp(`^${match2[2]}(?=/${next})`)] : [label, match2[1], new RegExp(`^${match2[2]}$`)];
          } else {
            patternCache[cacheKey] = [label, match2[1], true];
          }
        }
        return patternCache[cacheKey];
      }
      return null;
    }, "getPattern");
    tryDecode = /* @__PURE__ */ __name((str, decoder) => {
      try {
        return decoder(str);
      } catch {
        return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match2) => {
          try {
            return decoder(match2);
          } catch {
            return match2;
          }
        });
      }
    }, "tryDecode");
    tryDecodeURI = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURI), "tryDecodeURI");
    getPath = /* @__PURE__ */ __name((request) => {
      const url = request.url;
      const start = url.indexOf("/", url.indexOf(":") + 4);
      let i = start;
      for (; i < url.length; i++) {
        const charCode = url.charCodeAt(i);
        if (charCode === 37) {
          const queryIndex = url.indexOf("?", i);
          const path = url.slice(start, queryIndex === -1 ? void 0 : queryIndex);
          return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
        } else if (charCode === 63) {
          break;
        }
      }
      return url.slice(start, i);
    }, "getPath");
    getPathNoStrict = /* @__PURE__ */ __name((request) => {
      const result = getPath(request);
      return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
    }, "getPathNoStrict");
    mergePath = /* @__PURE__ */ __name((base, sub, ...rest) => {
      if (rest.length) {
        sub = mergePath(sub, ...rest);
      }
      return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
    }, "mergePath");
    checkOptionalParameter = /* @__PURE__ */ __name((path) => {
      if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
        return null;
      }
      const segments = path.split("/");
      const results = [];
      let basePath = "";
      segments.forEach((segment) => {
        if (segment !== "" && !/\:/.test(segment)) {
          basePath += "/" + segment;
        } else if (/\:/.test(segment)) {
          if (/\?/.test(segment)) {
            if (results.length === 0 && basePath === "") {
              results.push("/");
            } else {
              results.push(basePath);
            }
            const optionalSegment = segment.replace("?", "");
            basePath += "/" + optionalSegment;
            results.push(basePath);
          } else {
            basePath += "/" + segment;
          }
        }
      });
      return results.filter((v, i, a) => a.indexOf(v) === i);
    }, "checkOptionalParameter");
    _decodeURI = /* @__PURE__ */ __name((value) => {
      if (!/[%+]/.test(value)) {
        return value;
      }
      if (value.indexOf("+") !== -1) {
        value = value.replace(/\+/g, " ");
      }
      return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
    }, "_decodeURI");
    _getQueryParam = /* @__PURE__ */ __name((url, key, multiple) => {
      let encoded;
      if (!multiple && key && !/[%+]/.test(key)) {
        let keyIndex2 = url.indexOf(`?${key}`, 8);
        if (keyIndex2 === -1) {
          keyIndex2 = url.indexOf(`&${key}`, 8);
        }
        while (keyIndex2 !== -1) {
          const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
          if (trailingKeyCode === 61) {
            const valueIndex = keyIndex2 + key.length + 2;
            const endIndex = url.indexOf("&", valueIndex);
            return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
          } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
            return "";
          }
          keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
        }
        encoded = /[%+]/.test(url);
        if (!encoded) {
          return void 0;
        }
      }
      const results = {};
      encoded ??= /[%+]/.test(url);
      let keyIndex = url.indexOf("?", 8);
      while (keyIndex !== -1) {
        const nextKeyIndex = url.indexOf("&", keyIndex + 1);
        let valueIndex = url.indexOf("=", keyIndex);
        if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
          valueIndex = -1;
        }
        let name = url.slice(
          keyIndex + 1,
          valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
        );
        if (encoded) {
          name = _decodeURI(name);
        }
        keyIndex = nextKeyIndex;
        if (name === "") {
          continue;
        }
        let value;
        if (valueIndex === -1) {
          value = "";
        } else {
          value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
          if (encoded) {
            value = _decodeURI(value);
          }
        }
        if (multiple) {
          if (!(results[name] && Array.isArray(results[name]))) {
            results[name] = [];
          }
          ;
          results[name].push(value);
        } else {
          results[name] ??= value;
        }
      }
      return key ? results[key] : results;
    }, "_getQueryParam");
    getQueryParam = _getQueryParam;
    getQueryParams = /* @__PURE__ */ __name((url, key) => {
      return _getQueryParam(url, key, true);
    }, "getQueryParams");
    decodeURIComponent_ = decodeURIComponent;
  }
});

// node_modules/hono/dist/request.js
var tryDecodeURIComponent, HonoRequest;
var init_request = __esm({
  "node_modules/hono/dist/request.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_http_exception();
    init_constants();
    init_body();
    init_url();
    tryDecodeURIComponent = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURIComponent_), "tryDecodeURIComponent");
    HonoRequest = class {
      static {
        __name(this, "HonoRequest");
      }
      raw;
      #validatedData;
      #matchResult;
      routeIndex = 0;
      path;
      bodyCache = {};
      constructor(request, path = "/", matchResult = [[]]) {
        this.raw = request;
        this.path = path;
        this.#matchResult = matchResult;
        this.#validatedData = {};
      }
      param(key) {
        return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
      }
      #getDecodedParam(key) {
        const paramKey = this.#matchResult[0][this.routeIndex][1][key];
        const param = this.#getParamValue(paramKey);
        return param && /\%/.test(param) ? tryDecodeURIComponent(param) : param;
      }
      #getAllDecodedParams() {
        const decoded = {};
        const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
        for (const key of keys) {
          const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
          if (value !== void 0) {
            decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
          }
        }
        return decoded;
      }
      #getParamValue(paramKey) {
        return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
      }
      query(key) {
        return getQueryParam(this.url, key);
      }
      queries(key) {
        return getQueryParams(this.url, key);
      }
      header(name) {
        if (name) {
          return this.raw.headers.get(name) ?? void 0;
        }
        const headerData = {};
        this.raw.headers.forEach((value, key) => {
          headerData[key] = value;
        });
        return headerData;
      }
      async parseBody(options) {
        return this.bodyCache.parsedBody ??= await parseBody(this, options);
      }
      #cachedBody = /* @__PURE__ */ __name((key) => {
        const { bodyCache, raw: raw2 } = this;
        const cachedBody = bodyCache[key];
        if (cachedBody) {
          return cachedBody;
        }
        const anyCachedKey = Object.keys(bodyCache)[0];
        if (anyCachedKey) {
          return bodyCache[anyCachedKey].then((body) => {
            if (anyCachedKey === "json") {
              body = JSON.stringify(body);
            }
            return new Response(body)[key]();
          });
        }
        return bodyCache[key] = raw2[key]();
      }, "#cachedBody");
      json() {
        return this.#cachedBody("text").then((text) => JSON.parse(text));
      }
      text() {
        return this.#cachedBody("text");
      }
      arrayBuffer() {
        return this.#cachedBody("arrayBuffer");
      }
      blob() {
        return this.#cachedBody("blob");
      }
      formData() {
        return this.#cachedBody("formData");
      }
      addValidatedData(target, data) {
        this.#validatedData[target] = data;
      }
      valid(target) {
        return this.#validatedData[target];
      }
      get url() {
        return this.raw.url;
      }
      get method() {
        return this.raw.method;
      }
      get [GET_MATCH_RESULT]() {
        return this.#matchResult;
      }
      get matchedRoutes() {
        return this.#matchResult[0].map(([[, route]]) => route);
      }
      get routePath() {
        return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
      }
    };
  }
});

// node_modules/hono/dist/utils/html.js
var HtmlEscapedCallbackPhase, raw, resolveCallback;
var init_html = __esm({
  "node_modules/hono/dist/utils/html.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    HtmlEscapedCallbackPhase = {
      Stringify: 1,
      BeforeStream: 2,
      Stream: 3
    };
    raw = /* @__PURE__ */ __name((value, callbacks) => {
      const escapedString = new String(value);
      escapedString.isEscaped = true;
      escapedString.callbacks = callbacks;
      return escapedString;
    }, "raw");
    resolveCallback = /* @__PURE__ */ __name(async (str, phase, preserveCallbacks, context, buffer) => {
      if (typeof str === "object" && !(str instanceof String)) {
        if (!(str instanceof Promise)) {
          str = str.toString();
        }
        if (str instanceof Promise) {
          str = await str;
        }
      }
      const callbacks = str.callbacks;
      if (!callbacks?.length) {
        return Promise.resolve(str);
      }
      if (buffer) {
        buffer[0] += str;
      } else {
        buffer = [str];
      }
      const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then(
        (res) => Promise.all(
          res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))
        ).then(() => buffer[0])
      );
      if (preserveCallbacks) {
        return raw(await resStr, callbacks);
      } else {
        return resStr;
      }
    }, "resolveCallback");
  }
});

// node_modules/hono/dist/context.js
var TEXT_PLAIN, setDefaultContentType, Context;
var init_context = __esm({
  "node_modules/hono/dist/context.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_request();
    init_html();
    TEXT_PLAIN = "text/plain; charset=UTF-8";
    setDefaultContentType = /* @__PURE__ */ __name((contentType, headers) => {
      return {
        "Content-Type": contentType,
        ...headers
      };
    }, "setDefaultContentType");
    Context = class {
      static {
        __name(this, "Context");
      }
      #rawRequest;
      #req;
      env = {};
      #var;
      finalized = false;
      error;
      #status;
      #executionCtx;
      #res;
      #layout;
      #renderer;
      #notFoundHandler;
      #preparedHeaders;
      #matchResult;
      #path;
      constructor(req, options) {
        this.#rawRequest = req;
        if (options) {
          this.#executionCtx = options.executionCtx;
          this.env = options.env;
          this.#notFoundHandler = options.notFoundHandler;
          this.#path = options.path;
          this.#matchResult = options.matchResult;
        }
      }
      get req() {
        this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
        return this.#req;
      }
      get event() {
        if (this.#executionCtx && "respondWith" in this.#executionCtx) {
          return this.#executionCtx;
        } else {
          throw Error("This context has no FetchEvent");
        }
      }
      get executionCtx() {
        if (this.#executionCtx) {
          return this.#executionCtx;
        } else {
          throw Error("This context has no ExecutionContext");
        }
      }
      get res() {
        return this.#res ||= new Response(null, {
          headers: this.#preparedHeaders ??= new Headers()
        });
      }
      set res(_res) {
        if (this.#res && _res) {
          _res = new Response(_res.body, _res);
          for (const [k, v] of this.#res.headers.entries()) {
            if (k === "content-type") {
              continue;
            }
            if (k === "set-cookie") {
              const cookies = this.#res.headers.getSetCookie();
              _res.headers.delete("set-cookie");
              for (const cookie of cookies) {
                _res.headers.append("set-cookie", cookie);
              }
            } else {
              _res.headers.set(k, v);
            }
          }
        }
        this.#res = _res;
        this.finalized = true;
      }
      render = /* @__PURE__ */ __name((...args) => {
        this.#renderer ??= (content) => this.html(content);
        return this.#renderer(...args);
      }, "render");
      setLayout = /* @__PURE__ */ __name((layout) => this.#layout = layout, "setLayout");
      getLayout = /* @__PURE__ */ __name(() => this.#layout, "getLayout");
      setRenderer = /* @__PURE__ */ __name((renderer) => {
        this.#renderer = renderer;
      }, "setRenderer");
      header = /* @__PURE__ */ __name((name, value, options) => {
        if (this.finalized) {
          this.#res = new Response(this.#res.body, this.#res);
        }
        const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers();
        if (value === void 0) {
          headers.delete(name);
        } else if (options?.append) {
          headers.append(name, value);
        } else {
          headers.set(name, value);
        }
      }, "header");
      status = /* @__PURE__ */ __name((status) => {
        this.#status = status;
      }, "status");
      set = /* @__PURE__ */ __name((key, value) => {
        this.#var ??= /* @__PURE__ */ new Map();
        this.#var.set(key, value);
      }, "set");
      get = /* @__PURE__ */ __name((key) => {
        return this.#var ? this.#var.get(key) : void 0;
      }, "get");
      get var() {
        if (!this.#var) {
          return {};
        }
        return Object.fromEntries(this.#var);
      }
      #newResponse(data, arg, headers) {
        const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers();
        if (typeof arg === "object" && "headers" in arg) {
          const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
          for (const [key, value] of argHeaders) {
            if (key.toLowerCase() === "set-cookie") {
              responseHeaders.append(key, value);
            } else {
              responseHeaders.set(key, value);
            }
          }
        }
        if (headers) {
          for (const [k, v] of Object.entries(headers)) {
            if (typeof v === "string") {
              responseHeaders.set(k, v);
            } else {
              responseHeaders.delete(k);
              for (const v2 of v) {
                responseHeaders.append(k, v2);
              }
            }
          }
        }
        const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
        return new Response(data, { status, headers: responseHeaders });
      }
      newResponse = /* @__PURE__ */ __name((...args) => this.#newResponse(...args), "newResponse");
      body = /* @__PURE__ */ __name((data, arg, headers) => this.#newResponse(data, arg, headers), "body");
      text = /* @__PURE__ */ __name((text, arg, headers) => {
        return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(
          text,
          arg,
          setDefaultContentType(TEXT_PLAIN, headers)
        );
      }, "text");
      json = /* @__PURE__ */ __name((object, arg, headers) => {
        return this.#newResponse(
          JSON.stringify(object),
          arg,
          setDefaultContentType("application/json", headers)
        );
      }, "json");
      html = /* @__PURE__ */ __name((html, arg, headers) => {
        const res = /* @__PURE__ */ __name((html2) => this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers)), "res");
        return typeof html === "object" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);
      }, "html");
      redirect = /* @__PURE__ */ __name((location, status) => {
        const locationString = String(location);
        this.header(
          "Location",
          !/[^\x00-\xFF]/.test(locationString) ? locationString : encodeURI(locationString)
        );
        return this.newResponse(null, status ?? 302);
      }, "redirect");
      notFound = /* @__PURE__ */ __name(() => {
        this.#notFoundHandler ??= () => new Response();
        return this.#notFoundHandler(this);
      }, "notFound");
    };
  }
});

// node_modules/hono/dist/router.js
var METHOD_NAME_ALL, METHOD_NAME_ALL_LOWERCASE, METHODS, MESSAGE_MATCHER_IS_ALREADY_BUILT, UnsupportedPathError;
var init_router = __esm({
  "node_modules/hono/dist/router.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    METHOD_NAME_ALL = "ALL";
    METHOD_NAME_ALL_LOWERCASE = "all";
    METHODS = ["get", "post", "put", "delete", "options", "patch"];
    MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
    UnsupportedPathError = class extends Error {
      static {
        __name(this, "UnsupportedPathError");
      }
    };
  }
});

// node_modules/hono/dist/utils/constants.js
var COMPOSED_HANDLER;
var init_constants2 = __esm({
  "node_modules/hono/dist/utils/constants.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    COMPOSED_HANDLER = "__COMPOSED_HANDLER";
  }
});

// node_modules/hono/dist/hono-base.js
var notFoundHandler, errorHandler, Hono;
var init_hono_base = __esm({
  "node_modules/hono/dist/hono-base.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_compose();
    init_context();
    init_router();
    init_constants2();
    init_url();
    notFoundHandler = /* @__PURE__ */ __name((c) => {
      return c.text("404 Not Found", 404);
    }, "notFoundHandler");
    errorHandler = /* @__PURE__ */ __name((err, c) => {
      if ("getResponse" in err) {
        const res = err.getResponse();
        return c.newResponse(res.body, res);
      }
      console.error(err);
      return c.text("Internal Server Error", 500);
    }, "errorHandler");
    Hono = class {
      static {
        __name(this, "Hono");
      }
      get;
      post;
      put;
      delete;
      options;
      patch;
      all;
      on;
      use;
      router;
      getPath;
      _basePath = "/";
      #path = "/";
      routes = [];
      constructor(options = {}) {
        const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
        allMethods.forEach((method) => {
          this[method] = (args1, ...args) => {
            if (typeof args1 === "string") {
              this.#path = args1;
            } else {
              this.#addRoute(method, this.#path, args1);
            }
            args.forEach((handler) => {
              this.#addRoute(method, this.#path, handler);
            });
            return this;
          };
        });
        this.on = (method, path, ...handlers) => {
          for (const p of [path].flat()) {
            this.#path = p;
            for (const m of [method].flat()) {
              handlers.map((handler) => {
                this.#addRoute(m.toUpperCase(), this.#path, handler);
              });
            }
          }
          return this;
        };
        this.use = (arg1, ...handlers) => {
          if (typeof arg1 === "string") {
            this.#path = arg1;
          } else {
            this.#path = "*";
            handlers.unshift(arg1);
          }
          handlers.forEach((handler) => {
            this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
          });
          return this;
        };
        const { strict, ...optionsWithoutStrict } = options;
        Object.assign(this, optionsWithoutStrict);
        this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
      }
      #clone() {
        const clone = new Hono({
          router: this.router,
          getPath: this.getPath
        });
        clone.errorHandler = this.errorHandler;
        clone.#notFoundHandler = this.#notFoundHandler;
        clone.routes = this.routes;
        return clone;
      }
      #notFoundHandler = notFoundHandler;
      errorHandler = errorHandler;
      route(path, app2) {
        const subApp = this.basePath(path);
        app2.routes.map((r) => {
          let handler;
          if (app2.errorHandler === errorHandler) {
            handler = r.handler;
          } else {
            handler = /* @__PURE__ */ __name(async (c, next) => (await compose([], app2.errorHandler)(c, () => r.handler(c, next))).res, "handler");
            handler[COMPOSED_HANDLER] = r.handler;
          }
          subApp.#addRoute(r.method, r.path, handler);
        });
        return this;
      }
      basePath(path) {
        const subApp = this.#clone();
        subApp._basePath = mergePath(this._basePath, path);
        return subApp;
      }
      onError = /* @__PURE__ */ __name((handler) => {
        this.errorHandler = handler;
        return this;
      }, "onError");
      notFound = /* @__PURE__ */ __name((handler) => {
        this.#notFoundHandler = handler;
        return this;
      }, "notFound");
      mount(path, applicationHandler, options) {
        let replaceRequest;
        let optionHandler;
        if (options) {
          if (typeof options === "function") {
            optionHandler = options;
          } else {
            optionHandler = options.optionHandler;
            if (options.replaceRequest === false) {
              replaceRequest = /* @__PURE__ */ __name((request) => request, "replaceRequest");
            } else {
              replaceRequest = options.replaceRequest;
            }
          }
        }
        const getOptions = optionHandler ? (c) => {
          const options2 = optionHandler(c);
          return Array.isArray(options2) ? options2 : [options2];
        } : (c) => {
          let executionContext = void 0;
          try {
            executionContext = c.executionCtx;
          } catch {
          }
          return [c.env, executionContext];
        };
        replaceRequest ||= (() => {
          const mergedPath = mergePath(this._basePath, path);
          const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
          return (request) => {
            const url = new URL(request.url);
            url.pathname = url.pathname.slice(pathPrefixLength) || "/";
            return new Request(url, request);
          };
        })();
        const handler = /* @__PURE__ */ __name(async (c, next) => {
          const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
          if (res) {
            return res;
          }
          await next();
        }, "handler");
        this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
        return this;
      }
      #addRoute(method, path, handler) {
        method = method.toUpperCase();
        path = mergePath(this._basePath, path);
        const r = { basePath: this._basePath, path, method, handler };
        this.router.add(method, path, [handler, r]);
        this.routes.push(r);
      }
      #handleError(err, c) {
        if (err instanceof Error) {
          return this.errorHandler(err, c);
        }
        throw err;
      }
      #dispatch(request, executionCtx, env, method) {
        if (method === "HEAD") {
          return (async () => new Response(null, await this.#dispatch(request, executionCtx, env, "GET")))();
        }
        const path = this.getPath(request, { env });
        const matchResult = this.router.match(method, path);
        const c = new Context(request, {
          path,
          matchResult,
          env,
          executionCtx,
          notFoundHandler: this.#notFoundHandler
        });
        if (matchResult[0].length === 1) {
          let res;
          try {
            res = matchResult[0][0][0][0](c, async () => {
              c.res = await this.#notFoundHandler(c);
            });
          } catch (err) {
            return this.#handleError(err, c);
          }
          return res instanceof Promise ? res.then(
            (resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))
          ).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
        }
        const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
        return (async () => {
          try {
            const context = await composed(c);
            if (!context.finalized) {
              throw new Error(
                "Context is not finalized. Did you forget to return a Response object or `await next()`?"
              );
            }
            return context.res;
          } catch (err) {
            return this.#handleError(err, c);
          }
        })();
      }
      fetch = /* @__PURE__ */ __name((request, ...rest) => {
        return this.#dispatch(request, rest[1], rest[0], request.method);
      }, "fetch");
      request = /* @__PURE__ */ __name((input, requestInit, Env7, executionCtx) => {
        if (input instanceof Request) {
          return this.fetch(requestInit ? new Request(input, requestInit) : input, Env7, executionCtx);
        }
        input = input.toString();
        return this.fetch(
          new Request(
            /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`,
            requestInit
          ),
          Env7,
          executionCtx
        );
      }, "request");
      fire = /* @__PURE__ */ __name(() => {
        addEventListener("fetch", (event) => {
          event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));
        });
      }, "fire");
    };
  }
});

// node_modules/hono/dist/router/reg-exp-router/matcher.js
function match(method, path) {
  const matchers = this.buildAllMatchers();
  const match2 = /* @__PURE__ */ __name((method2, path2) => {
    const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
    const staticMatch = matcher[2][path2];
    if (staticMatch) {
      return staticMatch;
    }
    const match3 = path2.match(matcher[0]);
    if (!match3) {
      return [[], emptyParam];
    }
    const index = match3.indexOf("", 1);
    return [matcher[1][index], match3];
  }, "match2");
  this.match = match2;
  return match2(method, path);
}
var emptyParam;
var init_matcher = __esm({
  "node_modules/hono/dist/router/reg-exp-router/matcher.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_router();
    emptyParam = [];
    __name(match, "match");
  }
});

// node_modules/hono/dist/router/reg-exp-router/node.js
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
var LABEL_REG_EXP_STR, ONLY_WILDCARD_REG_EXP_STR, TAIL_WILDCARD_REG_EXP_STR, PATH_ERROR, regExpMetaChars, Node;
var init_node = __esm({
  "node_modules/hono/dist/router/reg-exp-router/node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    LABEL_REG_EXP_STR = "[^/]+";
    ONLY_WILDCARD_REG_EXP_STR = ".*";
    TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
    PATH_ERROR = Symbol();
    regExpMetaChars = new Set(".\\+*[^]$()");
    __name(compareKey, "compareKey");
    Node = class {
      static {
        __name(this, "Node");
      }
      #index;
      #varIndex;
      #children = /* @__PURE__ */ Object.create(null);
      insert(tokens2, index, paramMap, context, pathErrorCheckOnly) {
        if (tokens2.length === 0) {
          if (this.#index !== void 0) {
            throw PATH_ERROR;
          }
          if (pathErrorCheckOnly) {
            return;
          }
          this.#index = index;
          return;
        }
        const [token, ...restTokens] = tokens2;
        const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
        let node;
        if (pattern) {
          const name = pattern[1];
          let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
          if (name && pattern[2]) {
            if (regexpStr === ".*") {
              throw PATH_ERROR;
            }
            regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
            if (/\((?!\?:)/.test(regexpStr)) {
              throw PATH_ERROR;
            }
          }
          node = this.#children[regexpStr];
          if (!node) {
            if (Object.keys(this.#children).some(
              (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
            )) {
              throw PATH_ERROR;
            }
            if (pathErrorCheckOnly) {
              return;
            }
            node = this.#children[regexpStr] = new Node();
            if (name !== "") {
              node.#varIndex = context.varIndex++;
            }
          }
          if (!pathErrorCheckOnly && name !== "") {
            paramMap.push([name, node.#varIndex]);
          }
        } else {
          node = this.#children[token];
          if (!node) {
            if (Object.keys(this.#children).some(
              (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
            )) {
              throw PATH_ERROR;
            }
            if (pathErrorCheckOnly) {
              return;
            }
            node = this.#children[token] = new Node();
          }
        }
        node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
      }
      buildRegExpStr() {
        const childKeys = Object.keys(this.#children).sort(compareKey);
        const strList = childKeys.map((k) => {
          const c = this.#children[k];
          return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
        });
        if (typeof this.#index === "number") {
          strList.unshift(`#${this.#index}`);
        }
        if (strList.length === 0) {
          return "";
        }
        if (strList.length === 1) {
          return strList[0];
        }
        return "(?:" + strList.join("|") + ")";
      }
    };
  }
});

// node_modules/hono/dist/router/reg-exp-router/trie.js
var Trie;
var init_trie = __esm({
  "node_modules/hono/dist/router/reg-exp-router/trie.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_node();
    Trie = class {
      static {
        __name(this, "Trie");
      }
      #context = { varIndex: 0 };
      #root = new Node();
      insert(path, index, pathErrorCheckOnly) {
        const paramAssoc = [];
        const groups = [];
        for (let i = 0; ; ) {
          let replaced = false;
          path = path.replace(/\{[^}]+\}/g, (m) => {
            const mark = `@\\${i}`;
            groups[i] = [mark, m];
            i++;
            replaced = true;
            return mark;
          });
          if (!replaced) {
            break;
          }
        }
        const tokens2 = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
        for (let i = groups.length - 1; i >= 0; i--) {
          const [mark] = groups[i];
          for (let j = tokens2.length - 1; j >= 0; j--) {
            if (tokens2[j].indexOf(mark) !== -1) {
              tokens2[j] = tokens2[j].replace(mark, groups[i][1]);
              break;
            }
          }
        }
        this.#root.insert(tokens2, index, paramAssoc, this.#context, pathErrorCheckOnly);
        return paramAssoc;
      }
      buildRegExp() {
        let regexp = this.#root.buildRegExpStr();
        if (regexp === "") {
          return [/^$/, [], []];
        }
        let captureIndex = 0;
        const indexReplacementMap = [];
        const paramReplacementMap = [];
        regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
          if (handlerIndex !== void 0) {
            indexReplacementMap[++captureIndex] = Number(handlerIndex);
            return "$()";
          }
          if (paramIndex !== void 0) {
            paramReplacementMap[Number(paramIndex)] = ++captureIndex;
            return "";
          }
          return "";
        });
        return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
      }
    };
  }
});

// node_modules/hono/dist/router/reg-exp-router/router.js
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(
    path === "*" ? "" : `^${path.replace(
      /\/\*$|([.\\+*[^\]$()])/g,
      (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)"
    )}$`
  );
}
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie();
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map(
    (route) => [!/\*|\/:/.test(route[0]), ...route]
  ).sort(
    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
  );
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (; paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length; i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length; j < len2; j++) {
      const map = handlerData[i][j]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k = 0, len3 = keys.length; k < len3; k++) {
        map[keys[k]] = paramReplacementMap[map[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
function findMiddleware(middleware, path) {
  if (!middleware) {
    return void 0;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return void 0;
}
var nullMatcher, wildcardRegExpCache, RegExpRouter;
var init_router2 = __esm({
  "node_modules/hono/dist/router/reg-exp-router/router.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_router();
    init_url();
    init_matcher();
    init_node();
    init_trie();
    nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
    wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
    __name(buildWildcardRegExp, "buildWildcardRegExp");
    __name(clearWildcardRegExpCache, "clearWildcardRegExpCache");
    __name(buildMatcherFromPreprocessedRoutes, "buildMatcherFromPreprocessedRoutes");
    __name(findMiddleware, "findMiddleware");
    RegExpRouter = class {
      static {
        __name(this, "RegExpRouter");
      }
      name = "RegExpRouter";
      #middleware;
      #routes;
      constructor() {
        this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
        this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
      }
      add(method, path, handler) {
        const middleware = this.#middleware;
        const routes = this.#routes;
        if (!middleware || !routes) {
          throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
        }
        if (!middleware[method]) {
          ;
          [middleware, routes].forEach((handlerMap) => {
            handlerMap[method] = /* @__PURE__ */ Object.create(null);
            Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
              handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
            });
          });
        }
        if (path === "/*") {
          path = "*";
        }
        const paramCount = (path.match(/\/:/g) || []).length;
        if (/\*$/.test(path)) {
          const re = buildWildcardRegExp(path);
          if (method === METHOD_NAME_ALL) {
            Object.keys(middleware).forEach((m) => {
              middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
            });
          } else {
            middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
          }
          Object.keys(middleware).forEach((m) => {
            if (method === METHOD_NAME_ALL || method === m) {
              Object.keys(middleware[m]).forEach((p) => {
                re.test(p) && middleware[m][p].push([handler, paramCount]);
              });
            }
          });
          Object.keys(routes).forEach((m) => {
            if (method === METHOD_NAME_ALL || method === m) {
              Object.keys(routes[m]).forEach(
                (p) => re.test(p) && routes[m][p].push([handler, paramCount])
              );
            }
          });
          return;
        }
        const paths = checkOptionalParameter(path) || [path];
        for (let i = 0, len = paths.length; i < len; i++) {
          const path2 = paths[i];
          Object.keys(routes).forEach((m) => {
            if (method === METHOD_NAME_ALL || method === m) {
              routes[m][path2] ||= [
                ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
              ];
              routes[m][path2].push([handler, paramCount - len + i + 1]);
            }
          });
        }
      }
      match = match;
      buildAllMatchers() {
        const matchers = /* @__PURE__ */ Object.create(null);
        Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
          matchers[method] ||= this.#buildMatcher(method);
        });
        this.#middleware = this.#routes = void 0;
        clearWildcardRegExpCache();
        return matchers;
      }
      #buildMatcher(method) {
        const routes = [];
        let hasOwnRoute = method === METHOD_NAME_ALL;
        [this.#middleware, this.#routes].forEach((r) => {
          const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
          if (ownRoute.length !== 0) {
            hasOwnRoute ||= true;
            routes.push(...ownRoute);
          } else if (method !== METHOD_NAME_ALL) {
            routes.push(
              ...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]])
            );
          }
        });
        if (!hasOwnRoute) {
          return null;
        } else {
          return buildMatcherFromPreprocessedRoutes(routes);
        }
      }
    };
  }
});

// node_modules/hono/dist/router/reg-exp-router/prepared-router.js
var init_prepared_router = __esm({
  "node_modules/hono/dist/router/reg-exp-router/prepared-router.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_router();
    init_matcher();
    init_router2();
  }
});

// node_modules/hono/dist/router/reg-exp-router/index.js
var init_reg_exp_router = __esm({
  "node_modules/hono/dist/router/reg-exp-router/index.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_router2();
    init_prepared_router();
  }
});

// node_modules/hono/dist/router/smart-router/router.js
var SmartRouter;
var init_router3 = __esm({
  "node_modules/hono/dist/router/smart-router/router.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_router();
    SmartRouter = class {
      static {
        __name(this, "SmartRouter");
      }
      name = "SmartRouter";
      #routers = [];
      #routes = [];
      constructor(init) {
        this.#routers = init.routers;
      }
      add(method, path, handler) {
        if (!this.#routes) {
          throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
        }
        this.#routes.push([method, path, handler]);
      }
      match(method, path) {
        if (!this.#routes) {
          throw new Error("Fatal error");
        }
        const routers = this.#routers;
        const routes = this.#routes;
        const len = routers.length;
        let i = 0;
        let res;
        for (; i < len; i++) {
          const router = routers[i];
          try {
            for (let i2 = 0, len2 = routes.length; i2 < len2; i2++) {
              router.add(...routes[i2]);
            }
            res = router.match(method, path);
          } catch (e) {
            if (e instanceof UnsupportedPathError) {
              continue;
            }
            throw e;
          }
          this.match = router.match.bind(router);
          this.#routers = [router];
          this.#routes = void 0;
          break;
        }
        if (i === len) {
          throw new Error("Fatal error");
        }
        this.name = `SmartRouter + ${this.activeRouter.name}`;
        return res;
      }
      get activeRouter() {
        if (this.#routes || this.#routers.length !== 1) {
          throw new Error("No active router has been determined yet.");
        }
        return this.#routers[0];
      }
    };
  }
});

// node_modules/hono/dist/router/smart-router/index.js
var init_smart_router = __esm({
  "node_modules/hono/dist/router/smart-router/index.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_router3();
  }
});

// node_modules/hono/dist/router/trie-router/node.js
var emptyParams, Node2;
var init_node2 = __esm({
  "node_modules/hono/dist/router/trie-router/node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_router();
    init_url();
    emptyParams = /* @__PURE__ */ Object.create(null);
    Node2 = class {
      static {
        __name(this, "Node");
      }
      #methods;
      #children;
      #patterns;
      #order = 0;
      #params = emptyParams;
      constructor(method, handler, children) {
        this.#children = children || /* @__PURE__ */ Object.create(null);
        this.#methods = [];
        if (method && handler) {
          const m = /* @__PURE__ */ Object.create(null);
          m[method] = { handler, possibleKeys: [], score: 0 };
          this.#methods = [m];
        }
        this.#patterns = [];
      }
      insert(method, path, handler) {
        this.#order = ++this.#order;
        let curNode = this;
        const parts = splitRoutingPath(path);
        const possibleKeys = [];
        for (let i = 0, len = parts.length; i < len; i++) {
          const p = parts[i];
          const nextP = parts[i + 1];
          const pattern = getPattern(p, nextP);
          const key = Array.isArray(pattern) ? pattern[0] : p;
          if (key in curNode.#children) {
            curNode = curNode.#children[key];
            if (pattern) {
              possibleKeys.push(pattern[1]);
            }
            continue;
          }
          curNode.#children[key] = new Node2();
          if (pattern) {
            curNode.#patterns.push(pattern);
            possibleKeys.push(pattern[1]);
          }
          curNode = curNode.#children[key];
        }
        curNode.#methods.push({
          [method]: {
            handler,
            possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
            score: this.#order
          }
        });
        return curNode;
      }
      #getHandlerSets(node, method, nodeParams, params) {
        const handlerSets = [];
        for (let i = 0, len = node.#methods.length; i < len; i++) {
          const m = node.#methods[i];
          const handlerSet = m[method] || m[METHOD_NAME_ALL];
          const processedSet = {};
          if (handlerSet !== void 0) {
            handlerSet.params = /* @__PURE__ */ Object.create(null);
            handlerSets.push(handlerSet);
            if (nodeParams !== emptyParams || params && params !== emptyParams) {
              for (let i2 = 0, len2 = handlerSet.possibleKeys.length; i2 < len2; i2++) {
                const key = handlerSet.possibleKeys[i2];
                const processed = processedSet[handlerSet.score];
                handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
                processedSet[handlerSet.score] = true;
              }
            }
          }
        }
        return handlerSets;
      }
      search(method, path) {
        const handlerSets = [];
        this.#params = emptyParams;
        const curNode = this;
        let curNodes = [curNode];
        const parts = splitPath(path);
        const curNodesQueue = [];
        for (let i = 0, len = parts.length; i < len; i++) {
          const part = parts[i];
          const isLast = i === len - 1;
          const tempNodes = [];
          for (let j = 0, len2 = curNodes.length; j < len2; j++) {
            const node = curNodes[j];
            const nextNode = node.#children[part];
            if (nextNode) {
              nextNode.#params = node.#params;
              if (isLast) {
                if (nextNode.#children["*"]) {
                  handlerSets.push(
                    ...this.#getHandlerSets(nextNode.#children["*"], method, node.#params)
                  );
                }
                handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
              } else {
                tempNodes.push(nextNode);
              }
            }
            for (let k = 0, len3 = node.#patterns.length; k < len3; k++) {
              const pattern = node.#patterns[k];
              const params = node.#params === emptyParams ? {} : { ...node.#params };
              if (pattern === "*") {
                const astNode = node.#children["*"];
                if (astNode) {
                  handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
                  astNode.#params = params;
                  tempNodes.push(astNode);
                }
                continue;
              }
              const [key, name, matcher] = pattern;
              if (!part && !(matcher instanceof RegExp)) {
                continue;
              }
              const child = node.#children[key];
              const restPathString = parts.slice(i).join("/");
              if (matcher instanceof RegExp) {
                const m = matcher.exec(restPathString);
                if (m) {
                  params[name] = m[0];
                  handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
                  if (Object.keys(child.#children).length) {
                    child.#params = params;
                    const componentCount = m[0].match(/\//)?.length ?? 0;
                    const targetCurNodes = curNodesQueue[componentCount] ||= [];
                    targetCurNodes.push(child);
                  }
                  continue;
                }
              }
              if (matcher === true || matcher.test(part)) {
                params[name] = part;
                if (isLast) {
                  handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
                  if (child.#children["*"]) {
                    handlerSets.push(
                      ...this.#getHandlerSets(child.#children["*"], method, params, node.#params)
                    );
                  }
                } else {
                  child.#params = params;
                  tempNodes.push(child);
                }
              }
            }
          }
          curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
        }
        if (handlerSets.length > 1) {
          handlerSets.sort((a, b) => {
            return a.score - b.score;
          });
        }
        return [handlerSets.map(({ handler, params }) => [handler, params])];
      }
    };
  }
});

// node_modules/hono/dist/router/trie-router/router.js
var TrieRouter;
var init_router4 = __esm({
  "node_modules/hono/dist/router/trie-router/router.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_url();
    init_node2();
    TrieRouter = class {
      static {
        __name(this, "TrieRouter");
      }
      name = "TrieRouter";
      #node;
      constructor() {
        this.#node = new Node2();
      }
      add(method, path, handler) {
        const results = checkOptionalParameter(path);
        if (results) {
          for (let i = 0, len = results.length; i < len; i++) {
            this.#node.insert(method, results[i], handler);
          }
          return;
        }
        this.#node.insert(method, path, handler);
      }
      match(method, path) {
        return this.#node.search(method, path);
      }
    };
  }
});

// node_modules/hono/dist/router/trie-router/index.js
var init_trie_router = __esm({
  "node_modules/hono/dist/router/trie-router/index.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_router4();
  }
});

// node_modules/hono/dist/hono.js
var Hono2;
var init_hono = __esm({
  "node_modules/hono/dist/hono.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_hono_base();
    init_reg_exp_router();
    init_smart_router();
    init_trie_router();
    Hono2 = class extends Hono {
      static {
        __name(this, "Hono");
      }
      constructor(options = {}) {
        super(options);
        this.router = options.router ?? new SmartRouter({
          routers: [new RegExpRouter(), new TrieRouter()]
        });
      }
    };
  }
});

// node_modules/hono/dist/index.js
var init_dist = __esm({
  "node_modules/hono/dist/index.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_hono();
  }
});

// node_modules/hono/dist/middleware/cors/index.js
var cors;
var init_cors = __esm({
  "node_modules/hono/dist/middleware/cors/index.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    cors = /* @__PURE__ */ __name((options) => {
      const defaults = {
        origin: "*",
        allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
        allowHeaders: [],
        exposeHeaders: []
      };
      const opts = {
        ...defaults,
        ...options
      };
      const findAllowOrigin = ((optsOrigin) => {
        if (typeof optsOrigin === "string") {
          if (optsOrigin === "*") {
            return () => optsOrigin;
          } else {
            return (origin) => optsOrigin === origin ? origin : null;
          }
        } else if (typeof optsOrigin === "function") {
          return optsOrigin;
        } else {
          return (origin) => optsOrigin.includes(origin) ? origin : null;
        }
      })(opts.origin);
      const findAllowMethods = ((optsAllowMethods) => {
        if (typeof optsAllowMethods === "function") {
          return optsAllowMethods;
        } else if (Array.isArray(optsAllowMethods)) {
          return () => optsAllowMethods;
        } else {
          return () => [];
        }
      })(opts.allowMethods);
      return /* @__PURE__ */ __name(async function cors2(c, next) {
        function set(key, value) {
          c.res.headers.set(key, value);
        }
        __name(set, "set");
        const allowOrigin = await findAllowOrigin(c.req.header("origin") || "", c);
        if (allowOrigin) {
          set("Access-Control-Allow-Origin", allowOrigin);
        }
        if (opts.credentials) {
          set("Access-Control-Allow-Credentials", "true");
        }
        if (opts.exposeHeaders?.length) {
          set("Access-Control-Expose-Headers", opts.exposeHeaders.join(","));
        }
        if (c.req.method === "OPTIONS") {
          if (opts.origin !== "*") {
            set("Vary", "Origin");
          }
          if (opts.maxAge != null) {
            set("Access-Control-Max-Age", opts.maxAge.toString());
          }
          const allowMethods = await findAllowMethods(c.req.header("origin") || "", c);
          if (allowMethods.length) {
            set("Access-Control-Allow-Methods", allowMethods.join(","));
          }
          let headers = opts.allowHeaders;
          if (!headers?.length) {
            const requestHeaders = c.req.header("Access-Control-Request-Headers");
            if (requestHeaders) {
              headers = requestHeaders.split(/\s*,\s*/);
            }
          }
          if (headers?.length) {
            set("Access-Control-Allow-Headers", headers.join(","));
            c.res.headers.append("Vary", "Access-Control-Request-Headers");
          }
          c.res.headers.delete("Content-Length");
          c.res.headers.delete("Content-Type");
          return new Response(null, {
            headers: c.res.headers,
            status: 204,
            statusText: "No Content"
          });
        }
        await next();
        if (opts.origin !== "*") {
          c.header("Vary", "Origin", { append: true });
        }
      }, "cors2");
    }, "cors");
  }
});

// node_modules/cloudflare/version.mjs
var VERSION;
var init_version = __esm({
  "node_modules/cloudflare/version.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    VERSION = "3.5.0";
  }
});

// node_modules/cloudflare/_shims/registry.mjs
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'cloudflare/shims/${shims.kind}'\` before importing anything else from cloudflare`);
  }
  if (kind) {
    throw new Error(`can't \`import 'cloudflare/shims/${shims.kind}'\` after \`import 'cloudflare/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch2 = shims.fetch;
  Request2 = shims.Request;
  Response2 = shims.Response;
  Headers2 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}
var auto, kind, fetch2, Request2, Response2, Headers2, FormData2, Blob2, File2, ReadableStream2, getMultipartRequestOptions, getDefaultAgent, fileFromPath, isFsReadStream;
var init_registry = __esm({
  "node_modules/cloudflare/_shims/registry.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    auto = false;
    kind = void 0;
    fetch2 = void 0;
    Request2 = void 0;
    Response2 = void 0;
    Headers2 = void 0;
    FormData2 = void 0;
    Blob2 = void 0;
    File2 = void 0;
    ReadableStream2 = void 0;
    getMultipartRequestOptions = void 0;
    getDefaultAgent = void 0;
    fileFromPath = void 0;
    isFsReadStream = void 0;
    __name(setShims, "setShims");
  }
});

// node_modules/cloudflare/_shims/MultipartBody.mjs
var MultipartBody;
var init_MultipartBody = __esm({
  "node_modules/cloudflare/_shims/MultipartBody.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    MultipartBody = class {
      static {
        __name(this, "MultipartBody");
      }
      constructor(body) {
        this.body = body;
      }
      get [Symbol.toStringTag]() {
        return "MultipartBody";
      }
    };
  }
});

// node_modules/cloudflare/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from 'cloudflare'\`:
- \`import 'cloudflare/shims/node'\` (if you're running on Node)
- \`import 'cloudflare/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        static {
          __name(this, "FormData");
        }
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      static {
        __name(this, "Blob");
      }
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        static {
          __name(this, "File");
        }
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        static {
          __name(this, "ReadableStream");
        }
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: /* @__PURE__ */ __name(async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }), "getMultipartRequestOptions"),
    getDefaultAgent: /* @__PURE__ */ __name((url) => void 0, "getDefaultAgent"),
    fileFromPath: /* @__PURE__ */ __name(() => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/cloudflare/cloudflare-typescript#file-uploads");
    }, "fileFromPath"),
    isFsReadStream: /* @__PURE__ */ __name((value) => false, "isFsReadStream")
  };
}
var init_web_runtime = __esm({
  "node_modules/cloudflare/_shims/web-runtime.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_MultipartBody();
    __name(getRuntime, "getRuntime");
  }
});

// node_modules/cloudflare/_shims/auto/runtime.mjs
var init_runtime = __esm({
  "node_modules/cloudflare/_shims/auto/runtime.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_web_runtime();
  }
});

// node_modules/cloudflare/_shims/index.mjs
var init_shims = __esm({
  "node_modules/cloudflare/_shims/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_registry();
    init_runtime();
    init_registry();
    if (!kind) setShims(getRuntime(), { auto: true });
  }
});

// node_modules/cloudflare/uploads.mjs
async function toFile(value, name, options) {
  value = await value;
  options ?? (options = isFileLike(value) ? { lastModified: value.lastModified, type: value.type } : {});
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    return new File2([blob], name, options);
  }
  const bits = await getBytes(value);
  name || (name = getName(value) ?? "unknown_file");
  if (!options.type) {
    const type = bits[0]?.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor?.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  getStringFromMaybeBuffer(value.path)?.split(/[\\/]/).pop();
}
var isResponseLike, isFileLike, isBlobLike, isUploadable, getStringFromMaybeBuffer, isAsyncIterableIterator, isMultipartBody, maybeMultipartFormRequestOptions, multipartFormRequestOptions, createForm, hasUploadableValue, addFormValue;
var init_uploads = __esm({
  "node_modules/cloudflare/uploads.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_shims();
    init_shims();
    isResponseLike = /* @__PURE__ */ __name((value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function", "isResponseLike");
    isFileLike = /* @__PURE__ */ __name((value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value), "isFileLike");
    isBlobLike = /* @__PURE__ */ __name((value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function", "isBlobLike");
    isUploadable = /* @__PURE__ */ __name((value) => {
      return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
    }, "isUploadable");
    __name(toFile, "toFile");
    __name(getBytes, "getBytes");
    __name(propsForError, "propsForError");
    __name(getName, "getName");
    getStringFromMaybeBuffer = /* @__PURE__ */ __name((x) => {
      if (typeof x === "string")
        return x;
      if (typeof Buffer !== "undefined" && x instanceof Buffer)
        return String(x);
      return void 0;
    }, "getStringFromMaybeBuffer");
    isAsyncIterableIterator = /* @__PURE__ */ __name((value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function", "isAsyncIterableIterator");
    isMultipartBody = /* @__PURE__ */ __name((body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody", "isMultipartBody");
    maybeMultipartFormRequestOptions = /* @__PURE__ */ __name(async (opts) => {
      if (!hasUploadableValue(opts.body))
        return opts;
      const form = await createForm(opts.body);
      return getMultipartRequestOptions(form, opts);
    }, "maybeMultipartFormRequestOptions");
    multipartFormRequestOptions = /* @__PURE__ */ __name(async (opts) => {
      const form = await createForm(opts.body);
      return getMultipartRequestOptions(form, opts);
    }, "multipartFormRequestOptions");
    createForm = /* @__PURE__ */ __name(async (body) => {
      const form = new FormData2();
      await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
      return form;
    }, "createForm");
    hasUploadableValue = /* @__PURE__ */ __name((value) => {
      if (isUploadable(value))
        return true;
      if (Array.isArray(value))
        return value.some(hasUploadableValue);
      if (value && typeof value === "object") {
        for (const k in value) {
          if (hasUploadableValue(value[k]))
            return true;
        }
      }
      return false;
    }, "hasUploadableValue");
    addFormValue = /* @__PURE__ */ __name(async (form, key, value) => {
      if (value === void 0)
        return;
      if (value == null) {
        throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
      }
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        form.append(key, String(value));
      } else if (isUploadable(value)) {
        const file = await toFile(value);
        form.append(key, file);
      } else if (Array.isArray(value)) {
        await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
      } else if (typeof value === "object") {
        await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
      } else {
        throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
      }
    }, "addFormValue");
  }
});

// node_modules/cloudflare/core.mjs
async function defaultParseResponse(props) {
  const { response } = props;
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const isJSON = contentType?.includes("application/json") || contentType?.includes("application/vnd.api+json");
  if (isJSON) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return json;
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match2 = pattern.exec("Cloudflare-Workers");
    if (match2) {
      const major = match2[1] || 0;
      const minor = match2[2] || 0;
      const patch = match2[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn(newHeaders, k))
      continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
function debug(action, ...args) {
  if (typeof process !== "undefined" && process?.env?.["DEBUG"] === "true") {
    console.log(`Cloudflare:DEBUG:${action}`, ...args);
  }
}
var __classPrivateFieldSet, __classPrivateFieldGet, _AbstractPage_client, APIPromise, APIClient, AbstractPage, PagePromise, createResponseHeaders, requestOptionsKeys, isRequestOptions, getPlatformProperties, normalizeArch, normalizePlatform, _platformHeaders, getPlatformHeaders, safeJSON, startsWithSchemeRegexp, isAbsoluteURL, sleep, validatePositiveInteger, castToError, readEnv, uuid4;
var init_core = __esm({
  "node_modules/cloudflare/core.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_version();
    init_error();
    init_shims();
    init_uploads();
    init_uploads();
    __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
      if (kind2 === "m") throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet = function(receiver, state, kind2, f) {
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __name(defaultParseResponse, "defaultParseResponse");
    APIPromise = class _APIPromise extends Promise {
      static {
        __name(this, "APIPromise");
      }
      constructor(responsePromise, parseResponse = defaultParseResponse) {
        super((resolve) => {
          resolve(null);
        });
        this.responsePromise = responsePromise;
        this.parseResponse = parseResponse;
      }
      _thenUnwrap(transform) {
        return new _APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));
      }
      /**
       * Gets the raw `Response` instance instead of parsing the response
       * data.
       *
       * If you want to parse the response body but still get the `Response`
       * instance, you can use {@link withResponse()}.
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` if you can,
       * or add one of these imports before your first `import  from 'cloudflare'`:
       * - `import 'cloudflare/shims/node'` (if you're running on Node)
       * - `import 'cloudflare/shims/web'` (otherwise)
       */
      asResponse() {
        return this.responsePromise.then((p) => p.response);
      }
      /**
       * Gets the parsed response data and the raw `Response` instance.
       *
       * If you just want to get the raw `Response` instance without parsing it,
       * you can use {@link asResponse()}.
       *
       *
       *  Getting the wrong TypeScript type for `Response`?
       * Try setting `"moduleResolution": "NodeNext"` if you can,
       * or add one of these imports before your first `import  from 'cloudflare'`:
       * - `import 'cloudflare/shims/node'` (if you're running on Node)
       * - `import 'cloudflare/shims/web'` (otherwise)
       */
      async withResponse() {
        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
        return { data, response };
      }
      parse() {
        if (!this.parsedPromise) {
          this.parsedPromise = this.responsePromise.then(this.parseResponse);
        }
        return this.parsedPromise;
      }
      then(onfulfilled, onrejected) {
        return this.parse().then(onfulfilled, onrejected);
      }
      catch(onrejected) {
        return this.parse().catch(onrejected);
      }
      finally(onfinally) {
        return this.parse().finally(onfinally);
      }
    };
    APIClient = class {
      static {
        __name(this, "APIClient");
      }
      constructor({
        baseURL,
        maxRetries = 2,
        timeout = 6e4,
        // 1 minute
        httpAgent,
        fetch: overridenFetch
      }) {
        this.baseURL = baseURL;
        this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
        this.timeout = validatePositiveInteger("timeout", timeout);
        this.httpAgent = httpAgent;
        this.fetch = overridenFetch ?? fetch2;
      }
      authHeaders(opts) {
        return {};
      }
      /**
       * Override this to add your own default headers, for example:
       *
       *  {
       *    ...super.defaultHeaders(),
       *    Authorization: 'Bearer 123',
       *  }
       */
      defaultHeaders(opts) {
        return {
          Accept: "application/json",
          "Content-Type": "application/json",
          "User-Agent": this.getUserAgent(),
          ...getPlatformHeaders(),
          ...this.authHeaders(opts)
        };
      }
      /**
       * Override this to add your own headers validation:
       */
      validateHeaders(headers, customHeaders) {
      }
      defaultIdempotencyKey() {
        return `stainless-node-retry-${uuid4()}`;
      }
      get(path, opts) {
        return this.methodRequest("get", path, opts);
      }
      post(path, opts) {
        return this.methodRequest("post", path, opts);
      }
      patch(path, opts) {
        return this.methodRequest("patch", path, opts);
      }
      put(path, opts) {
        return this.methodRequest("put", path, opts);
      }
      delete(path, opts) {
        return this.methodRequest("delete", path, opts);
      }
      methodRequest(method, path, opts) {
        return this.request(Promise.resolve(opts).then(async (opts2) => {
          const body = opts2 && isBlobLike(opts2?.body) ? new DataView(await opts2.body.arrayBuffer()) : opts2?.body instanceof DataView ? opts2.body : opts2?.body instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2?.body) ? new DataView(opts2.body.buffer) : opts2?.body;
          return { method, path, ...opts2, body };
        }));
      }
      getAPIList(path, Page2, opts) {
        return this.requestAPIList(Page2, { method: "get", path, ...opts });
      }
      calculateContentLength(body) {
        if (typeof body === "string") {
          if (typeof Buffer !== "undefined") {
            return Buffer.byteLength(body, "utf8").toString();
          }
          if (typeof TextEncoder !== "undefined") {
            const encoder = new TextEncoder();
            const encoded = encoder.encode(body);
            return encoded.length.toString();
          }
        } else if (ArrayBuffer.isView(body)) {
          return body.byteLength.toString();
        }
        return null;
      }
      buildRequest(options) {
        const { method, path, query, headers = {} } = options;
        const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
        const contentLength = this.calculateContentLength(body);
        const url = this.buildURL(path, query);
        if ("timeout" in options)
          validatePositiveInteger("timeout", options.timeout);
        const timeout = options.timeout ?? this.timeout;
        const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
        const minAgentTimeout = timeout + 1e3;
        if (typeof httpAgent?.options?.timeout === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
          httpAgent.options.timeout = minAgentTimeout;
        }
        if (this.idempotencyHeader && method !== "get") {
          if (!options.idempotencyKey)
            options.idempotencyKey = this.defaultIdempotencyKey();
          headers[this.idempotencyHeader] = options.idempotencyKey;
        }
        const reqHeaders = this.buildHeaders({ options, headers, contentLength });
        const req = {
          method,
          ...body && { body },
          headers: reqHeaders,
          ...httpAgent && { agent: httpAgent },
          // @ts-ignore node-fetch uses a custom AbortSignal type that is
          // not compatible with standard web types
          signal: options.signal ?? null
        };
        return { req, url, timeout };
      }
      buildHeaders({ options, headers, contentLength }) {
        const reqHeaders = {};
        if (contentLength) {
          reqHeaders["content-length"] = contentLength;
        }
        const defaultHeaders = this.defaultHeaders(options);
        applyHeadersMut(reqHeaders, defaultHeaders);
        applyHeadersMut(reqHeaders, headers);
        if (isMultipartBody(options.body) && kind !== "node") {
          delete reqHeaders["content-type"];
        }
        this.validateHeaders(reqHeaders, headers);
        return reqHeaders;
      }
      /**
       * Used as a callback for mutating the given `FinalRequestOptions` object.
       */
      async prepareOptions(options) {
      }
      /**
       * Used as a callback for mutating the given `RequestInit` object.
       *
       * This is useful for cases where you want to add certain headers based off of
       * the request properties, e.g. `method` or `url`.
       */
      async prepareRequest(request, { url, options }) {
      }
      parseHeaders(headers) {
        return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
      }
      makeStatusError(status, error, message, headers) {
        return APIError.generate(status, error, message, headers);
      }
      request(options, remainingRetries = null) {
        return new APIPromise(this.makeRequest(options, remainingRetries));
      }
      async makeRequest(optionsInput, retriesRemaining) {
        const options = await optionsInput;
        if (retriesRemaining == null) {
          retriesRemaining = options.maxRetries ?? this.maxRetries;
        }
        await this.prepareOptions(options);
        const { req, url, timeout } = this.buildRequest(options);
        await this.prepareRequest(req, { url, options });
        debug("request", url, options, req.headers);
        if (options.signal?.aborted) {
          throw new APIUserAbortError();
        }
        const controller = new AbortController();
        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
        if (response instanceof Error) {
          if (options.signal?.aborted) {
            throw new APIUserAbortError();
          }
          if (retriesRemaining) {
            return this.retryRequest(options, retriesRemaining);
          }
          if (response.name === "AbortError") {
            throw new APIConnectionTimeoutError();
          }
          throw new APIConnectionError({ cause: response });
        }
        const responseHeaders = createResponseHeaders(response.headers);
        if (!response.ok) {
          if (retriesRemaining && this.shouldRetry(response)) {
            const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
            debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
            return this.retryRequest(options, retriesRemaining, responseHeaders);
          }
          const errText = await response.text().catch((e) => castToError(e).message);
          const errJSON = safeJSON(errText);
          const errMessage = errJSON ? void 0 : errText;
          const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
          debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
          const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
          throw err;
        }
        return { response, options, controller };
      }
      requestAPIList(Page2, options) {
        const request = this.makeRequest(options, null);
        return new PagePromise(this, request, Page2);
      }
      buildURL(path, query) {
        const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
        const defaultQuery = this.defaultQuery();
        if (!isEmptyObj(defaultQuery)) {
          query = { ...defaultQuery, ...query };
        }
        if (typeof query === "object" && query && !Array.isArray(query)) {
          url.search = this.stringifyQuery(query);
        }
        return url.toString();
      }
      stringifyQuery(query) {
        return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
          if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
            return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
          }
          if (value === null) {
            return `${encodeURIComponent(key)}=`;
          }
          throw new CloudflareError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
        }).join("&");
      }
      async fetchWithTimeout(url, init, ms, controller) {
        const { signal, ...options } = init || {};
        if (signal)
          signal.addEventListener("abort", () => controller.abort());
        const timeout = setTimeout(() => controller.abort(), ms);
        return this.getRequestClient().fetch.call(void 0, url, { signal: controller.signal, ...options }).finally(() => {
          clearTimeout(timeout);
        });
      }
      getRequestClient() {
        return { fetch: this.fetch };
      }
      shouldRetry(response) {
        const shouldRetryHeader = response.headers.get("x-should-retry");
        if (shouldRetryHeader === "true")
          return true;
        if (shouldRetryHeader === "false")
          return false;
        if (response.status === 408)
          return true;
        if (response.status === 409)
          return true;
        if (response.status === 429)
          return true;
        if (response.status >= 500)
          return true;
        return false;
      }
      async retryRequest(options, retriesRemaining, responseHeaders) {
        let timeoutMillis;
        const retryAfterMillisHeader = responseHeaders?.["retry-after-ms"];
        if (retryAfterMillisHeader) {
          const timeoutMs = parseFloat(retryAfterMillisHeader);
          if (!Number.isNaN(timeoutMs)) {
            timeoutMillis = timeoutMs;
          }
        }
        const retryAfterHeader = responseHeaders?.["retry-after"];
        if (retryAfterHeader && !timeoutMillis) {
          const timeoutSeconds = parseFloat(retryAfterHeader);
          if (!Number.isNaN(timeoutSeconds)) {
            timeoutMillis = timeoutSeconds * 1e3;
          } else {
            timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
          }
        }
        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
          const maxRetries = options.maxRetries ?? this.maxRetries;
          timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
        }
        await sleep(timeoutMillis);
        return this.makeRequest(options, retriesRemaining - 1);
      }
      calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
        const initialRetryDelay = 0.5;
        const maxRetryDelay = 8;
        const numRetries = maxRetries - retriesRemaining;
        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
        const jitter = 1 - Math.random() * 0.25;
        return sleepSeconds * jitter * 1e3;
      }
      getUserAgent() {
        return `${this.constructor.name}/JS ${VERSION}`;
      }
    };
    AbstractPage = class {
      static {
        __name(this, "AbstractPage");
      }
      constructor(client, response, body, options) {
        _AbstractPage_client.set(this, void 0);
        __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
        this.options = options;
        this.response = response;
        this.body = body;
      }
      hasNextPage() {
        const items = this.getPaginatedItems();
        if (!items.length)
          return false;
        return this.nextPageInfo() != null;
      }
      async getNextPage() {
        const nextInfo = this.nextPageInfo();
        if (!nextInfo) {
          throw new CloudflareError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
        }
        const nextOptions = { ...this.options };
        if ("params" in nextInfo && typeof nextOptions.query === "object") {
          nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
        } else if ("url" in nextInfo) {
          const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
          for (const [key, value] of params) {
            nextInfo.url.searchParams.set(key, value);
          }
          nextOptions.query = void 0;
          nextOptions.path = nextInfo.url.toString();
        }
        return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
      }
      async *iterPages() {
        let page = this;
        yield page;
        while (page.hasNextPage()) {
          page = await page.getNextPage();
          yield page;
        }
      }
      async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
        for await (const page of this.iterPages()) {
          for (const item of page.getPaginatedItems()) {
            yield item;
          }
        }
      }
    };
    PagePromise = class extends APIPromise {
      static {
        __name(this, "PagePromise");
      }
      constructor(client, request, Page2) {
        super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
      }
      /**
       * Allow auto-paginating iteration on an unawaited list call, eg:
       *
       *    for await (const item of client.items.list()) {
       *      console.log(item)
       *    }
       */
      async *[Symbol.asyncIterator]() {
        const page = await this;
        for await (const item of page) {
          yield item;
        }
      }
    };
    createResponseHeaders = /* @__PURE__ */ __name((headers) => {
      return new Proxy(Object.fromEntries(
        // @ts-ignore
        headers.entries()
      ), {
        get(target, name) {
          const key = name.toString();
          return target[key.toLowerCase()] || target[key];
        }
      });
    }, "createResponseHeaders");
    requestOptionsKeys = {
      method: true,
      path: true,
      query: true,
      body: true,
      headers: true,
      maxRetries: true,
      stream: true,
      timeout: true,
      httpAgent: true,
      signal: true,
      idempotencyKey: true,
      __binaryRequest: true,
      __binaryResponse: true
    };
    isRequestOptions = /* @__PURE__ */ __name((obj) => {
      return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
    }, "isRequestOptions");
    getPlatformProperties = /* @__PURE__ */ __name(() => {
      if (typeof Deno !== "undefined" && Deno.build != null) {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": normalizePlatform(Deno.build.os),
          "X-Stainless-Arch": normalizeArch(Deno.build.arch),
          "X-Stainless-Runtime": "deno",
          "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
        };
      }
      if (typeof EdgeRuntime !== "undefined") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": `other:${EdgeRuntime}`,
          "X-Stainless-Runtime": "edge",
          "X-Stainless-Runtime-Version": process.version
        };
      }
      if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": normalizePlatform(process.platform),
          "X-Stainless-Arch": normalizeArch(process.arch),
          "X-Stainless-Runtime": "node",
          "X-Stainless-Runtime-Version": process.version
        };
      }
      const browserInfo = getBrowserInfo();
      if (browserInfo) {
        return {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": VERSION,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": "unknown",
          "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
          "X-Stainless-Runtime-Version": browserInfo.version
        };
      }
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": VERSION,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": "unknown",
        "X-Stainless-Runtime": "unknown",
        "X-Stainless-Runtime-Version": "unknown"
      };
    }, "getPlatformProperties");
    __name(getBrowserInfo, "getBrowserInfo");
    normalizeArch = /* @__PURE__ */ __name((arch) => {
      if (arch === "x32")
        return "x32";
      if (arch === "x86_64" || arch === "x64")
        return "x64";
      if (arch === "arm")
        return "arm";
      if (arch === "aarch64" || arch === "arm64")
        return "arm64";
      if (arch)
        return `other:${arch}`;
      return "unknown";
    }, "normalizeArch");
    normalizePlatform = /* @__PURE__ */ __name((platform) => {
      platform = platform.toLowerCase();
      if (platform.includes("ios"))
        return "iOS";
      if (platform === "android")
        return "Android";
      if (platform === "darwin")
        return "MacOS";
      if (platform === "win32")
        return "Windows";
      if (platform === "freebsd")
        return "FreeBSD";
      if (platform === "openbsd")
        return "OpenBSD";
      if (platform === "linux")
        return "Linux";
      if (platform)
        return `Other:${platform}`;
      return "Unknown";
    }, "normalizePlatform");
    getPlatformHeaders = /* @__PURE__ */ __name(() => {
      return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
    }, "getPlatformHeaders");
    safeJSON = /* @__PURE__ */ __name((text) => {
      try {
        return JSON.parse(text);
      } catch (err) {
        return void 0;
      }
    }, "safeJSON");
    startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
    isAbsoluteURL = /* @__PURE__ */ __name((url) => {
      return startsWithSchemeRegexp.test(url);
    }, "isAbsoluteURL");
    sleep = /* @__PURE__ */ __name((ms) => new Promise((resolve) => setTimeout(resolve, ms)), "sleep");
    validatePositiveInteger = /* @__PURE__ */ __name((name, n) => {
      if (typeof n !== "number" || !Number.isInteger(n)) {
        throw new CloudflareError(`${name} must be an integer`);
      }
      if (n < 0) {
        throw new CloudflareError(`${name} must be a positive integer`);
      }
      return n;
    }, "validatePositiveInteger");
    castToError = /* @__PURE__ */ __name((err) => {
      if (err instanceof Error)
        return err;
      return new Error(err);
    }, "castToError");
    readEnv = /* @__PURE__ */ __name((env) => {
      if (typeof process !== "undefined") {
        return process.env?.[env]?.trim() ?? void 0;
      }
      if (typeof Deno !== "undefined") {
        return Deno.env?.get?.(env)?.trim();
      }
      return void 0;
    }, "readEnv");
    __name(isEmptyObj, "isEmptyObj");
    __name(hasOwn, "hasOwn");
    __name(applyHeadersMut, "applyHeadersMut");
    __name(debug, "debug");
    uuid4 = /* @__PURE__ */ __name(() => {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0;
        const v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    }, "uuid4");
  }
});

// node_modules/cloudflare/error.mjs
var error_exports = {};
__export(error_exports, {
  APIConnectionError: () => APIConnectionError,
  APIConnectionTimeoutError: () => APIConnectionTimeoutError,
  APIError: () => APIError,
  APIUserAbortError: () => APIUserAbortError,
  AuthenticationError: () => AuthenticationError,
  BadRequestError: () => BadRequestError,
  CloudflareError: () => CloudflareError,
  ConflictError: () => ConflictError,
  InternalServerError: () => InternalServerError,
  NotFoundError: () => NotFoundError,
  PermissionDeniedError: () => PermissionDeniedError,
  RateLimitError: () => RateLimitError,
  UnprocessableEntityError: () => UnprocessableEntityError
});
var CloudflareError, APIError, APIUserAbortError, APIConnectionError, APIConnectionTimeoutError, BadRequestError, AuthenticationError, PermissionDeniedError, NotFoundError, ConflictError, UnprocessableEntityError, RateLimitError, InternalServerError;
var init_error = __esm({
  "node_modules/cloudflare/error.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_core();
    CloudflareError = class extends Error {
      static {
        __name(this, "CloudflareError");
      }
    };
    APIError = class _APIError extends CloudflareError {
      static {
        __name(this, "APIError");
      }
      constructor(status, error, message, headers) {
        super(`${_APIError.makeMessage(status, error, message)}`);
        this.status = status;
        this.headers = headers;
        const data = error;
        this.error = data;
        this.errors = data?.["errors"] ?? [];
      }
      static makeMessage(status, error, message) {
        const msg = error?.message ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
        if (status && msg) {
          return `${status} ${msg}`;
        }
        if (status) {
          return `${status} status code (no body)`;
        }
        if (msg) {
          return msg;
        }
        return "(no status code or body)";
      }
      static generate(status, errorResponse, message, headers) {
        if (!status) {
          return new APIConnectionError({ cause: castToError(errorResponse) });
        }
        const error = errorResponse;
        if (status === 400) {
          return new BadRequestError(status, error, message, headers);
        }
        if (status === 401) {
          return new AuthenticationError(status, error, message, headers);
        }
        if (status === 403) {
          return new PermissionDeniedError(status, error, message, headers);
        }
        if (status === 404) {
          return new NotFoundError(status, error, message, headers);
        }
        if (status === 409) {
          return new ConflictError(status, error, message, headers);
        }
        if (status === 422) {
          return new UnprocessableEntityError(status, error, message, headers);
        }
        if (status === 429) {
          return new RateLimitError(status, error, message, headers);
        }
        if (status >= 500) {
          return new InternalServerError(status, error, message, headers);
        }
        return new _APIError(status, error, message, headers);
      }
    };
    APIUserAbortError = class extends APIError {
      static {
        __name(this, "APIUserAbortError");
      }
      constructor({ message } = {}) {
        super(void 0, void 0, message || "Request was aborted.", void 0);
        this.status = void 0;
      }
    };
    APIConnectionError = class extends APIError {
      static {
        __name(this, "APIConnectionError");
      }
      constructor({ message, cause }) {
        super(void 0, void 0, message || "Connection error.", void 0);
        this.status = void 0;
        if (cause)
          this.cause = cause;
      }
    };
    APIConnectionTimeoutError = class extends APIConnectionError {
      static {
        __name(this, "APIConnectionTimeoutError");
      }
      constructor({ message } = {}) {
        super({ message: message ?? "Request timed out." });
      }
    };
    BadRequestError = class extends APIError {
      static {
        __name(this, "BadRequestError");
      }
      constructor() {
        super(...arguments);
        this.status = 400;
      }
    };
    AuthenticationError = class extends APIError {
      static {
        __name(this, "AuthenticationError");
      }
      constructor() {
        super(...arguments);
        this.status = 401;
      }
    };
    PermissionDeniedError = class extends APIError {
      static {
        __name(this, "PermissionDeniedError");
      }
      constructor() {
        super(...arguments);
        this.status = 403;
      }
    };
    NotFoundError = class extends APIError {
      static {
        __name(this, "NotFoundError");
      }
      constructor() {
        super(...arguments);
        this.status = 404;
      }
    };
    ConflictError = class extends APIError {
      static {
        __name(this, "ConflictError");
      }
      constructor() {
        super(...arguments);
        this.status = 409;
      }
    };
    UnprocessableEntityError = class extends APIError {
      static {
        __name(this, "UnprocessableEntityError");
      }
      constructor() {
        super(...arguments);
        this.status = 422;
      }
    };
    RateLimitError = class extends APIError {
      static {
        __name(this, "RateLimitError");
      }
      constructor() {
        super(...arguments);
        this.status = 429;
      }
    };
    InternalServerError = class extends APIError {
      static {
        __name(this, "InternalServerError");
      }
    };
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = TypeError;
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    __name(addNumericSeparator, "addNumericSeparator");
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    var quotes = {
      __proto__: null,
      "double": '"',
      single: "'"
    };
    var quoteREs = {
      __proto__: null,
      "double": /(["\\])/g,
      single: /(['\\])/g
    };
    module.exports = /* @__PURE__ */ __name(function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      __name(inspect, "inspect");
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber2(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt2(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean2(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString2(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate2(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    }, "inspect_");
    function wrapQuotes(s, defaultStyle, opts) {
      var style = opts.quoteStyle || defaultStyle;
      var quoteChar = quotes[style];
      return quoteChar + s + quoteChar;
    }
    __name(wrapQuotes, "wrapQuotes");
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    __name(quote, "quote");
    function canTrustToString(obj) {
      return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
    }
    __name(canTrustToString, "canTrustToString");
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && canTrustToString(obj);
    }
    __name(isArray, "isArray");
    function isDate2(obj) {
      return toStr(obj) === "[object Date]" && canTrustToString(obj);
    }
    __name(isDate2, "isDate");
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
    }
    __name(isRegExp, "isRegExp");
    function isError(obj) {
      return toStr(obj) === "[object Error]" && canTrustToString(obj);
    }
    __name(isError, "isError");
    function isString2(obj) {
      return toStr(obj) === "[object String]" && canTrustToString(obj);
    }
    __name(isString2, "isString");
    function isNumber2(obj) {
      return toStr(obj) === "[object Number]" && canTrustToString(obj);
    }
    __name(isNumber2, "isNumber");
    function isBoolean2(obj) {
      return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
    }
    __name(isBoolean2, "isBoolean");
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    __name(isSymbol, "isSymbol");
    function isBigInt2(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    __name(isBigInt2, "isBigInt");
    var hasOwn2 = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn2.call(obj, key);
    }
    __name(has, "has");
    function toStr(obj) {
      return objectToString.call(obj);
    }
    __name(toStr, "toStr");
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    __name(nameOf, "nameOf");
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    __name(indexOf, "indexOf");
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    __name(isMap, "isMap");
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    __name(isWeakMap, "isWeakMap");
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    __name(isWeakRef, "isWeakRef");
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    __name(isSet, "isSet");
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    __name(isWeakSet, "isWeakSet");
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    __name(isElement, "isElement");
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var quoteRE = quoteREs[opts.quoteStyle || "single"];
      quoteRE.lastIndex = 0;
      var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    __name(inspectString, "inspectString");
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    __name(lowbyte, "lowbyte");
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    __name(markBoxed, "markBoxed");
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    __name(weakCollectionOf, "weakCollectionOf");
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    __name(collectionOf, "collectionOf");
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    __name(singleLineValues, "singleLineValues");
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    __name(getIndent, "getIndent");
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    __name(indentedJoin, "indentedJoin");
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
    __name(arrObjKeys, "arrObjKeys");
  }
});

// node_modules/side-channel-list/index.js
var require_side_channel_list = __commonJS({
  "node_modules/side-channel-list/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var listGetNode = /* @__PURE__ */ __name(function(list, key, isDelete) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) != null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          if (!isDelete) {
            curr.next = /** @type {NonNullable<typeof list.next>} */
            list.next;
            list.next = curr;
          }
          return curr;
        }
      }
    }, "listGetNode");
    var listGet = /* @__PURE__ */ __name(function(objects, key) {
      if (!objects) {
        return void 0;
      }
      var node = listGetNode(objects, key);
      return node && node.value;
    }, "listGet");
    var listSet = /* @__PURE__ */ __name(function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    }, "listSet");
    var listHas = /* @__PURE__ */ __name(function(objects, key) {
      if (!objects) {
        return false;
      }
      return !!listGetNode(objects, key);
    }, "listHas");
    var listDelete = /* @__PURE__ */ __name(function(objects, key) {
      if (objects) {
        return listGetNode(objects, key, true);
      }
    }, "listDelete");
    module.exports = /* @__PURE__ */ __name(function getSideChannelList() {
      var $o;
      var channel = {
        assert: /* @__PURE__ */ __name(function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        }, "assert"),
        "delete": /* @__PURE__ */ __name(function(key) {
          var root = $o && $o.next;
          var deletedNode = listDelete($o, key);
          if (deletedNode && root && root === deletedNode) {
            $o = void 0;
          }
          return !!deletedNode;
        }, "delete"),
        get: /* @__PURE__ */ __name(function(key) {
          return listGet($o, key);
        }, "get"),
        has: /* @__PURE__ */ __name(function(key) {
          return listHas($o, key);
        }, "has"),
        set: /* @__PURE__ */ __name(function(key, value) {
          if (!$o) {
            $o = {
              next: void 0
            };
          }
          listSet(
            /** @type {NonNullable<typeof $o>} */
            $o,
            key,
            value
          );
        }, "set")
      };
      return channel;
    }, "getSideChannelList");
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = SyntaxError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = Number.isNaN || /* @__PURE__ */ __name(function isNaN2(a) {
      return a !== a;
    }, "isNaN");
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var $isNaN = require_isNaN();
    module.exports = /* @__PURE__ */ __name(function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    }, "sign");
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = /* @__PURE__ */ __name(function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    }, "hasSymbols");
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = /* @__PURE__ */ __name(function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    }, "hasNativeSymbols");
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = /* @__PURE__ */ __name(function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    }, "concatty");
    var slicy = /* @__PURE__ */ __name(function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    }, "slicy");
    var joiny = /* @__PURE__ */ __name(function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    }, "joiny");
    module.exports = /* @__PURE__ */ __name(function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = /* @__PURE__ */ __name(function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      }, "binder");
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = /* @__PURE__ */ __name(function Empty2() {
        }, "Empty");
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    }, "bind");
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = /* @__PURE__ */ __name(function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    }, "callBindBasic");
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      /* @__PURE__ */ __name(function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }, "getDunder")
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto ? /* @__PURE__ */ __name(function getProto(O) {
      return reflectGetProto(O);
    }, "getProto") : originalGetProto ? /* @__PURE__ */ __name(function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    }, "getProto") : getDunderProto ? /* @__PURE__ */ __name(function getProto(O) {
      return getDunderProto(O);
    }, "getProto") : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = /* @__PURE__ */ __name(function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    }, "getEvalledConstructor");
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = /* @__PURE__ */ __name(function() {
      throw new $TypeError();
    }, "throwTypeError");
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = /* @__PURE__ */ __name(function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    }, "doEval");
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn2 = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = /* @__PURE__ */ __name(function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match2, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match2;
      });
      return result;
    }, "stringToPath");
    var getBaseIntrinsic = /* @__PURE__ */ __name(function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn2(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn2(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    }, "getBaseIntrinsic");
    module.exports = /* @__PURE__ */ __name(function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn2(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn2(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    }, "GetIntrinsic");
  }
});

// node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "node_modules/call-bound/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module.exports = /* @__PURE__ */ __name(function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    }, "callBoundIntrinsic");
  }
});

// node_modules/side-channel-map/index.js
var require_side_channel_map = __commonJS({
  "node_modules/side-channel-map/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $Map = GetIntrinsic("%Map%", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var $mapDelete = callBound("Map.prototype.delete", true);
    var $mapSize = callBound("Map.prototype.size", true);
    module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */
    /* @__PURE__ */ __name(function getSideChannelMap() {
      var $m;
      var channel = {
        assert: /* @__PURE__ */ __name(function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        }, "assert"),
        "delete": /* @__PURE__ */ __name(function(key) {
          if ($m) {
            var result = $mapDelete($m, key);
            if ($mapSize($m) === 0) {
              $m = void 0;
            }
            return result;
          }
          return false;
        }, "delete"),
        get: /* @__PURE__ */ __name(function(key) {
          if ($m) {
            return $mapGet($m, key);
          }
        }, "get"),
        has: /* @__PURE__ */ __name(function(key) {
          if ($m) {
            return $mapHas($m, key);
          }
          return false;
        }, "has"),
        set: /* @__PURE__ */ __name(function(key, value) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value);
        }, "set")
      };
      return channel;
    }, "getSideChannelMap");
  }
});

// node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = __commonJS({
  "node_modules/side-channel-weakmap/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var getSideChannelMap = require_side_channel_map();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
    module.exports = $WeakMap ? (
      /** @type {Exclude<import('.'), false>} */
      /* @__PURE__ */ __name(function getSideChannelWeakMap() {
        var $wm;
        var $m;
        var channel = {
          assert: /* @__PURE__ */ __name(function(key) {
            if (!channel.has(key)) {
              throw new $TypeError("Side channel does not contain " + inspect(key));
            }
          }, "assert"),
          "delete": /* @__PURE__ */ __name(function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapDelete($wm, key);
              }
            } else if (getSideChannelMap) {
              if ($m) {
                return $m["delete"](key);
              }
            }
            return false;
          }, "delete"),
          get: /* @__PURE__ */ __name(function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key);
              }
            }
            return $m && $m.get(key);
          }, "get"),
          has: /* @__PURE__ */ __name(function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key);
              }
            }
            return !!$m && $m.has(key);
          }, "has"),
          set: /* @__PURE__ */ __name(function(key, value) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if (!$wm) {
                $wm = new $WeakMap();
              }
              $weakMapSet($wm, key, value);
            } else if (getSideChannelMap) {
              if (!$m) {
                $m = getSideChannelMap();
              }
              $m.set(key, value);
            }
          }, "set")
        };
        return channel;
      }, "getSideChannelWeakMap")
    ) : getSideChannelMap;
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var getSideChannelList = require_side_channel_list();
    var getSideChannelMap = require_side_channel_map();
    var getSideChannelWeakMap = require_side_channel_weakmap();
    var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
    module.exports = /* @__PURE__ */ __name(function getSideChannel() {
      var $channelData;
      var channel = {
        assert: /* @__PURE__ */ __name(function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        }, "assert"),
        "delete": /* @__PURE__ */ __name(function(key) {
          return !!$channelData && $channelData["delete"](key);
        }, "delete"),
        get: /* @__PURE__ */ __name(function(key) {
          return $channelData && $channelData.get(key);
        }, "get"),
        has: /* @__PURE__ */ __name(function(key) {
          return !!$channelData && $channelData.has(key);
        }, "has"),
        set: /* @__PURE__ */ __name(function(key, value) {
          if (!$channelData) {
            $channelData = makeChannel();
          }
          $channelData.set(key, value);
        }, "set")
      };
      return channel;
    }, "getSideChannel");
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: /* @__PURE__ */ __name(function(value) {
          return replace.call(value, percentTwenties, "+");
        }, "RFC1738"),
        RFC3986: /* @__PURE__ */ __name(function(value) {
          return String(value);
        }, "RFC3986")
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = /* @__PURE__ */ __name(function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    }, "compactQueue");
    var arrayToObject = /* @__PURE__ */ __name(function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? { __proto__: null } : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    }, "arrayToObject");
    var merge = /* @__PURE__ */ __name(function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object" && typeof source !== "function") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    }, "merge");
    var assign = /* @__PURE__ */ __name(function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    }, "assignSingleSource");
    var decode = /* @__PURE__ */ __name(function(str, defaultDecoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    }, "decode");
    var limit = 1024;
    var encode = /* @__PURE__ */ __name(function encode2(str, defaultEncoder, charset, kind2, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for (var i = 0; i < segment.length; ++i) {
          var c = segment.charCodeAt(i);
          if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hexTable[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        out += arr.join("");
      }
      return out;
    }, "encode");
    var compact = /* @__PURE__ */ __name(function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    }, "compact");
    var isRegExp = /* @__PURE__ */ __name(function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    }, "isRegExp");
    var isBuffer2 = /* @__PURE__ */ __name(function isBuffer3(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    }, "isBuffer");
    var combine = /* @__PURE__ */ __name(function combine2(a, b) {
      return [].concat(a, b);
    }, "combine");
    var maybeMap = /* @__PURE__ */ __name(function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    }, "maybeMap");
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer: isBuffer2,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: /* @__PURE__ */ __name(function brackets(prefix) {
        return prefix + "[]";
      }, "brackets"),
      comma: "comma",
      indices: /* @__PURE__ */ __name(function indices(prefix, key) {
        return prefix + "[" + key + "]";
      }, "indices"),
      repeat: /* @__PURE__ */ __name(function repeat(prefix) {
        return prefix;
      }, "repeat")
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = /* @__PURE__ */ __name(function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    }, "pushToArray");
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      commaRoundTrip: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      filter: void 0,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: /* @__PURE__ */ __name(function serializeDate(date) {
        return toISO.call(date);
      }, "serializeDate"),
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = /* @__PURE__ */ __name(function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    }, "isNonNullishPrimitive");
    var sentinel = {};
    var stringify2 = /* @__PURE__ */ __name(function stringify3(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify3(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    }, "stringify");
    var normalizeStringifyOptions = /* @__PURE__ */ __name(function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    }, "normalizeStringifyOptions");
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = obj[key];
        if (options.skipNulls && value === null) {
          continue;
        }
        pushToArray(keys, stringify2(
          value,
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.allowEmptyArrays,
          options.strictNullHandling,
          options.skipNulls,
          options.encodeDotInKeys,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictDepth: false,
      strictNullHandling: false,
      throwOnLimitExceeded: false
    };
    var interpretNumericEntities = /* @__PURE__ */ __name(function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    }, "interpretNumericEntities");
    var parseArrayValue = /* @__PURE__ */ __name(function(val, options, currentArrayLength) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
        throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
      }
      return val;
    }, "parseArrayValue");
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = /* @__PURE__ */ __name(function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(
        options.delimiter,
        options.throwOnLimitExceeded ? limit + 1 : limit
      );
      if (options.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
      }
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key;
        var val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(
              part.slice(pos + 1),
              options,
              isArray(obj[key]) ? obj[key].length : 0
            ),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(String(val));
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options.duplicates === "combine") {
          obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === "last") {
          obj[key] = val;
        }
      }
      return obj;
    }, "parseQueryStringValues");
    var parseObject = /* @__PURE__ */ __name(function(chain, val, options, valuesParsed) {
      var currentArrayLength = 0;
      if (chain.length > 0 && chain[chain.length - 1] === "[]") {
        var parentKey = chain.slice(0, -1).join("");
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
      }
      var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf);
        } else {
          obj = options.plainObjects ? { __proto__: null } : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index = parseInt(decodedRoot, 10);
          if (!options.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    }, "parseObject");
    var parseKeys = /* @__PURE__ */ __name(function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        if (options.strictDepth === true) {
          throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
        }
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    }, "parseQueryStringKeys");
    var normalizeParseOptions = /* @__PURE__ */ __name(function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
        throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
      };
    }, "normalizeParseOptions");
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? { __proto__: null } : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? { __proto__: null } : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var stringify2 = require_stringify();
    var parse = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse,
      stringify: stringify2
    };
  }
});

// node_modules/cloudflare/pagination.mjs
var V4PagePagination, V4PagePaginationArray, CursorPagination, CursorLimitPagination, SinglePage;
var init_pagination = __esm({
  "node_modules/cloudflare/pagination.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_core();
    V4PagePagination = class extends AbstractPage {
      static {
        __name(this, "V4PagePagination");
      }
      constructor(client, response, body, options) {
        super(client, response, body, options);
        this.result = body.result || {};
        this.result_info = body.result_info || {};
      }
      getPaginatedItems() {
        return this.result?.items ?? [];
      }
      // @deprecated Please use `nextPageInfo()` instead
      nextPageParams() {
        const info = this.nextPageInfo();
        if (!info)
          return null;
        if ("params" in info)
          return info.params;
        const params = Object.fromEntries(info.url.searchParams);
        if (!Object.keys(params).length)
          return null;
        return params;
      }
      nextPageInfo() {
        const query = this.options.query;
        const currentPage = query?.page ?? 1;
        return { params: { page: currentPage + 1 } };
      }
    };
    V4PagePaginationArray = class extends AbstractPage {
      static {
        __name(this, "V4PagePaginationArray");
      }
      constructor(client, response, body, options) {
        super(client, response, body, options);
        this.result = body.result || [];
        this.result_info = body.result_info || {};
      }
      getPaginatedItems() {
        return this.result ?? [];
      }
      // @deprecated Please use `nextPageInfo()` instead
      nextPageParams() {
        const info = this.nextPageInfo();
        if (!info)
          return null;
        if ("params" in info)
          return info.params;
        const params = Object.fromEntries(info.url.searchParams);
        if (!Object.keys(params).length)
          return null;
        return params;
      }
      nextPageInfo() {
        const query = this.options.query;
        const currentPage = query?.page ?? 1;
        return { params: { page: currentPage + 1 } };
      }
    };
    CursorPagination = class extends AbstractPage {
      static {
        __name(this, "CursorPagination");
      }
      constructor(client, response, body, options) {
        super(client, response, body, options);
        this.result = body.result || [];
        this.result_info = body.result_info || {};
      }
      getPaginatedItems() {
        return this.result ?? [];
      }
      // @deprecated Please use `nextPageInfo()` instead
      nextPageParams() {
        const info = this.nextPageInfo();
        if (!info)
          return null;
        if ("params" in info)
          return info.params;
        const params = Object.fromEntries(info.url.searchParams);
        if (!Object.keys(params).length)
          return null;
        return params;
      }
      nextPageInfo() {
        const cursor = this.result_info?.cursor;
        if (!cursor) {
          return null;
        }
        return {
          params: {
            cursor
          }
        };
      }
    };
    CursorLimitPagination = class extends AbstractPage {
      static {
        __name(this, "CursorLimitPagination");
      }
      constructor(client, response, body, options) {
        super(client, response, body, options);
        this.result = body.result || [];
        this.result_info = body.result_info || {};
      }
      getPaginatedItems() {
        return this.result ?? [];
      }
      // @deprecated Please use `nextPageInfo()` instead
      nextPageParams() {
        const info = this.nextPageInfo();
        if (!info)
          return null;
        if ("params" in info)
          return info.params;
        const params = Object.fromEntries(info.url.searchParams);
        if (!Object.keys(params).length)
          return null;
        return params;
      }
      nextPageInfo() {
        const cursor = this.result_info?.cursor;
        if (!cursor) {
          return null;
        }
        return {
          params: {
            cursor
          }
        };
      }
    };
    SinglePage = class extends AbstractPage {
      static {
        __name(this, "SinglePage");
      }
      constructor(client, response, body, options) {
        super(client, response, body, options);
        this.result = body.result || [];
      }
      getPaginatedItems() {
        return this.result ?? [];
      }
      // @deprecated Please use `nextPageInfo()` instead
      /**
       * This page represents a response that isn't actually paginated at the API level
       * so there will never be any next page params.
       */
      nextPageParams() {
        return null;
      }
      nextPageInfo() {
        return null;
      }
    };
  }
});

// node_modules/cloudflare/resources/shared.mjs
var RolesSinglePage, AuditLogsV4PagePaginationArray;
var init_shared = __esm({
  "node_modules/cloudflare/resources/shared.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_pagination();
    RolesSinglePage = class extends SinglePage {
      static {
        __name(this, "RolesSinglePage");
      }
    };
    AuditLogsV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "AuditLogsV4PagePaginationArray");
      }
    };
  }
});

// node_modules/cloudflare/resource.mjs
var APIResource;
var init_resource = __esm({
  "node_modules/cloudflare/resource.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    APIResource = class {
      static {
        __name(this, "APIResource");
      }
      constructor(client) {
        this._client = client;
      }
    };
  }
});

// node_modules/cloudflare/resources/acm/total-tls.mjs
var TotalTLS;
var init_total_tls = __esm({
  "node_modules/cloudflare/resources/acm/total-tls.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    TotalTLS = class extends APIResource {
      static {
        __name(this, "TotalTLS");
      }
      /**
       * Set Total TLS Settings or disable the feature for a Zone.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/acm/total_tls`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get Total TLS Settings for a Zone.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/acm/total_tls`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(TotalTLS2) {
    })(TotalTLS || (TotalTLS = {}));
  }
});

// node_modules/cloudflare/resources/acm/acm.mjs
var ACM;
var init_acm = __esm({
  "node_modules/cloudflare/resources/acm/acm.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_total_tls();
    ACM = class extends APIResource {
      static {
        __name(this, "ACM");
      }
      constructor() {
        super(...arguments);
        this.totalTLS = new TotalTLS(this._client);
      }
    };
    (function(ACM2) {
      ACM2.TotalTLS = TotalTLS;
    })(ACM || (ACM = {}));
  }
});

// node_modules/cloudflare/resources/ai-gateway/logs.mjs
var Logs, LogListResponsesV4PagePaginationArray;
var init_logs = __esm({
  "node_modules/cloudflare/resources/ai-gateway/logs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_logs();
    init_pagination();
    Logs = class extends APIResource {
      static {
        __name(this, "Logs");
      }
      /**
       * List Gateway Logs
       */
      list(id, params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/ai-gateway/gateways/${id}/logs`, LogListResponsesV4PagePaginationArray, { query, ...options });
      }
    };
    LogListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "LogListResponsesV4PagePaginationArray");
      }
    };
    (function(Logs5) {
      Logs5.LogListResponsesV4PagePaginationArray = LogListResponsesV4PagePaginationArray;
    })(Logs || (Logs = {}));
  }
});

// node_modules/cloudflare/resources/ai-gateway/ai-gateway.mjs
var AIGateway, AIGatewayListResponsesV4PagePaginationArray;
var init_ai_gateway = __esm({
  "node_modules/cloudflare/resources/ai-gateway/ai-gateway.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_logs();
    init_pagination();
    AIGateway = class extends APIResource {
      static {
        __name(this, "AIGateway");
      }
      constructor() {
        super(...arguments);
        this.logs = new Logs(this._client);
      }
      /**
       * Create a new Gateway
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/ai-gateway/gateways`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a Gateway
       */
      update(id, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/ai-gateway/gateways/${id}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List Gateways
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/ai-gateway/gateways`, AIGatewayListResponsesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Delete a Gateway
       */
      delete(id, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/ai-gateway/gateways/${id}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch a Gateway
       */
      get(id, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/ai-gateway/gateways/${id}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    AIGatewayListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "AIGatewayListResponsesV4PagePaginationArray");
      }
    };
    (function(AIGateway2) {
      AIGateway2.Logs = Logs;
      AIGateway2.LogListResponsesV4PagePaginationArray = LogListResponsesV4PagePaginationArray;
    })(AIGateway || (AIGateway = {}));
  }
});

// node_modules/cloudflare/resources/api-gateway/configurations.mjs
var Configurations;
var init_configurations = __esm({
  "node_modules/cloudflare/resources/api-gateway/configurations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Configurations = class extends APIResource {
      static {
        __name(this, "Configurations");
      }
      /**
       * Set configuration properties
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/api_gateway/configuration`, { body, ...options });
      }
      /**
       * Retrieve information about specific configuration properties
       */
      get(params, options) {
        const { zone_id, ...query } = params;
        return this._client.get(`/zones/${zone_id}/api_gateway/configuration`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Configurations4) {
    })(Configurations || (Configurations = {}));
  }
});

// node_modules/cloudflare/resources/api-gateway/schemas.mjs
var Schemas;
var init_schemas = __esm({
  "node_modules/cloudflare/resources/api-gateway/schemas.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Schemas = class extends APIResource {
      static {
        __name(this, "Schemas");
      }
      /**
       * Retrieve operations and features as OpenAPI schemas
       */
      list(params, options) {
        const { zone_id, ...query } = params;
        return this._client.get(`/zones/${zone_id}/api_gateway/schemas`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Schemas2) {
    })(Schemas || (Schemas = {}));
  }
});

// node_modules/cloudflare/resources/api-gateway/discovery/operations.mjs
var Operations;
var init_operations = __esm({
  "node_modules/cloudflare/resources/api-gateway/discovery/operations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_discovery();
    Operations = class extends APIResource {
      static {
        __name(this, "Operations");
      }
      /**
       * Retrieve the most up to date view of discovered operations
       */
      list(params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/api_gateway/discovery/operations`, DiscoveryOperationsV4PagePaginationArray, { query, ...options });
      }
      /**
       * Update the `state` on a discovered operation
       */
      edit(operationId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/api_gateway/discovery/operations/${operationId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Operations4) {
    })(Operations || (Operations = {}));
  }
});

// node_modules/cloudflare/resources/api-gateway/discovery/discovery.mjs
var Discovery, DiscoveryOperationsV4PagePaginationArray;
var init_discovery = __esm({
  "node_modules/cloudflare/resources/api-gateway/discovery/discovery.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_operations();
    init_pagination();
    Discovery = class extends APIResource {
      static {
        __name(this, "Discovery");
      }
      constructor() {
        super(...arguments);
        this.operations = new Operations(this._client);
      }
      /**
       * Retrieve the most up to date view of discovered operations, rendered as OpenAPI
       * schemas
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/api_gateway/discovery`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    DiscoveryOperationsV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "DiscoveryOperationsV4PagePaginationArray");
      }
    };
    (function(Discovery2) {
      Discovery2.Operations = Operations;
    })(Discovery || (Discovery = {}));
  }
});

// node_modules/cloudflare/resources/api-gateway/operations/schema-validation.mjs
var SchemaValidation;
var init_schema_validation = __esm({
  "node_modules/cloudflare/resources/api-gateway/operations/schema-validation.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    SchemaValidation = class extends APIResource {
      static {
        __name(this, "SchemaValidation");
      }
      /**
       * Updates operation-level schema validation settings on the zone
       */
      update(operationId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/api_gateway/operations/${operationId}/schema_validation`, {
          body,
          ...options
        });
      }
      /**
       * Updates multiple operation-level schema validation settings on the zone
       */
      edit(params, options) {
        const { zone_id, settings_multiple_request } = params;
        return this._client.patch(`/zones/${zone_id}/api_gateway/operations/schema_validation`, {
          body: settings_multiple_request,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Retrieves operation-level schema validation settings on the zone
       */
      get(operationId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/api_gateway/operations/${operationId}/schema_validation`, options);
      }
    };
    /* @__PURE__ */ (function(SchemaValidation3) {
    })(SchemaValidation || (SchemaValidation = {}));
  }
});

// node_modules/cloudflare/resources/api-gateway/operations/operations.mjs
var Operations2, OperationListResponsesV4PagePaginationArray;
var init_operations2 = __esm({
  "node_modules/cloudflare/resources/api-gateway/operations/operations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_operations2();
    init_schema_validation();
    init_pagination();
    Operations2 = class extends APIResource {
      static {
        __name(this, "Operations");
      }
      constructor() {
        super(...arguments);
        this.schemaValidation = new SchemaValidation(this._client);
      }
      /**
       * Add one or more operations to a zone. Endpoints can contain path variables.
       * Host, method, endpoint will be normalized to a canoncial form when creating an
       * operation and must be unique on the zone. Inserting an operation that matches an
       * existing one will return the record of the already existing operation and update
       * its last_updated date.
       */
      create(params, options) {
        const { zone_id, body } = params;
        return this._client.post(`/zones/${zone_id}/api_gateway/operations`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Retrieve information about all operations on a zone
       */
      list(params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/api_gateway/operations`, OperationListResponsesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Delete an operation
       */
      delete(operationId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/api_gateway/operations/${operationId}`, options);
      }
      /**
       * Retrieve information about an operation
       */
      get(operationId, params, options) {
        const { zone_id, ...query } = params;
        return this._client.get(`/zones/${zone_id}/api_gateway/operations/${operationId}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    OperationListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "OperationListResponsesV4PagePaginationArray");
      }
    };
    (function(Operations4) {
      Operations4.OperationListResponsesV4PagePaginationArray = OperationListResponsesV4PagePaginationArray;
      Operations4.SchemaValidation = SchemaValidation;
    })(Operations2 || (Operations2 = {}));
  }
});

// node_modules/cloudflare/resources/api-gateway/settings/schema-validation.mjs
var SchemaValidation2;
var init_schema_validation2 = __esm({
  "node_modules/cloudflare/resources/api-gateway/settings/schema-validation.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    SchemaValidation2 = class extends APIResource {
      static {
        __name(this, "SchemaValidation");
      }
      /**
       * Updates zone level schema validation settings on the zone
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/api_gateway/settings/schema_validation`, { body, ...options });
      }
      /**
       * Updates zone level schema validation settings on the zone
       */
      edit(params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/api_gateway/settings/schema_validation`, {
          body,
          ...options
        });
      }
      /**
       * Retrieves zone level schema validation settings currently set on the zone
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/api_gateway/settings/schema_validation`, options);
      }
    };
    /* @__PURE__ */ (function(SchemaValidation3) {
    })(SchemaValidation2 || (SchemaValidation2 = {}));
  }
});

// node_modules/cloudflare/resources/api-gateway/settings/settings.mjs
var Settings;
var init_settings = __esm({
  "node_modules/cloudflare/resources/api-gateway/settings/settings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_settings();
    init_schema_validation2();
    Settings = class extends APIResource {
      static {
        __name(this, "Settings");
      }
      constructor() {
        super(...arguments);
        this.schemaValidation = new SchemaValidation2(this._client);
      }
    };
    (function(Settings13) {
      Settings13.Settings = Settings;
      Settings13.SchemaValidation = SchemaValidation2;
    })(Settings || (Settings = {}));
  }
});

// node_modules/cloudflare/resources/api-gateway/user-schemas/operations.mjs
var Operations3, OperationListResponsesV4PagePaginationArray2;
var init_operations3 = __esm({
  "node_modules/cloudflare/resources/api-gateway/user-schemas/operations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_operations3();
    init_pagination();
    Operations3 = class extends APIResource {
      static {
        __name(this, "Operations");
      }
      /**
       * Retrieves all operations from the schema. Operations that already exist in API
       * Shield Endpoint Management will be returned as full operations.
       */
      list(schemaId, params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/api_gateway/user_schemas/${schemaId}/operations`, OperationListResponsesV4PagePaginationArray2, { query, ...options });
      }
    };
    OperationListResponsesV4PagePaginationArray2 = class extends V4PagePaginationArray {
      static {
        __name(this, "OperationListResponsesV4PagePaginationArray");
      }
    };
    (function(Operations4) {
      Operations4.OperationListResponsesV4PagePaginationArray = OperationListResponsesV4PagePaginationArray2;
    })(Operations3 || (Operations3 = {}));
  }
});

// node_modules/cloudflare/resources/api-gateway/user-schemas/user-schemas.mjs
var UserSchemas, PublicSchemasV4PagePaginationArray;
var init_user_schemas = __esm({
  "node_modules/cloudflare/resources/api-gateway/user-schemas/user-schemas.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_user_schemas();
    init_operations3();
    init_pagination();
    UserSchemas = class extends APIResource {
      static {
        __name(this, "UserSchemas");
      }
      constructor() {
        super(...arguments);
        this.operations = new Operations3(this._client);
      }
      /**
       * Upload a schema to a zone
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/api_gateway/user_schemas`, multipartFormRequestOptions({ body, ...options }))._thenUnwrap((obj) => obj.result);
      }
      /**
       * Retrieve information about all schemas on a zone
       */
      list(params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/api_gateway/user_schemas`, PublicSchemasV4PagePaginationArray, { query, ...options });
      }
      /**
       * Delete a schema
       */
      delete(schemaId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/api_gateway/user_schemas/${schemaId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Enable validation for a schema
       */
      edit(schemaId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/api_gateway/user_schemas/${schemaId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Retrieve information about a specific schema on a zone
       */
      get(schemaId, params, options) {
        const { zone_id, ...query } = params;
        return this._client.get(`/zones/${zone_id}/api_gateway/user_schemas/${schemaId}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    PublicSchemasV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "PublicSchemasV4PagePaginationArray");
      }
    };
    (function(UserSchemas2) {
      UserSchemas2.PublicSchemasV4PagePaginationArray = PublicSchemasV4PagePaginationArray;
      UserSchemas2.Operations = Operations3;
      UserSchemas2.OperationListResponsesV4PagePaginationArray = OperationListResponsesV4PagePaginationArray2;
    })(UserSchemas || (UserSchemas = {}));
  }
});

// node_modules/cloudflare/resources/api-gateway/api-gateway.mjs
var APIGateway;
var init_api_gateway = __esm({
  "node_modules/cloudflare/resources/api-gateway/api-gateway.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_configurations();
    init_schemas();
    init_discovery();
    init_operations2();
    init_settings();
    init_user_schemas();
    APIGateway = class extends APIResource {
      static {
        __name(this, "APIGateway");
      }
      constructor() {
        super(...arguments);
        this.configurations = new Configurations(this._client);
        this.discovery = new Discovery(this._client);
        this.operations = new Operations2(this._client);
        this.schemas = new Schemas(this._client);
        this.settings = new Settings(this._client);
        this.userSchemas = new UserSchemas(this._client);
      }
    };
    (function(APIGateway2) {
      APIGateway2.Configurations = Configurations;
      APIGateway2.Discovery = Discovery;
      APIGateway2.Operations = Operations2;
      APIGateway2.OperationListResponsesV4PagePaginationArray = OperationListResponsesV4PagePaginationArray;
      APIGateway2.Schemas = Schemas;
      APIGateway2.Settings = Settings;
      APIGateway2.UserSchemas = UserSchemas;
      APIGateway2.PublicSchemasV4PagePaginationArray = PublicSchemasV4PagePaginationArray;
    })(APIGateway || (APIGateway = {}));
  }
});

// node_modules/cloudflare/resources/accounts/members.mjs
var Members, MemberListResponsesV4PagePaginationArray;
var init_members = __esm({
  "node_modules/cloudflare/resources/accounts/members.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_members();
    init_pagination();
    Members = class extends APIResource {
      static {
        __name(this, "Members");
      }
      /**
       * Add a user to the list of members for this account.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/members`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Modify an account member.
       */
      update(memberId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/members/${memberId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List all members of an account.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/members`, MemberListResponsesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Remove a member from an account.
       */
      delete(memberId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/members/${memberId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get information about a specific member of an account.
       */
      get(memberId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/members/${memberId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    MemberListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "MemberListResponsesV4PagePaginationArray");
      }
    };
    (function(Members2) {
      Members2.MemberListResponsesV4PagePaginationArray = MemberListResponsesV4PagePaginationArray;
    })(Members || (Members = {}));
  }
});

// node_modules/cloudflare/resources/accounts/roles.mjs
var Roles;
var init_roles = __esm({
  "node_modules/cloudflare/resources/accounts/roles.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_shared();
    Roles = class extends APIResource {
      static {
        __name(this, "Roles");
      }
      /**
       * Get all available roles for an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/roles`, RolesSinglePage, options);
      }
      /**
       * Get information about a specific role for an account.
       */
      get(roleId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/roles/${roleId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Roles2) {
    })(Roles || (Roles = {}));
  }
});

// node_modules/cloudflare/resources/accounts/accounts.mjs
var Accounts, AccountListResponsesV4PagePaginationArray;
var init_accounts = __esm({
  "node_modules/cloudflare/resources/accounts/accounts.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_members();
    init_roles();
    init_pagination();
    Accounts = class extends APIResource {
      static {
        __name(this, "Accounts");
      }
      constructor() {
        super(...arguments);
        this.members = new Members(this._client);
        this.roles = new Roles(this._client);
      }
      /**
       * Update an existing account.
       */
      update(params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/accounts", AccountListResponsesV4PagePaginationArray, {
          query,
          ...options
        });
      }
      /**
       * Get information about a specific account that you are a member of.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    AccountListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "AccountListResponsesV4PagePaginationArray");
      }
    };
    (function(Accounts3) {
      Accounts3.Members = Members;
      Accounts3.MemberListResponsesV4PagePaginationArray = MemberListResponsesV4PagePaginationArray;
      Accounts3.Roles = Roles;
    })(Accounts || (Accounts = {}));
  }
});

// node_modules/cloudflare/resources/addressing/services.mjs
var Services, ServiceListResponsesSinglePage;
var init_services = __esm({
  "node_modules/cloudflare/resources/addressing/services.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_services();
    init_pagination();
    Services = class extends APIResource {
      static {
        __name(this, "Services");
      }
      /**
       * Bring-Your-Own IP (BYOIP) prefixes onboarded to Cloudflare must be bound to a
       * service running on the Cloudflare network to enable a Cloudflare product on the
       * IP addresses. This endpoint can be used as a reference of available services on
       * the Cloudflare network, and their service IDs.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/addressing/services`, ServiceListResponsesSinglePage, options);
      }
    };
    ServiceListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "ServiceListResponsesSinglePage");
      }
    };
    (function(Services2) {
      Services2.ServiceListResponsesSinglePage = ServiceListResponsesSinglePage;
    })(Services || (Services = {}));
  }
});

// node_modules/cloudflare/resources/addressing/address-maps/accounts.mjs
var Accounts2;
var init_accounts2 = __esm({
  "node_modules/cloudflare/resources/addressing/address-maps/accounts.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Accounts2 = class extends APIResource {
      static {
        __name(this, "Accounts");
      }
      /**
       * Add an account as a member of a particular address map.
       */
      update(addressMapId, params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/addressing/address_maps/${addressMapId}/accounts/${account_id}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Remove an account as a member of a particular address map.
       */
      delete(addressMapId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/addressing/address_maps/${addressMapId}/accounts/${account_id}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Accounts3) {
    })(Accounts2 || (Accounts2 = {}));
  }
});

// node_modules/cloudflare/resources/addressing/address-maps/ips.mjs
var IPs;
var init_ips = __esm({
  "node_modules/cloudflare/resources/addressing/address-maps/ips.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    IPs = class extends APIResource {
      static {
        __name(this, "IPs");
      }
      /**
       * Add an IP from a prefix owned by the account to a particular address map.
       */
      update(addressMapId, ipAddress, params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/addressing/address_maps/${addressMapId}/ips/${ipAddress}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Remove an IP from a particular address map.
       */
      delete(addressMapId, ipAddress, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/addressing/address_maps/${addressMapId}/ips/${ipAddress}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(IPs6) {
    })(IPs || (IPs = {}));
  }
});

// node_modules/cloudflare/resources/addressing/address-maps/zones.mjs
var Zones;
var init_zones = __esm({
  "node_modules/cloudflare/resources/addressing/address-maps/zones.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Zones = class extends APIResource {
      static {
        __name(this, "Zones");
      }
      /**
       * Add a zone as a member of a particular address map.
       */
      update(addressMapId, params, options) {
        const { zone_id, account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/addressing/address_maps/${addressMapId}/zones/${zone_id}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Remove a zone as a member of a particular address map.
       */
      delete(addressMapId, params, options) {
        const { zone_id, account_id } = params;
        return this._client.delete(`/accounts/${account_id}/addressing/address_maps/${addressMapId}/zones/${zone_id}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Zones3) {
    })(Zones || (Zones = {}));
  }
});

// node_modules/cloudflare/resources/addressing/address-maps/address-maps.mjs
var AddressMaps, AddressMapsSinglePage;
var init_address_maps = __esm({
  "node_modules/cloudflare/resources/addressing/address-maps/address-maps.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_address_maps();
    init_accounts2();
    init_ips();
    init_zones();
    init_pagination();
    AddressMaps = class extends APIResource {
      static {
        __name(this, "AddressMaps");
      }
      constructor() {
        super(...arguments);
        this.accounts = new Accounts2(this._client);
        this.ips = new IPs(this._client);
        this.zones = new Zones(this._client);
      }
      /**
       * Create a new address map under the account.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/addressing/address_maps`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List all address maps owned by the account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/addressing/address_maps`, AddressMapsSinglePage, options);
      }
      /**
       * Delete a particular address map owned by the account. An Address Map must be
       * disabled before it can be deleted.
       */
      delete(addressMapId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/addressing/address_maps/${addressMapId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Modify properties of an address map owned by the account.
       */
      edit(addressMapId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/addressing/address_maps/${addressMapId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Show a particular address map owned by the account.
       */
      get(addressMapId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/addressing/address_maps/${addressMapId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    AddressMapsSinglePage = class extends SinglePage {
      static {
        __name(this, "AddressMapsSinglePage");
      }
    };
    (function(AddressMaps2) {
      AddressMaps2.AddressMapsSinglePage = AddressMapsSinglePage;
      AddressMaps2.Accounts = Accounts2;
      AddressMaps2.IPs = IPs;
      AddressMaps2.Zones = Zones;
    })(AddressMaps || (AddressMaps = {}));
  }
});

// node_modules/cloudflare/resources/addressing/loa-documents/downloads.mjs
var Downloads;
var init_downloads = __esm({
  "node_modules/cloudflare/resources/addressing/loa-documents/downloads.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Downloads = class extends APIResource {
      static {
        __name(this, "Downloads");
      }
      /**
       * Download specified LOA document under the account.
       */
      get(loaDocumentId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/addressing/loa_documents/${loaDocumentId}/download`, {
          ...options,
          __binaryResponse: true
        });
      }
    };
    /* @__PURE__ */ (function(Downloads3) {
    })(Downloads || (Downloads = {}));
  }
});

// node_modules/cloudflare/resources/addressing/loa-documents/loa-documents.mjs
var LOADocuments;
var init_loa_documents = __esm({
  "node_modules/cloudflare/resources/addressing/loa-documents/loa-documents.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_downloads();
    LOADocuments = class extends APIResource {
      static {
        __name(this, "LOADocuments");
      }
      constructor() {
        super(...arguments);
        this.downloads = new Downloads(this._client);
      }
      /**
       * Submit LOA document (pdf format) under the account.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/addressing/loa_documents`, multipartFormRequestOptions({ body, ...options }))._thenUnwrap((obj) => obj.result);
      }
    };
    (function(LOADocuments2) {
      LOADocuments2.Downloads = Downloads;
    })(LOADocuments || (LOADocuments = {}));
  }
});

// node_modules/cloudflare/resources/addressing/prefixes/delegations.mjs
var Delegations, DelegationsSinglePage;
var init_delegations = __esm({
  "node_modules/cloudflare/resources/addressing/prefixes/delegations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_delegations();
    init_pagination();
    Delegations = class extends APIResource {
      static {
        __name(this, "Delegations");
      }
      /**
       * Create a new account delegation for a given IP prefix.
       */
      create(prefixId, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/addressing/prefixes/${prefixId}/delegations`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List all delegations for a given account IP prefix.
       */
      list(prefixId, params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/addressing/prefixes/${prefixId}/delegations`, DelegationsSinglePage, options);
      }
      /**
       * Delete an account delegation for a given IP prefix.
       */
      delete(prefixId, delegationId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/addressing/prefixes/${prefixId}/delegations/${delegationId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    DelegationsSinglePage = class extends SinglePage {
      static {
        __name(this, "DelegationsSinglePage");
      }
    };
    (function(Delegations2) {
      Delegations2.Delegations = Delegations;
      Delegations2.DelegationsSinglePage = DelegationsSinglePage;
    })(Delegations || (Delegations = {}));
  }
});

// node_modules/cloudflare/resources/addressing/prefixes/bgp/bindings.mjs
var Bindings, ServiceBindingsSinglePage;
var init_bindings = __esm({
  "node_modules/cloudflare/resources/addressing/prefixes/bgp/bindings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_bindings();
    init_pagination();
    Bindings = class extends APIResource {
      static {
        __name(this, "Bindings");
      }
      /**
       * Creates a new Service Binding, routing traffic to IPs within the given CIDR to a
       * service running on Cloudflare's network. **Note:** This API may only be used on
       * prefixes currently configured with a Magic Transit service binding, and only
       * allows creating service bindings for the Cloudflare CDN or Cloudflare Spectrum.
       */
      create(prefixId, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/addressing/prefixes/${prefixId}/bindings`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List the Cloudflare services this prefix is currently bound to. Traffic sent to
       * an address within an IP prefix will be routed to the Cloudflare service of the
       * most-specific Service Binding matching the address. **Example:** binding
       * `192.0.2.0/24` to Cloudflare Magic Transit and `192.0.2.1/32` to the Cloudflare
       * CDN would route traffic for `192.0.2.1` to the CDN, and traffic for all other
       * IPs in the prefix to Cloudflare Magic Transit.
       */
      list(prefixId, params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/addressing/prefixes/${prefixId}/bindings`, ServiceBindingsSinglePage, options);
      }
      /**
       * Delete a Service Binding
       */
      delete(prefixId, bindingId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/addressing/prefixes/${prefixId}/bindings/${bindingId}`, options);
      }
      /**
       * Fetch a single Service Binding
       */
      get(prefixId, bindingId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/addressing/prefixes/${prefixId}/bindings/${bindingId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ServiceBindingsSinglePage = class extends SinglePage {
      static {
        __name(this, "ServiceBindingsSinglePage");
      }
    };
    (function(Bindings3) {
      Bindings3.ServiceBindingsSinglePage = ServiceBindingsSinglePage;
    })(Bindings || (Bindings = {}));
  }
});

// node_modules/cloudflare/resources/addressing/prefixes/bgp/prefixes.mjs
var Prefixes, BGPPrefixesSinglePage;
var init_prefixes = __esm({
  "node_modules/cloudflare/resources/addressing/prefixes/bgp/prefixes.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_prefixes();
    init_pagination();
    Prefixes = class extends APIResource {
      static {
        __name(this, "Prefixes");
      }
      /**
       * List all BGP Prefixes within the specified IP Prefix. BGP Prefixes are used to
       * control which specific subnets are advertised to the Internet. It is possible to
       * advertise subnets more specific than an IP Prefix by creating more specific BGP
       * Prefixes.
       */
      list(prefixId, params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/addressing/prefixes/${prefixId}/bgp/prefixes`, BGPPrefixesSinglePage, options);
      }
      /**
       * Update the properties of a BGP Prefix, such as the on demand advertisement
       * status (advertised or withdrawn).
       */
      edit(prefixId, bgpPrefixId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/addressing/prefixes/${prefixId}/bgp/prefixes/${bgpPrefixId}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Retrieve a single BGP Prefix according to its identifier
       */
      get(prefixId, bgpPrefixId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/addressing/prefixes/${prefixId}/bgp/prefixes/${bgpPrefixId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    BGPPrefixesSinglePage = class extends SinglePage {
      static {
        __name(this, "BGPPrefixesSinglePage");
      }
    };
    (function(Prefixes3) {
      Prefixes3.BGPPrefixesSinglePage = BGPPrefixesSinglePage;
    })(Prefixes || (Prefixes = {}));
  }
});

// node_modules/cloudflare/resources/addressing/prefixes/bgp/statuses.mjs
var Statuses;
var init_statuses = __esm({
  "node_modules/cloudflare/resources/addressing/prefixes/bgp/statuses.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Statuses = class extends APIResource {
      static {
        __name(this, "Statuses");
      }
      /**
       * Advertise or withdraw BGP route for a prefix.
       */
      edit(prefixId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/addressing/prefixes/${prefixId}/bgp/status`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List the current advertisement state for a prefix.
       */
      get(prefixId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/addressing/prefixes/${prefixId}/bgp/status`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Statuses3) {
    })(Statuses || (Statuses = {}));
  }
});

// node_modules/cloudflare/resources/addressing/prefixes/bgp/bgp.mjs
var BGP;
var init_bgp = __esm({
  "node_modules/cloudflare/resources/addressing/prefixes/bgp/bgp.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_bindings();
    init_prefixes();
    init_statuses();
    BGP = class extends APIResource {
      static {
        __name(this, "BGP");
      }
      constructor() {
        super(...arguments);
        this.bindings = new Bindings(this._client);
        this.prefixes = new Prefixes(this._client);
        this.statuses = new Statuses(this._client);
      }
    };
    (function(BGP3) {
      BGP3.Bindings = Bindings;
      BGP3.ServiceBindingsSinglePage = ServiceBindingsSinglePage;
      BGP3.Prefixes = Prefixes;
      BGP3.BGPPrefixesSinglePage = BGPPrefixesSinglePage;
      BGP3.Statuses = Statuses;
    })(BGP || (BGP = {}));
  }
});

// node_modules/cloudflare/resources/addressing/prefixes/prefixes.mjs
var Prefixes2, PrefixesSinglePage;
var init_prefixes2 = __esm({
  "node_modules/cloudflare/resources/addressing/prefixes/prefixes.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_prefixes2();
    init_delegations();
    init_bgp();
    init_pagination();
    Prefixes2 = class extends APIResource {
      static {
        __name(this, "Prefixes");
      }
      constructor() {
        super(...arguments);
        this.bgp = new BGP(this._client);
        this.delegations = new Delegations(this._client);
      }
      /**
       * Add a new prefix under the account.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/addressing/prefixes`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List all prefixes owned by the account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/addressing/prefixes`, PrefixesSinglePage, options);
      }
      /**
       * Delete an unapproved prefix owned by the account.
       */
      delete(prefixId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/addressing/prefixes/${prefixId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Modify the description for a prefix owned by the account.
       */
      edit(prefixId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/addressing/prefixes/${prefixId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List a particular prefix owned by the account.
       */
      get(prefixId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/addressing/prefixes/${prefixId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    PrefixesSinglePage = class extends SinglePage {
      static {
        __name(this, "PrefixesSinglePage");
      }
    };
    (function(Prefixes3) {
      Prefixes3.PrefixesSinglePage = PrefixesSinglePage;
      Prefixes3.BGP = BGP;
      Prefixes3.Delegations = Delegations;
      Prefixes3.DelegationsSinglePage = DelegationsSinglePage;
    })(Prefixes2 || (Prefixes2 = {}));
  }
});

// node_modules/cloudflare/resources/addressing/regional-hostnames/regions.mjs
var Regions, RegionListResponsesSinglePage;
var init_regions = __esm({
  "node_modules/cloudflare/resources/addressing/regional-hostnames/regions.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_regions();
    init_pagination();
    Regions = class extends APIResource {
      static {
        __name(this, "Regions");
      }
      /**
       * List all Regional Services regions available for use by this account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/addressing/regional_hostnames/regions`, RegionListResponsesSinglePage, options);
      }
    };
    RegionListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "RegionListResponsesSinglePage");
      }
    };
    (function(Regions3) {
      Regions3.RegionListResponsesSinglePage = RegionListResponsesSinglePage;
    })(Regions || (Regions = {}));
  }
});

// node_modules/cloudflare/resources/addressing/regional-hostnames/regional-hostnames.mjs
var RegionalHostnames, RegionalHostnameListResponsesSinglePage;
var init_regional_hostnames = __esm({
  "node_modules/cloudflare/resources/addressing/regional-hostnames/regional-hostnames.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_regional_hostnames();
    init_regions();
    init_pagination();
    RegionalHostnames = class extends APIResource {
      static {
        __name(this, "RegionalHostnames");
      }
      constructor() {
        super(...arguments);
        this.regions = new Regions(this._client);
      }
      /**
       * Create a new Regional Hostname entry. Cloudflare will only use data centers that
       * are physically located within the chosen region to decrypt and service HTTPS
       * traffic. Learn more about
       * [Regional Services](https://developers.cloudflare.com/data-localization/regional-services/get-started/).
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/addressing/regional_hostnames`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List all Regional Hostnames within a zone.
       */
      list(params, options) {
        const { zone_id } = params;
        return this._client.getAPIList(`/zones/${zone_id}/addressing/regional_hostnames`, RegionalHostnameListResponsesSinglePage, options);
      }
      /**
       * Delete the region configuration for a specific Regional Hostname.
       */
      delete(hostname, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/addressing/regional_hostnames/${hostname}`, options);
      }
      /**
       * Update the configuration for a specific Regional Hostname. Only the region_key
       * of a hostname is mutable.
       */
      edit(hostname, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/addressing/regional_hostnames/${hostname}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch the configuration for a specific Regional Hostname, within a zone.
       */
      get(hostname, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/addressing/regional_hostnames/${hostname}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    RegionalHostnameListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "RegionalHostnameListResponsesSinglePage");
      }
    };
    (function(RegionalHostnames2) {
      RegionalHostnames2.RegionalHostnameListResponsesSinglePage = RegionalHostnameListResponsesSinglePage;
      RegionalHostnames2.Regions = Regions;
      RegionalHostnames2.RegionListResponsesSinglePage = RegionListResponsesSinglePage;
    })(RegionalHostnames || (RegionalHostnames = {}));
  }
});

// node_modules/cloudflare/resources/addressing/addressing.mjs
var Addressing;
var init_addressing = __esm({
  "node_modules/cloudflare/resources/addressing/addressing.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_services();
    init_address_maps();
    init_loa_documents();
    init_prefixes2();
    init_regional_hostnames();
    Addressing = class extends APIResource {
      static {
        __name(this, "Addressing");
      }
      constructor() {
        super(...arguments);
        this.regionalHostnames = new RegionalHostnames(this._client);
        this.services = new Services(this._client);
        this.addressMaps = new AddressMaps(this._client);
        this.loaDocuments = new LOADocuments(this._client);
        this.prefixes = new Prefixes2(this._client);
      }
    };
    (function(Addressing2) {
      Addressing2.RegionalHostnames = RegionalHostnames;
      Addressing2.RegionalHostnameListResponsesSinglePage = RegionalHostnameListResponsesSinglePage;
      Addressing2.Services = Services;
      Addressing2.ServiceListResponsesSinglePage = ServiceListResponsesSinglePage;
      Addressing2.AddressMaps = AddressMaps;
      Addressing2.AddressMapsSinglePage = AddressMapsSinglePage;
      Addressing2.LOADocuments = LOADocuments;
      Addressing2.Prefixes = Prefixes2;
      Addressing2.PrefixesSinglePage = PrefixesSinglePage;
    })(Addressing || (Addressing = {}));
  }
});

// node_modules/cloudflare/resources/alerting/available-alerts.mjs
var AvailableAlerts;
var init_available_alerts = __esm({
  "node_modules/cloudflare/resources/alerting/available-alerts.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    AvailableAlerts = class extends APIResource {
      static {
        __name(this, "AvailableAlerts");
      }
      /**
       * Gets a list of all alert types for which an account is eligible.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/alerting/v3/available_alerts`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(AvailableAlerts2) {
    })(AvailableAlerts || (AvailableAlerts = {}));
  }
});

// node_modules/cloudflare/resources/alerting/history.mjs
var HistoryResource, HistoriesV4PagePaginationArray;
var init_history = __esm({
  "node_modules/cloudflare/resources/alerting/history.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_history();
    init_pagination();
    HistoryResource = class extends APIResource {
      static {
        __name(this, "HistoryResource");
      }
      /**
       * Gets a list of history records for notifications sent to an account. The records
       * are displayed for last `x` number of days based on the zone plan (free = 30, pro
       * = 30, biz = 30, ent = 90).
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/alerting/v3/history`, HistoriesV4PagePaginationArray, { query, ...options });
      }
    };
    HistoriesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "HistoriesV4PagePaginationArray");
      }
    };
    (function(HistoryResource2) {
      HistoryResource2.HistoriesV4PagePaginationArray = HistoriesV4PagePaginationArray;
    })(HistoryResource || (HistoryResource = {}));
  }
});

// node_modules/cloudflare/resources/alerting/policies.mjs
var Policies, PoliciesSinglePage;
var init_policies = __esm({
  "node_modules/cloudflare/resources/alerting/policies.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_policies();
    init_pagination();
    Policies = class extends APIResource {
      static {
        __name(this, "Policies");
      }
      /**
       * Creates a new Notification policy.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/alerting/v3/policies`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a Notification policy.
       */
      update(policyId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/alerting/v3/policies/${policyId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a list of all Notification policies.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/alerting/v3/policies`, PoliciesSinglePage, options);
      }
      /**
       * Delete a Notification policy.
       */
      delete(policyId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/alerting/v3/policies/${policyId}`, options);
      }
      /**
       * Get details for a single policy.
       */
      get(policyId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/alerting/v3/policies/${policyId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    PoliciesSinglePage = class extends SinglePage {
      static {
        __name(this, "PoliciesSinglePage");
      }
    };
    (function(Policies6) {
      Policies6.PoliciesSinglePage = PoliciesSinglePage;
    })(Policies || (Policies = {}));
  }
});

// node_modules/cloudflare/resources/alerting/destinations/eligible.mjs
var Eligible;
var init_eligible = __esm({
  "node_modules/cloudflare/resources/alerting/destinations/eligible.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Eligible = class extends APIResource {
      static {
        __name(this, "Eligible");
      }
      /**
       * Get a list of all delivery mechanism types for which an account is eligible.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/alerting/v3/destinations/eligible`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Eligible2) {
    })(Eligible || (Eligible = {}));
  }
});

// node_modules/cloudflare/resources/alerting/destinations/pagerduty.mjs
var PagerdutyResource;
var init_pagerduty = __esm({
  "node_modules/cloudflare/resources/alerting/destinations/pagerduty.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    PagerdutyResource = class extends APIResource {
      static {
        __name(this, "PagerdutyResource");
      }
      /**
       * Creates a new token for integrating with PagerDuty.
       */
      create(params, options) {
        const { account_id } = params;
        return this._client.post(`/accounts/${account_id}/alerting/v3/destinations/pagerduty/connect`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Deletes all the PagerDuty Services connected to the account.
       */
      delete(params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/alerting/v3/destinations/pagerduty`, options);
      }
      /**
       * Get a list of all configured PagerDuty services.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/alerting/v3/destinations/pagerduty`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Links PagerDuty with the account using the integration token.
       */
      link(tokenId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/alerting/v3/destinations/pagerduty/connect/${tokenId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(PagerdutyResource2) {
    })(PagerdutyResource || (PagerdutyResource = {}));
  }
});

// node_modules/cloudflare/resources/alerting/destinations/webhooks.mjs
var Webhooks, WebhooksSinglePage;
var init_webhooks = __esm({
  "node_modules/cloudflare/resources/alerting/destinations/webhooks.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_webhooks();
    init_pagination();
    Webhooks = class extends APIResource {
      static {
        __name(this, "Webhooks");
      }
      /**
       * Creates a new webhook destination.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/alerting/v3/destinations/webhooks`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a webhook destination.
       */
      update(webhookId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/alerting/v3/destinations/webhooks/${webhookId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Gets a list of all configured webhook destinations.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/alerting/v3/destinations/webhooks`, WebhooksSinglePage, options);
      }
      /**
       * Delete a configured webhook destination.
       */
      delete(webhookId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/alerting/v3/destinations/webhooks/${webhookId}`, options);
      }
      /**
       * Get details for a single webhooks destination.
       */
      get(webhookId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/alerting/v3/destinations/webhooks/${webhookId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    WebhooksSinglePage = class extends SinglePage {
      static {
        __name(this, "WebhooksSinglePage");
      }
    };
    (function(Webhooks3) {
      Webhooks3.Webhooks = Webhooks;
      Webhooks3.WebhooksSinglePage = WebhooksSinglePage;
    })(Webhooks || (Webhooks = {}));
  }
});

// node_modules/cloudflare/resources/alerting/destinations/destinations.mjs
var Destinations;
var init_destinations = __esm({
  "node_modules/cloudflare/resources/alerting/destinations/destinations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_eligible();
    init_pagerduty();
    init_webhooks();
    Destinations = class extends APIResource {
      static {
        __name(this, "Destinations");
      }
      constructor() {
        super(...arguments);
        this.eligible = new Eligible(this._client);
        this.pagerduty = new PagerdutyResource(this._client);
        this.webhooks = new Webhooks(this._client);
      }
    };
    (function(Destinations2) {
      Destinations2.Eligible = Eligible;
      Destinations2.PagerdutyResource = PagerdutyResource;
      Destinations2.Webhooks = Webhooks;
      Destinations2.WebhooksSinglePage = WebhooksSinglePage;
    })(Destinations || (Destinations = {}));
  }
});

// node_modules/cloudflare/resources/alerting/alerting.mjs
var Alerting;
var init_alerting = __esm({
  "node_modules/cloudflare/resources/alerting/alerting.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_available_alerts();
    init_history();
    init_policies();
    init_destinations();
    Alerting = class extends APIResource {
      static {
        __name(this, "Alerting");
      }
      constructor() {
        super(...arguments);
        this.availableAlerts = new AvailableAlerts(this._client);
        this.destinations = new Destinations(this._client);
        this.history = new HistoryResource(this._client);
        this.policies = new Policies(this._client);
      }
    };
    (function(Alerting2) {
      Alerting2.AvailableAlerts = AvailableAlerts;
      Alerting2.Destinations = Destinations;
      Alerting2.HistoryResource = HistoryResource;
      Alerting2.HistoriesV4PagePaginationArray = HistoriesV4PagePaginationArray;
      Alerting2.Policies = Policies;
      Alerting2.PoliciesSinglePage = PoliciesSinglePage;
    })(Alerting || (Alerting = {}));
  }
});

// node_modules/cloudflare/resources/argo/smart-routing.mjs
var SmartRouting;
var init_smart_routing = __esm({
  "node_modules/cloudflare/resources/argo/smart-routing.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    SmartRouting = class extends APIResource {
      static {
        __name(this, "SmartRouting");
      }
      /**
       * Updates enablement of Argo Smart Routing.
       */
      edit(params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/argo/smart_routing`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get Argo Smart Routing setting
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/argo/smart_routing`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(SmartRouting2) {
    })(SmartRouting || (SmartRouting = {}));
  }
});

// node_modules/cloudflare/resources/argo/tiered-caching.mjs
var TieredCaching;
var init_tiered_caching = __esm({
  "node_modules/cloudflare/resources/argo/tiered-caching.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    TieredCaching = class extends APIResource {
      static {
        __name(this, "TieredCaching");
      }
      /**
       * Updates enablement of Tiered Caching
       */
      edit(params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/argo/tiered_caching`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get Tiered Caching setting
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/argo/tiered_caching`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(TieredCaching2) {
    })(TieredCaching || (TieredCaching = {}));
  }
});

// node_modules/cloudflare/resources/argo/argo.mjs
var Argo;
var init_argo = __esm({
  "node_modules/cloudflare/resources/argo/argo.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_smart_routing();
    init_tiered_caching();
    Argo = class extends APIResource {
      static {
        __name(this, "Argo");
      }
      constructor() {
        super(...arguments);
        this.smartRouting = new SmartRouting(this._client);
        this.tieredCaching = new TieredCaching(this._client);
      }
    };
    (function(Argo2) {
      Argo2.SmartRouting = SmartRouting;
      Argo2.TieredCaching = TieredCaching;
    })(Argo || (Argo = {}));
  }
});

// node_modules/cloudflare/resources/audit-logs.mjs
var AuditLogs;
var init_audit_logs = __esm({
  "node_modules/cloudflare/resources/audit-logs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_shared();
    AuditLogs = class extends APIResource {
      static {
        __name(this, "AuditLogs");
      }
      /**
       * Gets a list of audit logs for an account. Can be filtered by who made the
       * change, on which zone, and the timeframe of the change.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/audit_logs`, AuditLogsV4PagePaginationArray, {
          query,
          ...options
        });
      }
    };
  }
});

// node_modules/cloudflare/resources/billing/profiles.mjs
var Profiles;
var init_profiles = __esm({
  "node_modules/cloudflare/resources/billing/profiles.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Profiles = class extends APIResource {
      static {
        __name(this, "Profiles");
      }
      /**
       * Gets the current billing profile for the account.
       */
      get(accountIdentifier, options) {
        return this._client.get(`/accounts/${accountIdentifier}/billing/profile`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Profiles3) {
    })(Profiles || (Profiles = {}));
  }
});

// node_modules/cloudflare/resources/billing/billing.mjs
var Billing;
var init_billing = __esm({
  "node_modules/cloudflare/resources/billing/billing.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_profiles();
    Billing = class extends APIResource {
      static {
        __name(this, "Billing");
      }
      constructor() {
        super(...arguments);
        this.profiles = new Profiles(this._client);
      }
    };
    (function(Billing3) {
      Billing3.Profiles = Profiles;
    })(Billing || (Billing = {}));
  }
});

// node_modules/cloudflare/resources/bot-management.mjs
var BotManagement;
var init_bot_management = __esm({
  "node_modules/cloudflare/resources/bot-management.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    BotManagement = class extends APIResource {
      static {
        __name(this, "BotManagement");
      }
      /**
       * Updates the Bot Management configuration for a zone.
       *
       * This API is used to update:
       *
       * - **Bot Fight Mode**
       * - **Super Bot Fight Mode**
       * - **Bot Management for Enterprise**
       *
       * See [Bot Plans](https://developers.cloudflare.com/bots/plans/) for more
       * information on the different plans
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/bot_management`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Retrieve a zone's Bot Management Config
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/bot_management`, options)._thenUnwrap((obj) => obj.result);
      }
    };
  }
});

// node_modules/cloudflare/resources/brand-protection.mjs
var BrandProtection;
var init_brand_protection = __esm({
  "node_modules/cloudflare/resources/brand-protection.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    BrandProtection = class extends APIResource {
      static {
        __name(this, "BrandProtection");
      }
      /**
       * Submit suspicious URL for scanning
       */
      submit(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/brand-protection/submit`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get results for a URL scan
       */
      urlInfo(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/brand-protection/url-info`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
  }
});

// node_modules/cloudflare/resources/cache/cache-reserve.mjs
var CacheReserveResource;
var init_cache_reserve = __esm({
  "node_modules/cloudflare/resources/cache/cache-reserve.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    CacheReserveResource = class extends APIResource {
      static {
        __name(this, "CacheReserveResource");
      }
      /**
       * You can use Cache Reserve Clear to clear your Cache Reserve, but you must first
       * disable Cache Reserve. In most cases, this will be accomplished within 24 hours.
       * You cannot re-enable Cache Reserve while this process is ongoing. Keep in mind
       * that you cannot undo or cancel this operation.
       */
      clear(params, options) {
        const { zone_id, body } = params;
        return this._client.post(`/zones/${zone_id}/cache/cache_reserve_clear`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Increase cache lifetimes by automatically storing all cacheable files into
       * Cloudflare's persistent object storage buckets. Requires Cache Reserve
       * subscription. Note: using Tiered Cache with Cache Reserve is highly recommended
       * to reduce Reserve operations costs. See the
       * [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve)
       * for more information.
       */
      edit(params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/cache/cache_reserve`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Increase cache lifetimes by automatically storing all cacheable files into
       * Cloudflare's persistent object storage buckets. Requires Cache Reserve
       * subscription. Note: using Tiered Cache with Cache Reserve is highly recommended
       * to reduce Reserve operations costs. See the
       * [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve)
       * for more information.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/cache/cache_reserve`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * You can use Cache Reserve Clear to clear your Cache Reserve, but you must first
       * disable Cache Reserve. In most cases, this will be accomplished within 24 hours.
       * You cannot re-enable Cache Reserve while this process is ongoing. Keep in mind
       * that you cannot undo or cancel this operation.
       */
      status(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/cache/cache_reserve_clear`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(CacheReserveResource2) {
    })(CacheReserveResource || (CacheReserveResource = {}));
  }
});

// node_modules/cloudflare/resources/cache/regional-tiered-cache.mjs
var RegionalTieredCacheResource;
var init_regional_tiered_cache = __esm({
  "node_modules/cloudflare/resources/cache/regional-tiered-cache.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    RegionalTieredCacheResource = class extends APIResource {
      static {
        __name(this, "RegionalTieredCacheResource");
      }
      /**
       * Instructs Cloudflare to check a regional hub data center on the way to your
       * upper tier. This can help improve performance for smart and custom tiered cache
       * topologies.
       */
      edit(params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/cache/regional_tiered_cache`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Instructs Cloudflare to check a regional hub data center on the way to your
       * upper tier. This can help improve performance for smart and custom tiered cache
       * topologies.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/cache/regional_tiered_cache`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(RegionalTieredCacheResource2) {
    })(RegionalTieredCacheResource || (RegionalTieredCacheResource = {}));
  }
});

// node_modules/cloudflare/resources/cache/smart-tiered-cache.mjs
var SmartTieredCache;
var init_smart_tiered_cache = __esm({
  "node_modules/cloudflare/resources/cache/smart-tiered-cache.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    SmartTieredCache = class extends APIResource {
      static {
        __name(this, "SmartTieredCache");
      }
      /**
       * Remvoves enablement of Smart Tiered Cache
       */
      delete(params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/cache/tiered_cache_smart_topology_enable`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates enablement of Tiered Cache
       */
      edit(params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/cache/tiered_cache_smart_topology_enable`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get Smart Tiered Cache setting
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/cache/tiered_cache_smart_topology_enable`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(SmartTieredCache2) {
    })(SmartTieredCache || (SmartTieredCache = {}));
  }
});

// node_modules/cloudflare/resources/cache/variants.mjs
var Variants;
var init_variants = __esm({
  "node_modules/cloudflare/resources/cache/variants.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Variants = class extends APIResource {
      static {
        __name(this, "Variants");
      }
      /**
       * Variant support enables caching variants of images with certain file extensions
       * in addition to the original. This only applies when the origin server sends the
       * 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but
       * does not serve the variant requested, the response will not be cached. This will
       * be indicated with BYPASS cache status in the response headers.
       */
      delete(params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/cache/variants`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Variant support enables caching variants of images with certain file extensions
       * in addition to the original. This only applies when the origin server sends the
       * 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but
       * does not serve the variant requested, the response will not be cached. This will
       * be indicated with BYPASS cache status in the response headers.
       */
      edit(params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/cache/variants`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Variant support enables caching variants of images with certain file extensions
       * in addition to the original. This only applies when the origin server sends the
       * 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but
       * does not serve the variant requested, the response will not be cached. This will
       * be indicated with BYPASS cache status in the response headers.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/cache/variants`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Variants3) {
    })(Variants || (Variants = {}));
  }
});

// node_modules/cloudflare/resources/cache/cache.mjs
var Cache;
var init_cache = __esm({
  "node_modules/cloudflare/resources/cache/cache.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_cache_reserve();
    init_regional_tiered_cache();
    init_smart_tiered_cache();
    init_variants();
    Cache = class extends APIResource {
      static {
        __name(this, "Cache");
      }
      constructor() {
        super(...arguments);
        this.cacheReserve = new CacheReserveResource(this._client);
        this.smartTieredCache = new SmartTieredCache(this._client);
        this.variants = new Variants(this._client);
        this.regionalTieredCache = new RegionalTieredCacheResource(this._client);
      }
      /**
       * ### Purge All Cached Content
       *
       * Removes ALL files from Cloudflare's cache. All tiers can purge everything.
       *
       * ```
       * {"purge_everything": true}
       * ```
       *
       * ### Purge Cached Content by URL
       *
       * Granularly removes one or more files from Cloudflare's cache by specifying URLs.
       * All tiers can purge by URL.
       *
       * To purge files with custom cache keys, include the headers used to compute the
       * cache key as in the example. If you have a device type or geo in your cache key,
       * you will need to include the CF-Device-Type or CF-IPCountry headers. If you have
       * lang in your cache key, you will need to include the Accept-Language header.
       *
       * **NB:** When including the Origin header, be sure to include the **scheme** and
       * **hostname**. The port number can be omitted if it is the default port (80 for
       * http, 443 for https), but must be included otherwise.
       *
       * **NB:** For Zones on Free/Pro/Business plan, you may purge up to 30 URLs in one
       * API call. For Zones on Enterprise plan, you may purge up to 500 URLs in one API
       * call.
       *
       * Single file purge example with files:
       *
       * ```
       * {"files": ["http://www.example.com/css/styles.css", "http://www.example.com/js/index.js"]}
       * ```
       *
       * Single file purge example with url and header pairs:
       *
       * ```
       * {"files": [{url: "http://www.example.com/cat_picture.jpg", headers: { "CF-IPCountry": "US", "CF-Device-Type": "desktop", "Accept-Language": "zh-CN" }}, {url: "http://www.example.com/dog_picture.jpg", headers: { "CF-IPCountry": "EU", "CF-Device-Type": "mobile", "Accept-Language": "en-US" }}]}
       * ```
       *
       * ### Purge Cached Content by Tag, Host or Prefix
       *
       * Granularly removes one or more files from Cloudflare's cache either by
       * specifying the host, the associated Cache-Tag, or a Prefix. Only Enterprise
       * customers are permitted to purge by Tag, Host or Prefix.
       *
       * **NB:** Cache-Tag, host, and prefix purging each have a rate limit of 30,000
       * purge API calls in every 24 hour period. You may purge up to 30 tags, hosts, or
       * prefixes in one API call. This rate limit can be raised for customers who need
       * to purge at higher volume.
       *
       * Flex purge with tags:
       *
       * ```
       * {"tags": ["a-cache-tag", "another-cache-tag"]}
       * ```
       *
       * Flex purge with hosts:
       *
       * ```
       * {"hosts": ["www.example.com", "images.example.com"]}
       * ```
       *
       * Flex purge with prefixes:
       *
       * ```
       * {"prefixes": ["www.example.com/foo", "images.example.com/bar/baz"]}
       * ```
       */
      purge(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/purge_cache`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Cache2) {
      Cache2.CacheReserveResource = CacheReserveResource;
      Cache2.SmartTieredCache = SmartTieredCache;
      Cache2.Variants = Variants;
      Cache2.RegionalTieredCacheResource = RegionalTieredCacheResource;
    })(Cache || (Cache = {}));
  }
});

// node_modules/cloudflare/resources/calls/turn/keys.mjs
var Keys, KeyListResponsesSinglePage;
var init_keys = __esm({
  "node_modules/cloudflare/resources/calls/turn/keys.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_keys();
    init_pagination();
    Keys = class extends APIResource {
      static {
        __name(this, "Keys");
      }
      /**
       * Creates a new Cloudflare Calls TURN key.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/calls/turn_keys`, { body, ...options });
      }
      /**
       * Edit details for a single TURN key.
       */
      update(keyId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/calls/turn_keys/${keyId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists all TURN keys in the Cloudflare account
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/calls/turn_keys`, KeyListResponsesSinglePage, options);
      }
      /**
       * Deletes a TURN key from Cloudflare Calls
       */
      delete(keyId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/calls/turn_keys/${keyId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches details for a single TURN key.
       */
      get(keyId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/calls/turn_keys/${keyId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    KeyListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "KeyListResponsesSinglePage");
      }
    };
    (function(Keys6) {
      Keys6.KeyListResponsesSinglePage = KeyListResponsesSinglePage;
    })(Keys || (Keys = {}));
  }
});

// node_modules/cloudflare/resources/calls/turn/turn.mjs
var TURN;
var init_turn = __esm({
  "node_modules/cloudflare/resources/calls/turn/turn.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_keys();
    TURN = class extends APIResource {
      static {
        __name(this, "TURN");
      }
      constructor() {
        super(...arguments);
        this.keys = new Keys(this._client);
      }
    };
    (function(TURN2) {
      TURN2.Keys = Keys;
      TURN2.KeyListResponsesSinglePage = KeyListResponsesSinglePage;
    })(TURN || (TURN = {}));
  }
});

// node_modules/cloudflare/resources/calls/calls.mjs
var Calls, CallListResponsesSinglePage;
var init_calls = __esm({
  "node_modules/cloudflare/resources/calls/calls.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_turn();
    init_pagination();
    Calls = class extends APIResource {
      static {
        __name(this, "Calls");
      }
      constructor() {
        super(...arguments);
        this.turn = new TURN(this._client);
      }
      /**
       * Creates a new Cloudflare calls app. An app is an unique enviroment where each
       * Session can access all Tracks within the app.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/calls/apps`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Edit details for a single app.
       */
      update(appId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/calls/apps/${appId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists all apps in the Cloudflare account
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/calls/apps`, CallListResponsesSinglePage, options);
      }
      /**
       * Deletes an app from Cloudflare Calls
       */
      delete(appId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/calls/apps/${appId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches details for a single Calls app.
       */
      get(appId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/calls/apps/${appId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    CallListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "CallListResponsesSinglePage");
      }
    };
    (function(Calls2) {
      Calls2.TURN = TURN;
    })(Calls || (Calls = {}));
  }
});

// node_modules/cloudflare/resources/certificate-authorities/hostname-associations.mjs
var HostnameAssociations;
var init_hostname_associations = __esm({
  "node_modules/cloudflare/resources/certificate-authorities/hostname-associations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    HostnameAssociations = class extends APIResource {
      static {
        __name(this, "HostnameAssociations");
      }
      /**
       * Replace Hostname Associations
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/certificate_authorities/hostname_associations`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List Hostname Associations
       */
      get(params, options) {
        const { zone_id, ...query } = params;
        return this._client.get(`/zones/${zone_id}/certificate_authorities/hostname_associations`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(HostnameAssociations2) {
    })(HostnameAssociations || (HostnameAssociations = {}));
  }
});

// node_modules/cloudflare/resources/certificate-authorities/certificate-authorities.mjs
var CertificateAuthorities;
var init_certificate_authorities = __esm({
  "node_modules/cloudflare/resources/certificate-authorities/certificate-authorities.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_hostname_associations();
    CertificateAuthorities = class extends APIResource {
      static {
        __name(this, "CertificateAuthorities");
      }
      constructor() {
        super(...arguments);
        this.hostnameAssociations = new HostnameAssociations(this._client);
      }
    };
    (function(CertificateAuthorities2) {
      CertificateAuthorities2.HostnameAssociations = HostnameAssociations;
    })(CertificateAuthorities || (CertificateAuthorities = {}));
  }
});

// node_modules/cloudflare/resources/challenges/widgets.mjs
var Widgets, WidgetListResponsesV4PagePaginationArray;
var init_widgets = __esm({
  "node_modules/cloudflare/resources/challenges/widgets.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_widgets();
    init_pagination();
    Widgets = class extends APIResource {
      static {
        __name(this, "Widgets");
      }
      /**
       * Lists challenge widgets.
       */
      create(params, options) {
        const { account_id, direction, order, page, per_page, ...body } = params;
        return this._client.post(`/accounts/${account_id}/challenges/widgets`, {
          query: { direction, order, page, per_page },
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update the configuration of a widget.
       */
      update(sitekey, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/challenges/widgets/${sitekey}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists all turnstile widgets of an account.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/challenges/widgets`, WidgetListResponsesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Destroy a Turnstile Widget.
       */
      delete(sitekey, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/challenges/widgets/${sitekey}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Show a single challenge widget configuration.
       */
      get(sitekey, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/challenges/widgets/${sitekey}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Generate a new secret key for this widget. If `invalidate_immediately` is set to
       * `false`, the previous secret remains valid for 2 hours.
       *
       * Note that secrets cannot be rotated again during the grace period.
       */
      rotateSecret(sitekey, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/challenges/widgets/${sitekey}/rotate_secret`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    WidgetListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "WidgetListResponsesV4PagePaginationArray");
      }
    };
    (function(Widgets2) {
      Widgets2.WidgetListResponsesV4PagePaginationArray = WidgetListResponsesV4PagePaginationArray;
    })(Widgets || (Widgets = {}));
  }
});

// node_modules/cloudflare/resources/challenges/challenges.mjs
var Challenges;
var init_challenges = __esm({
  "node_modules/cloudflare/resources/challenges/challenges.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_widgets();
    Challenges = class extends APIResource {
      static {
        __name(this, "Challenges");
      }
      constructor() {
        super(...arguments);
        this.widgets = new Widgets(this._client);
      }
    };
    (function(Challenges2) {
      Challenges2.Widgets = Widgets;
      Challenges2.WidgetListResponsesV4PagePaginationArray = WidgetListResponsesV4PagePaginationArray;
    })(Challenges || (Challenges = {}));
  }
});

// node_modules/cloudflare/resources/client-certificates.mjs
var ClientCertificates, ClientCertificatesV4PagePaginationArray;
var init_client_certificates = __esm({
  "node_modules/cloudflare/resources/client-certificates.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_pagination();
    ClientCertificates = class extends APIResource {
      static {
        __name(this, "ClientCertificates");
      }
      /**
       * Create a new API Shield mTLS Client Certificate
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/client_certificates`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List all of your Zone's API Shield mTLS Client Certificates by Status and/or
       * using Pagination
       */
      list(params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/client_certificates`, ClientCertificatesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Set a API Shield mTLS Client Certificate to pending_revocation status for
       * processing to revoked status.
       */
      delete(clientCertificateId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/client_certificates/${clientCertificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * If a API Shield mTLS Client Certificate is in a pending_revocation state, you
       * may reactivate it with this endpoint.
       */
      edit(clientCertificateId, params, options) {
        const { zone_id } = params;
        return this._client.patch(`/zones/${zone_id}/client_certificates/${clientCertificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get Details for a single mTLS API Shield Client Certificate
       */
      get(clientCertificateId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/client_certificates/${clientCertificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ClientCertificatesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "ClientCertificatesV4PagePaginationArray");
      }
    };
  }
});

// node_modules/cloudflare/resources/cloud-connector/rules.mjs
var Rules, RuleListResponsesSinglePage;
var init_rules = __esm({
  "node_modules/cloudflare/resources/cloud-connector/rules.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_rules();
    init_pagination();
    Rules = class extends APIResource {
      static {
        __name(this, "Rules");
      }
      /**
       * Put Rules
       */
      update(params, options) {
        const { zone_id, body } = params;
        return this._client.put(`/zones/${zone_id}/cloud_connector/rules`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Rules
       */
      list(params, options) {
        const { zone_id } = params;
        return this._client.getAPIList(`/zones/${zone_id}/cloud_connector/rules`, RuleListResponsesSinglePage, options);
      }
    };
    RuleListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "RuleListResponsesSinglePage");
      }
    };
    (function(Rules12) {
      Rules12.RuleListResponsesSinglePage = RuleListResponsesSinglePage;
    })(Rules || (Rules = {}));
  }
});

// node_modules/cloudflare/resources/cloud-connector/cloud-connector.mjs
var CloudConnector;
var init_cloud_connector = __esm({
  "node_modules/cloudflare/resources/cloud-connector/cloud-connector.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_rules();
    CloudConnector = class extends APIResource {
      static {
        __name(this, "CloudConnector");
      }
      constructor() {
        super(...arguments);
        this.rules = new Rules(this._client);
      }
    };
    (function(CloudConnector2) {
      CloudConnector2.Rules = Rules;
      CloudConnector2.RuleListResponsesSinglePage = RuleListResponsesSinglePage;
    })(CloudConnector || (CloudConnector = {}));
  }
});

// node_modules/cloudflare/resources/cloudforce-one/requests/message.mjs
var MessageResource;
var init_message = __esm({
  "node_modules/cloudflare/resources/cloudforce-one/requests/message.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    MessageResource = class extends APIResource {
      static {
        __name(this, "MessageResource");
      }
      /**
       * Creating a request adds the request into the Cloudforce One queue for analysis.
       * In addition to the content, a short title, type, priority, and releasability
       * should be provided. If one is not provided a default will be assigned.
       */
      create(accountIdentifier, requestIdentifier, body, options) {
        return this._client.post(`/accounts/${accountIdentifier}/cloudforce-one/requests/${requestIdentifier}/message/new`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a Request Message
       */
      update(accountIdentifier, requestIdentifier, messageIdentifer, body, options) {
        return this._client.put(`/accounts/${accountIdentifier}/cloudforce-one/requests/${requestIdentifier}/message/${messageIdentifer}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Delete a Request Message
       */
      delete(accountIdentifier, requestIdentifier, messageIdentifer, options) {
        return this._client.delete(`/accounts/${accountIdentifier}/cloudforce-one/requests/${requestIdentifier}/message/${messageIdentifer}`, options);
      }
      /**
       * List Request Messages
       */
      get(accountIdentifier, requestIdentifier, body, options) {
        return this._client.post(`/accounts/${accountIdentifier}/cloudforce-one/requests/${requestIdentifier}/message`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(MessageResource2) {
    })(MessageResource || (MessageResource = {}));
  }
});

// node_modules/cloudflare/resources/cloudforce-one/requests/priority.mjs
var PriorityResource;
var init_priority = __esm({
  "node_modules/cloudflare/resources/cloudforce-one/requests/priority.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    PriorityResource = class extends APIResource {
      static {
        __name(this, "PriorityResource");
      }
      /**
       * Create a New Priority Requirement
       */
      create(accountIdentifier, body, options) {
        return this._client.post(`/accounts/${accountIdentifier}/cloudforce-one/requests/priority/new`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a Priority Intelligence Requirement
       */
      update(accountIdentifier, priorityIdentifer, body, options) {
        return this._client.put(`/accounts/${accountIdentifier}/cloudforce-one/requests/priority/${priorityIdentifer}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Delete a Priority Intelligence Report
       */
      delete(accountIdentifier, priorityIdentifer, options) {
        return this._client.delete(`/accounts/${accountIdentifier}/cloudforce-one/requests/priority/${priorityIdentifer}`, options);
      }
      /**
       * Get a Priority Intelligence Requirement
       */
      get(accountIdentifier, priorityIdentifer, options) {
        return this._client.get(`/accounts/${accountIdentifier}/cloudforce-one/requests/priority/${priorityIdentifer}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get Priority Intelligence Requirement Quota
       */
      quota(accountIdentifier, options) {
        return this._client.get(`/accounts/${accountIdentifier}/cloudforce-one/requests/priority/quota`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(PriorityResource2) {
    })(PriorityResource || (PriorityResource = {}));
  }
});

// node_modules/cloudflare/resources/cloudforce-one/requests/requests.mjs
var Requests, ListItemsV4PagePaginationArray;
var init_requests = __esm({
  "node_modules/cloudflare/resources/cloudforce-one/requests/requests.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_requests();
    init_message();
    init_priority();
    init_pagination();
    Requests = class extends APIResource {
      static {
        __name(this, "Requests");
      }
      constructor() {
        super(...arguments);
        this.message = new MessageResource(this._client);
        this.priority = new PriorityResource(this._client);
      }
      /**
       * Creating a request adds the request into the Cloudforce One queue for analysis.
       * In addition to the content, a short title, type, priority, and releasability
       * should be provided. If one is not provided a default will be assigned.
       */
      create(accountIdentifier, body, options) {
        return this._client.post(`/accounts/${accountIdentifier}/cloudforce-one/requests/new`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updating a request alters the request in the Cloudforce One queue. This API may
       * be used to update any attributes of the request after the initial submission.
       * Only fields that you choose to update need to be add to the request body
       */
      update(accountIdentifier, requestIdentifier, body, options) {
        return this._client.put(`/accounts/${accountIdentifier}/cloudforce-one/requests/${requestIdentifier}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List Requests
       */
      list(accountIdentifier, body, options) {
        return this._client.getAPIList(`/accounts/${accountIdentifier}/cloudforce-one/requests`, ListItemsV4PagePaginationArray, { body, method: "post", ...options });
      }
      /**
       * Delete a Request
       */
      delete(accountIdentifier, requestIdentifier, options) {
        return this._client.delete(`/accounts/${accountIdentifier}/cloudforce-one/requests/${requestIdentifier}`, options);
      }
      /**
       * Get Request Priority, Status, and TLP constants
       */
      constants(accountIdentifier, options) {
        return this._client.get(`/accounts/${accountIdentifier}/cloudforce-one/requests/constants`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a Request
       */
      get(accountIdentifier, requestIdentifier, options) {
        return this._client.get(`/accounts/${accountIdentifier}/cloudforce-one/requests/${requestIdentifier}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get Request Quota
       */
      quota(accountIdentifier, options) {
        return this._client.get(`/accounts/${accountIdentifier}/cloudforce-one/requests/quota`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get Request Types
       */
      types(accountIdentifier, options) {
        return this._client.get(`/accounts/${accountIdentifier}/cloudforce-one/requests/types`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ListItemsV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "ListItemsV4PagePaginationArray");
      }
    };
    (function(Requests2) {
      Requests2.ListItemsV4PagePaginationArray = ListItemsV4PagePaginationArray;
      Requests2.MessageResource = MessageResource;
      Requests2.PriorityResource = PriorityResource;
    })(Requests || (Requests = {}));
  }
});

// node_modules/cloudflare/resources/cloudforce-one/cloudforce-one.mjs
var CloudforceOne;
var init_cloudforce_one = __esm({
  "node_modules/cloudflare/resources/cloudforce-one/cloudforce-one.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_requests();
    CloudforceOne = class extends APIResource {
      static {
        __name(this, "CloudforceOne");
      }
      constructor() {
        super(...arguments);
        this.requests = new Requests(this._client);
      }
    };
    (function(CloudforceOne2) {
      CloudforceOne2.Requests = Requests;
      CloudforceOne2.ListItemsV4PagePaginationArray = ListItemsV4PagePaginationArray;
    })(CloudforceOne || (CloudforceOne = {}));
  }
});

// node_modules/cloudflare/resources/custom-certificates/prioritize.mjs
var Prioritize;
var init_prioritize = __esm({
  "node_modules/cloudflare/resources/custom-certificates/prioritize.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Prioritize = class extends APIResource {
      static {
        __name(this, "Prioritize");
      }
      /**
       * If a zone has multiple SSL certificates, you can set the order in which they
       * should be used during a request. The higher priority will break ties across
       * overlapping 'legacy_custom' certificates.
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/custom_certificates/prioritize`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Prioritize2) {
    })(Prioritize || (Prioritize = {}));
  }
});

// node_modules/cloudflare/resources/custom-certificates/custom-certificates.mjs
var CustomCertificates, CustomCertificatesV4PagePaginationArray;
var init_custom_certificates = __esm({
  "node_modules/cloudflare/resources/custom-certificates/custom-certificates.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_prioritize();
    init_pagination();
    CustomCertificates = class extends APIResource {
      static {
        __name(this, "CustomCertificates");
      }
      constructor() {
        super(...arguments);
        this.prioritize = new Prioritize(this._client);
      }
      /**
       * Upload a new SSL certificate for a zone.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/custom_certificates`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List, search, and filter all of your custom SSL certificates. The higher
       * priority will break ties across overlapping 'legacy_custom' certificates, but
       * 'legacy_custom' certificates will always supercede 'sni_custom' certificates.
       */
      list(params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/custom_certificates`, CustomCertificatesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Remove a SSL certificate from a zone.
       */
      delete(customCertificateId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/custom_certificates/${customCertificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Upload a new private key and/or PEM/CRT for the SSL certificate. Note: PATCHing
       * a configuration for sni_custom certificates will result in a new resource id
       * being returned, and the previous one being deleted.
       */
      edit(customCertificateId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/custom_certificates/${customCertificateId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * SSL Configuration Details
       */
      get(customCertificateId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/custom_certificates/${customCertificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    CustomCertificatesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "CustomCertificatesV4PagePaginationArray");
      }
    };
    (function(CustomCertificates2) {
      CustomCertificates2.Prioritize = Prioritize;
    })(CustomCertificates || (CustomCertificates = {}));
  }
});

// node_modules/cloudflare/resources/custom-hostnames/fallback-origin.mjs
var FallbackOrigin;
var init_fallback_origin = __esm({
  "node_modules/cloudflare/resources/custom-hostnames/fallback-origin.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    FallbackOrigin = class extends APIResource {
      static {
        __name(this, "FallbackOrigin");
      }
      /**
       * Update Fallback Origin for Custom Hostnames
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/custom_hostnames/fallback_origin`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Delete Fallback Origin for Custom Hostnames
       */
      delete(params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/custom_hostnames/fallback_origin`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get Fallback Origin for Custom Hostnames
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/custom_hostnames/fallback_origin`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(FallbackOrigin2) {
    })(FallbackOrigin || (FallbackOrigin = {}));
  }
});

// node_modules/cloudflare/resources/custom-hostnames/custom-hostnames.mjs
var CustomHostnames, CustomHostnameListResponsesV4PagePaginationArray;
var init_custom_hostnames = __esm({
  "node_modules/cloudflare/resources/custom-hostnames/custom-hostnames.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_fallback_origin();
    init_pagination();
    CustomHostnames = class extends APIResource {
      static {
        __name(this, "CustomHostnames");
      }
      constructor() {
        super(...arguments);
        this.fallbackOrigin = new FallbackOrigin(this._client);
      }
      /**
       * Add a new custom hostname and request that an SSL certificate be issued for it.
       * One of three validation methodshttp, txt, emailshould be used, with 'http'
       * recommended if the CNAME is already in place (or will be soon). Specifying
       * 'email' will send an email to the WHOIS contacts on file for the base domain
       * plus hostmaster, postmaster, webmaster, admin, administrator. If http is used
       * and the domain is not already pointing to the Managed CNAME host, the PATCH
       * method must be used once it is (to complete validation).
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/custom_hostnames`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List, search, sort, and filter all of your custom hostnames.
       */
      list(params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/custom_hostnames`, CustomHostnameListResponsesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Delete Custom Hostname (and any issued SSL certificates)
       */
      delete(customHostnameId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/custom_hostnames/${customHostnameId}`, options);
      }
      /**
       * Modify SSL configuration for a custom hostname. When sent with SSL config that
       * matches existing config, used to indicate that hostname should pass domain
       * control validation (DCV). Can also be used to change validation type, e.g., from
       * 'http' to 'email'.
       */
      edit(customHostnameId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/custom_hostnames/${customHostnameId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Custom Hostname Details
       */
      get(customHostnameId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/custom_hostnames/${customHostnameId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    CustomHostnameListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "CustomHostnameListResponsesV4PagePaginationArray");
      }
    };
    (function(CustomHostnames2) {
      CustomHostnames2.FallbackOrigin = FallbackOrigin;
    })(CustomHostnames || (CustomHostnames = {}));
  }
});

// node_modules/cloudflare/resources/custom-nameservers.mjs
var CustomNameservers;
var init_custom_nameservers = __esm({
  "node_modules/cloudflare/resources/custom-nameservers.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    CustomNameservers = class extends APIResource {
      static {
        __name(this, "CustomNameservers");
      }
      /**
       * Add Account Custom Nameserver
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/custom_ns`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Delete Account Custom Nameserver
       */
      delete(customNSId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/custom_ns/${customNSId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get Eligible Zones for Account Custom Nameservers
       */
      availabilty(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/custom_ns/availability`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * List an account's custom nameservers.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/custom_ns`, options)._thenUnwrap((obj) => obj.result);
      }
    };
  }
});

// node_modules/cloudflare/resources/d1/database.mjs
var Database, DatabaseListResponsesV4PagePaginationArray;
var init_database = __esm({
  "node_modules/cloudflare/resources/d1/database.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_database();
    init_pagination();
    Database = class extends APIResource {
      static {
        __name(this, "Database");
      }
      /**
       * Returns the created D1 database.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/d1/database`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Returns a list of D1 databases.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/d1/database`, DatabaseListResponsesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Deletes the specified D1 database.
       */
      delete(databaseId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/d1/database/${databaseId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Returns the specified D1 database.
       */
      get(databaseId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/d1/database/${databaseId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Returns the query result as an object.
       */
      query(databaseId, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/d1/database/${databaseId}/query`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Returns the query result rows as arrays rather than objects. This is a
       * performance-optimized version of the /query endpoint.
       */
      raw(databaseId, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/d1/database/${databaseId}/raw`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    DatabaseListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "DatabaseListResponsesV4PagePaginationArray");
      }
    };
    (function(Database3) {
      Database3.DatabaseListResponsesV4PagePaginationArray = DatabaseListResponsesV4PagePaginationArray;
    })(Database || (Database = {}));
  }
});

// node_modules/cloudflare/resources/d1/d1.mjs
var D1Resource;
var init_d1 = __esm({
  "node_modules/cloudflare/resources/d1/d1.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_database();
    D1Resource = class extends APIResource {
      static {
        __name(this, "D1Resource");
      }
      constructor() {
        super(...arguments);
        this.database = new Database(this._client);
      }
    };
    (function(D1Resource2) {
      D1Resource2.Database = Database;
      D1Resource2.DatabaseListResponsesV4PagePaginationArray = DatabaseListResponsesV4PagePaginationArray;
    })(D1Resource || (D1Resource = {}));
  }
});

// node_modules/cloudflare/resources/dcv-delegation.mjs
var DCVDelegation;
var init_dcv_delegation = __esm({
  "node_modules/cloudflare/resources/dcv-delegation.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    DCVDelegation = class extends APIResource {
      static {
        __name(this, "DCVDelegation");
      }
      /**
       * Retrieve the account and zone specific unique identifier used as part of the
       * CNAME target for DCV Delegation.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/dcv_delegation/uuid`, options)._thenUnwrap((obj) => obj.result);
      }
    };
  }
});

// node_modules/cloudflare/resources/dns/records.mjs
var Records, RecordsV4PagePaginationArray;
var init_records = __esm({
  "node_modules/cloudflare/resources/dns/records.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_records();
    init_pagination();
    Records = class extends APIResource {
      static {
        __name(this, "Records");
      }
      /**
       * Create a new DNS record for a zone.
       *
       * Notes:
       *
       * - A/AAAA records cannot exist on the same name as CNAME records.
       * - NS records cannot exist on the same name as any other record type.
       * - Domain names are always represented in Punycode, even if Unicode characters
       *   were used when creating the record.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/dns_records`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Overwrite an existing DNS record. Notes:
       *
       * - A/AAAA records cannot exist on the same name as CNAME records.
       * - NS records cannot exist on the same name as any other record type.
       * - Domain names are always represented in Punycode, even if Unicode characters
       *   were used when creating the record.
       */
      update(dnsRecordId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/dns_records/${dnsRecordId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List, search, sort, and filter a zones' DNS records.
       */
      list(params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/dns_records`, RecordsV4PagePaginationArray, {
          query,
          ...options
        });
      }
      /**
       * Delete DNS Record
       */
      delete(dnsRecordId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/dns_records/${dnsRecordId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update an existing DNS record. Notes:
       *
       * - A/AAAA records cannot exist on the same name as CNAME records.
       * - NS records cannot exist on the same name as any other record type.
       * - Domain names are always represented in Punycode, even if Unicode characters
       *   were used when creating the record.
       */
      edit(dnsRecordId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/dns_records/${dnsRecordId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * You can export your
       * [BIND config](https://en.wikipedia.org/wiki/Zone_file "Zone file") through this
       * endpoint.
       *
       * See
       * [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ "Import and export records")
       * for more information.
       */
      export(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/dns_records/export`, {
          ...options,
          headers: { Accept: "text/plain", ...options?.headers }
        });
      }
      /**
       * DNS Record Details
       */
      get(dnsRecordId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/dns_records/${dnsRecordId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * You can upload your
       * [BIND config](https://en.wikipedia.org/wiki/Zone_file "Zone file") through this
       * endpoint. It assumes that cURL is called from a location with bind_config.txt
       * (valid BIND config) present.
       *
       * See
       * [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ "Import and export records")
       * for more information.
       */
      import(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/dns_records/import`, multipartFormRequestOptions({ body, ...options }))._thenUnwrap((obj) => obj.result);
      }
      /**
       * Scan for common DNS records on your domain and automatically add them to your
       * zone. Useful if you haven't updated your nameservers yet.
       */
      scan(params, options) {
        const { zone_id, body } = params;
        return this._client.post(`/zones/${zone_id}/dns_records/scan`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    RecordsV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "RecordsV4PagePaginationArray");
      }
    };
    (function(Records2) {
      Records2.RecordsV4PagePaginationArray = RecordsV4PagePaginationArray;
    })(Records || (Records = {}));
  }
});

// node_modules/cloudflare/resources/dns/settings.mjs
var Settings2;
var init_settings2 = __esm({
  "node_modules/cloudflare/resources/dns/settings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    Settings2 = class extends APIResource {
      static {
        __name(this, "Settings");
      }
      /**
       * Update DNS settings for an account or zone
       */
      edit(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.patch(`/${accountOrZone}/${accountOrZoneId}/dns_settings`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      get(params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get({}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/dns_settings`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Settings13) {
    })(Settings2 || (Settings2 = {}));
  }
});

// node_modules/cloudflare/resources/dns/analytics/reports/bytimes.mjs
var Bytimes;
var init_bytimes = __esm({
  "node_modules/cloudflare/resources/dns/analytics/reports/bytimes.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Bytimes = class extends APIResource {
      static {
        __name(this, "Bytimes");
      }
      /**
       * Retrieves a list of aggregate metrics grouped by time interval.
       *
       * See
       * [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/)
       * for detailed information about the available query parameters.
       */
      get(params, options) {
        const { zone_id, ...query } = params;
        return this._client.get(`/zones/${zone_id}/dns_analytics/report/bytime`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Bytimes4) {
    })(Bytimes || (Bytimes = {}));
  }
});

// node_modules/cloudflare/resources/dns/analytics/reports/reports.mjs
var Reports;
var init_reports = __esm({
  "node_modules/cloudflare/resources/dns/analytics/reports/reports.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_bytimes();
    Reports = class extends APIResource {
      static {
        __name(this, "Reports");
      }
      constructor() {
        super(...arguments);
        this.bytimes = new Bytimes(this._client);
      }
      /**
       * Retrieves a list of summarised aggregate metrics over a given time period.
       *
       * See
       * [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/)
       * for detailed information about the available query parameters.
       */
      get(params, options) {
        const { zone_id, ...query } = params;
        return this._client.get(`/zones/${zone_id}/dns_analytics/report`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Reports3) {
      Reports3.Bytimes = Bytimes;
    })(Reports || (Reports = {}));
  }
});

// node_modules/cloudflare/resources/dns/analytics/analytics.mjs
var Analytics;
var init_analytics = __esm({
  "node_modules/cloudflare/resources/dns/analytics/analytics.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_reports();
    Analytics = class extends APIResource {
      static {
        __name(this, "Analytics");
      }
      constructor() {
        super(...arguments);
        this.reports = new Reports(this._client);
      }
    };
    (function(Analytics5) {
      Analytics5.Reports = Reports;
    })(Analytics || (Analytics = {}));
  }
});

// node_modules/cloudflare/resources/dns/firewall/analytics/reports/bytimes.mjs
var Bytimes2;
var init_bytimes2 = __esm({
  "node_modules/cloudflare/resources/dns/firewall/analytics/reports/bytimes.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Bytimes2 = class extends APIResource {
      static {
        __name(this, "Bytimes");
      }
      /**
       * Retrieves a list of aggregate metrics grouped by time interval.
       *
       * See
       * [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/)
       * for detailed information about the available query parameters.
       */
      get(dnsFirewallId, params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/dns_firewall/${dnsFirewallId}/dns_analytics/report/bytime`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Bytimes4) {
    })(Bytimes2 || (Bytimes2 = {}));
  }
});

// node_modules/cloudflare/resources/dns/firewall/analytics/reports/reports.mjs
var Reports2;
var init_reports2 = __esm({
  "node_modules/cloudflare/resources/dns/firewall/analytics/reports/reports.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_bytimes2();
    Reports2 = class extends APIResource {
      static {
        __name(this, "Reports");
      }
      constructor() {
        super(...arguments);
        this.bytimes = new Bytimes2(this._client);
      }
      /**
       * Retrieves a list of summarised aggregate metrics over a given time period.
       *
       * See
       * [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/)
       * for detailed information about the available query parameters.
       */
      get(dnsFirewallId, params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/dns_firewall/${dnsFirewallId}/dns_analytics/report`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Reports3) {
      Reports3.Bytimes = Bytimes2;
    })(Reports2 || (Reports2 = {}));
  }
});

// node_modules/cloudflare/resources/dns/firewall/analytics/analytics.mjs
var Analytics2;
var init_analytics2 = __esm({
  "node_modules/cloudflare/resources/dns/firewall/analytics/analytics.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_reports2();
    Analytics2 = class extends APIResource {
      static {
        __name(this, "Analytics");
      }
      constructor() {
        super(...arguments);
        this.reports = new Reports2(this._client);
      }
    };
    (function(Analytics5) {
      Analytics5.Reports = Reports2;
    })(Analytics2 || (Analytics2 = {}));
  }
});

// node_modules/cloudflare/resources/dns/firewall/firewall.mjs
var FirewallResource, FirewallsV4PagePaginationArray;
var init_firewall = __esm({
  "node_modules/cloudflare/resources/dns/firewall/firewall.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_firewall();
    init_analytics2();
    init_pagination();
    FirewallResource = class extends APIResource {
      static {
        __name(this, "FirewallResource");
      }
      constructor() {
        super(...arguments);
        this.analytics = new Analytics2(this._client);
      }
      /**
       * Create a configured DNS Firewall Cluster.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/dns_firewall`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List configured DNS Firewall clusters for an account.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/dns_firewall`, FirewallsV4PagePaginationArray, {
          query,
          ...options
        });
      }
      /**
       * Delete a configured DNS Firewall Cluster.
       */
      delete(dnsFirewallId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/dns_firewall/${dnsFirewallId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Modify a DNS Firewall Cluster configuration.
       */
      edit(dnsFirewallId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/dns_firewall/${dnsFirewallId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Show a single configured DNS Firewall cluster for an account.
       */
      get(dnsFirewallId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/dns_firewall/${dnsFirewallId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    FirewallsV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "FirewallsV4PagePaginationArray");
      }
    };
    (function(FirewallResource2) {
      FirewallResource2.FirewallsV4PagePaginationArray = FirewallsV4PagePaginationArray;
      FirewallResource2.Analytics = Analytics2;
    })(FirewallResource || (FirewallResource = {}));
  }
});

// node_modules/cloudflare/resources/dns/dns.mjs
var DNS;
var init_dns = __esm({
  "node_modules/cloudflare/resources/dns/dns.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_records();
    init_settings2();
    init_analytics();
    init_firewall();
    DNS = class extends APIResource {
      static {
        __name(this, "DNS");
      }
      constructor() {
        super(...arguments);
        this.records = new Records(this._client);
        this.settings = new Settings2(this._client);
        this.analytics = new Analytics(this._client);
        this.firewall = new FirewallResource(this._client);
      }
    };
    (function(DNS5) {
      DNS5.Records = Records;
      DNS5.RecordsV4PagePaginationArray = RecordsV4PagePaginationArray;
      DNS5.Settings = Settings2;
      DNS5.Analytics = Analytics;
      DNS5.FirewallResource = FirewallResource;
      DNS5.FirewallsV4PagePaginationArray = FirewallsV4PagePaginationArray;
    })(DNS || (DNS = {}));
  }
});

// node_modules/cloudflare/resources/dnssec.mjs
var DNSSECResource;
var init_dnssec = __esm({
  "node_modules/cloudflare/resources/dnssec.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    DNSSECResource = class extends APIResource {
      static {
        __name(this, "DNSSECResource");
      }
      /**
       * Delete DNSSEC.
       */
      delete(params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/dnssec`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Enable or disable DNSSEC.
       */
      edit(params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/dnssec`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Details about DNSSEC status and configuration.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/dnssec`, options)._thenUnwrap((obj) => obj.result);
      }
    };
  }
});

// node_modules/cloudflare/resources/diagnostics/traceroutes.mjs
var Traceroutes;
var init_traceroutes = __esm({
  "node_modules/cloudflare/resources/diagnostics/traceroutes.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Traceroutes = class extends APIResource {
      static {
        __name(this, "Traceroutes");
      }
      /**
       * Run traceroutes from Cloudflare colos.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/diagnostics/traceroute`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Traceroutes2) {
    })(Traceroutes || (Traceroutes = {}));
  }
});

// node_modules/cloudflare/resources/diagnostics/diagnostics.mjs
var Diagnostics;
var init_diagnostics = __esm({
  "node_modules/cloudflare/resources/diagnostics/diagnostics.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_traceroutes();
    Diagnostics = class extends APIResource {
      static {
        __name(this, "Diagnostics");
      }
      constructor() {
        super(...arguments);
        this.traceroutes = new Traceroutes(this._client);
      }
    };
    (function(Diagnostics2) {
      Diagnostics2.Traceroutes = Traceroutes;
    })(Diagnostics || (Diagnostics = {}));
  }
});

// node_modules/cloudflare/resources/durable-objects/namespaces/objects.mjs
var Objects, DurableObjectsCursorLimitPagination;
var init_objects = __esm({
  "node_modules/cloudflare/resources/durable-objects/namespaces/objects.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_objects();
    init_pagination();
    Objects = class extends APIResource {
      static {
        __name(this, "Objects");
      }
      /**
       * Returns the Durable Objects in a given namespace.
       */
      list(id, params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/workers/durable_objects/namespaces/${id}/objects`, DurableObjectsCursorLimitPagination, { query, ...options });
      }
    };
    DurableObjectsCursorLimitPagination = class extends CursorLimitPagination {
      static {
        __name(this, "DurableObjectsCursorLimitPagination");
      }
    };
    (function(Objects2) {
      Objects2.DurableObjectsCursorLimitPagination = DurableObjectsCursorLimitPagination;
    })(Objects || (Objects = {}));
  }
});

// node_modules/cloudflare/resources/durable-objects/namespaces/namespaces.mjs
var Namespaces, NamespacesSinglePage;
var init_namespaces = __esm({
  "node_modules/cloudflare/resources/durable-objects/namespaces/namespaces.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_namespaces();
    init_objects();
    init_pagination();
    Namespaces = class extends APIResource {
      static {
        __name(this, "Namespaces");
      }
      constructor() {
        super(...arguments);
        this.objects = new Objects(this._client);
      }
      /**
       * Returns the Durable Object namespaces owned by an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/workers/durable_objects/namespaces`, NamespacesSinglePage, options);
      }
    };
    NamespacesSinglePage = class extends SinglePage {
      static {
        __name(this, "NamespacesSinglePage");
      }
    };
    (function(Namespaces4) {
      Namespaces4.NamespacesSinglePage = NamespacesSinglePage;
      Namespaces4.Objects = Objects;
      Namespaces4.DurableObjectsCursorLimitPagination = DurableObjectsCursorLimitPagination;
    })(Namespaces || (Namespaces = {}));
  }
});

// node_modules/cloudflare/resources/durable-objects/durable-objects.mjs
var DurableObjects;
var init_durable_objects = __esm({
  "node_modules/cloudflare/resources/durable-objects/durable-objects.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_namespaces();
    DurableObjects = class extends APIResource {
      static {
        __name(this, "DurableObjects");
      }
      constructor() {
        super(...arguments);
        this.namespaces = new Namespaces(this._client);
      }
    };
    (function(DurableObjects2) {
      DurableObjects2.Namespaces = Namespaces;
      DurableObjects2.NamespacesSinglePage = NamespacesSinglePage;
    })(DurableObjects || (DurableObjects = {}));
  }
});

// node_modules/cloudflare/resources/email-routing/addresses.mjs
var Addresses, AddressesV4PagePaginationArray;
var init_addresses = __esm({
  "node_modules/cloudflare/resources/email-routing/addresses.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_addresses();
    init_pagination();
    Addresses = class extends APIResource {
      static {
        __name(this, "Addresses");
      }
      /**
       * Create a destination address to forward your emails to. Destination addresses
       * need to be verified before they can be used.
       */
      create(accountIdentifier, body, options) {
        return this._client.post(`/accounts/${accountIdentifier}/email/routing/addresses`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      list(accountIdentifier, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list(accountIdentifier, {}, query);
        }
        return this._client.getAPIList(`/accounts/${accountIdentifier}/email/routing/addresses`, AddressesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Deletes a specific destination address.
       */
      delete(accountIdentifier, destinationAddressIdentifier, options) {
        return this._client.delete(`/accounts/${accountIdentifier}/email/routing/addresses/${destinationAddressIdentifier}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Gets information for a specific destination email already created.
       */
      get(accountIdentifier, destinationAddressIdentifier, options) {
        return this._client.get(`/accounts/${accountIdentifier}/email/routing/addresses/${destinationAddressIdentifier}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    AddressesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "AddressesV4PagePaginationArray");
      }
    };
    (function(Addresses2) {
      Addresses2.AddressesV4PagePaginationArray = AddressesV4PagePaginationArray;
    })(Addresses || (Addresses = {}));
  }
});

// node_modules/cloudflare/resources/email-routing/dns.mjs
var DNS2;
var init_dns2 = __esm({
  "node_modules/cloudflare/resources/email-routing/dns.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    DNS2 = class extends APIResource {
      static {
        __name(this, "DNS");
      }
      /**
       * Show the DNS records needed to configure your Email Routing zone.
       */
      get(zoneIdentifier, options) {
        return this._client.get(`/zones/${zoneIdentifier}/email/routing/dns`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(DNS5) {
    })(DNS2 || (DNS2 = {}));
  }
});

// node_modules/cloudflare/resources/email-routing/rules/catch-alls.mjs
var CatchAlls;
var init_catch_alls = __esm({
  "node_modules/cloudflare/resources/email-routing/rules/catch-alls.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    CatchAlls = class extends APIResource {
      static {
        __name(this, "CatchAlls");
      }
      /**
       * Enable or disable catch-all routing rule, or change action to forward to
       * specific destination address.
       */
      update(zoneIdentifier, body, options) {
        return this._client.put(`/zones/${zoneIdentifier}/email/routing/rules/catch_all`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get information on the default catch-all routing rule.
       */
      get(zoneIdentifier, options) {
        return this._client.get(`/zones/${zoneIdentifier}/email/routing/rules/catch_all`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(CatchAlls2) {
    })(CatchAlls || (CatchAlls = {}));
  }
});

// node_modules/cloudflare/resources/email-routing/rules/rules.mjs
var Rules2, EmailRoutingRulesV4PagePaginationArray;
var init_rules2 = __esm({
  "node_modules/cloudflare/resources/email-routing/rules/rules.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_rules2();
    init_catch_alls();
    init_pagination();
    Rules2 = class extends APIResource {
      static {
        __name(this, "Rules");
      }
      constructor() {
        super(...arguments);
        this.catchAlls = new CatchAlls(this._client);
      }
      /**
       * Rules consist of a set of criteria for matching emails (such as an email being
       * sent to a specific custom email address) plus a set of actions to take on the
       * email (like forwarding it to a specific destination address).
       */
      create(zoneIdentifier, body, options) {
        return this._client.post(`/zones/${zoneIdentifier}/email/routing/rules`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update actions and matches, or enable/disable specific routing rules.
       */
      update(zoneIdentifier, ruleIdentifier, body, options) {
        return this._client.put(`/zones/${zoneIdentifier}/email/routing/rules/${ruleIdentifier}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      list(zoneIdentifier, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list(zoneIdentifier, {}, query);
        }
        return this._client.getAPIList(`/zones/${zoneIdentifier}/email/routing/rules`, EmailRoutingRulesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Delete a specific routing rule.
       */
      delete(zoneIdentifier, ruleIdentifier, options) {
        return this._client.delete(`/zones/${zoneIdentifier}/email/routing/rules/${ruleIdentifier}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get information for a specific routing rule already created.
       */
      get(zoneIdentifier, ruleIdentifier, options) {
        return this._client.get(`/zones/${zoneIdentifier}/email/routing/rules/${ruleIdentifier}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    EmailRoutingRulesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "EmailRoutingRulesV4PagePaginationArray");
      }
    };
    (function(Rules12) {
      Rules12.EmailRoutingRulesV4PagePaginationArray = EmailRoutingRulesV4PagePaginationArray;
      Rules12.CatchAlls = CatchAlls;
    })(Rules2 || (Rules2 = {}));
  }
});

// node_modules/cloudflare/resources/email-routing/email-routing.mjs
var EmailRouting;
var init_email_routing = __esm({
  "node_modules/cloudflare/resources/email-routing/email-routing.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_addresses();
    init_dns2();
    init_rules2();
    EmailRouting = class extends APIResource {
      static {
        __name(this, "EmailRouting");
      }
      constructor() {
        super(...arguments);
        this.dns = new DNS2(this._client);
        this.rules = new Rules2(this._client);
        this.addresses = new Addresses(this._client);
      }
      /**
       * Disable your Email Routing zone. Also removes additional MX records previously
       * required for Email Routing to work.
       */
      disable(zoneIdentifier, body, options) {
        return this._client.post(`/zones/${zoneIdentifier}/email/routing/disable`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Enable you Email Routing zone. Add and lock the necessary MX and SPF records.
       */
      enable(zoneIdentifier, body, options) {
        return this._client.post(`/zones/${zoneIdentifier}/email/routing/enable`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get information about the settings for your Email Routing zone.
       */
      get(zoneIdentifier, options) {
        return this._client.get(`/zones/${zoneIdentifier}/email/routing`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(EmailRouting2) {
      EmailRouting2.DNS = DNS2;
      EmailRouting2.Rules = Rules2;
      EmailRouting2.EmailRoutingRulesV4PagePaginationArray = EmailRoutingRulesV4PagePaginationArray;
      EmailRouting2.Addresses = Addresses;
      EmailRouting2.AddressesV4PagePaginationArray = AddressesV4PagePaginationArray;
    })(EmailRouting || (EmailRouting = {}));
  }
});

// node_modules/cloudflare/resources/event-notifications/r2/configuration/queues.mjs
var Queues;
var init_queues = __esm({
  "node_modules/cloudflare/resources/event-notifications/r2/configuration/queues.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Queues = class extends APIResource {
      static {
        __name(this, "Queues");
      }
      /**
       * Define the rules for a given queue which will determine event notification
       * production.
       */
      update(bucketName, queueId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/event_notifications/r2/${bucketName}/configuration/queues/${queueId}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Turn off all event notifications configured for delivery to a given queue. No
       * further notifications will be produced for the queue once complete.
       */
      delete(bucketName, queueId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/event_notifications/r2/${bucketName}/configuration/queues/${queueId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Queues3) {
    })(Queues || (Queues = {}));
  }
});

// node_modules/cloudflare/resources/event-notifications/r2/configuration/configuration.mjs
var Configuration;
var init_configuration = __esm({
  "node_modules/cloudflare/resources/event-notifications/r2/configuration/configuration.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_queues();
    Configuration = class extends APIResource {
      static {
        __name(this, "Configuration");
      }
      constructor() {
        super(...arguments);
        this.queues = new Queues(this._client);
      }
      /**
       * Returns all notification rules for each queue for which bucket notifications are
       * produced.
       */
      get(bucketName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/event_notifications/r2/${bucketName}/configuration`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Configuration2) {
      Configuration2.Queues = Queues;
    })(Configuration || (Configuration = {}));
  }
});

// node_modules/cloudflare/resources/event-notifications/r2/r2.mjs
var R2;
var init_r2 = __esm({
  "node_modules/cloudflare/resources/event-notifications/r2/r2.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_configuration();
    R2 = class extends APIResource {
      static {
        __name(this, "R2");
      }
      constructor() {
        super(...arguments);
        this.configuration = new Configuration(this._client);
      }
    };
    (function(R23) {
      R23.Configuration = Configuration;
    })(R2 || (R2 = {}));
  }
});

// node_modules/cloudflare/resources/event-notifications/event-notifications.mjs
var EventNotifications;
var init_event_notifications = __esm({
  "node_modules/cloudflare/resources/event-notifications/event-notifications.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_r2();
    EventNotifications = class extends APIResource {
      static {
        __name(this, "EventNotifications");
      }
      constructor() {
        super(...arguments);
        this.r2 = new R2(this._client);
      }
    };
    (function(EventNotifications2) {
      EventNotifications2.R2 = R2;
    })(EventNotifications || (EventNotifications = {}));
  }
});

// node_modules/cloudflare/resources/filters.mjs
var Filters, FirewallFiltersV4PagePaginationArray;
var init_filters = __esm({
  "node_modules/cloudflare/resources/filters.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_pagination();
    Filters = class extends APIResource {
      static {
        __name(this, "Filters");
      }
      /**
       * Creates one or more filters.
       *
       * @deprecated The Filters API is deprecated in favour of using the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#firewall-rules-api-and-filters-api for full details.
       */
      create(zoneIdentifier, body, options) {
        return this._client.post(`/zones/${zoneIdentifier}/filters`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an existing filter.
       *
       * @deprecated The Filters API is deprecated in favour of using the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#firewall-rules-api-and-filters-api for full details.
       */
      update(zoneIdentifier, id, body, options) {
        return this._client.put(`/zones/${zoneIdentifier}/filters/${id}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      list(zoneIdentifier, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list(zoneIdentifier, {}, query);
        }
        return this._client.getAPIList(`/zones/${zoneIdentifier}/filters`, FirewallFiltersV4PagePaginationArray, {
          query,
          ...options
        });
      }
      /**
       * Deletes an existing filter.
       *
       * @deprecated The Filters API is deprecated in favour of using the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#firewall-rules-api-and-filters-api for full details.
       */
      delete(zoneIdentifier, id, options) {
        return this._client.delete(`/zones/${zoneIdentifier}/filters/${id}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the details of a filter.
       *
       * @deprecated The Filters API is deprecated in favour of using the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#firewall-rules-api-and-filters-api for full details.
       */
      get(zoneIdentifier, id, options) {
        return this._client.get(`/zones/${zoneIdentifier}/filters/${id}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    FirewallFiltersV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "FirewallFiltersV4PagePaginationArray");
      }
    };
  }
});

// node_modules/cloudflare/resources/firewall/access-rules.mjs
var AccessRules, AccessRuleListResponsesV4PagePaginationArray;
var init_access_rules = __esm({
  "node_modules/cloudflare/resources/firewall/access-rules.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    init_access_rules();
    init_pagination();
    AccessRules = class extends APIResource {
      static {
        __name(this, "AccessRules");
      }
      /**
       * Creates a new IP Access rule for an account or zone. The rule will apply to all
       * zones in the account or zone.
       *
       * Note: To create an IP Access rule that applies to a single zone, refer to the
       * [IP Access rules for a zone](#ip-access-rules-for-a-zone) endpoints.
       */
      create(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/firewall/access_rules/rules`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      list(params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list({}, params);
        }
        const { account_id, zone_id, ...query } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.getAPIList(`/${accountOrZone}/${accountOrZoneId}/firewall/access_rules/rules`, AccessRuleListResponsesV4PagePaginationArray, { query, ...options });
      }
      delete(identifier, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.delete(identifier, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.delete(`/${accountOrZone}/${accountOrZoneId}/firewall/access_rules/rules/${identifier}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an IP Access rule defined.
       *
       * Note: This operation will affect all zones in the account or zone.
       */
      edit(identifier, params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.patch(`/${accountOrZone}/${accountOrZoneId}/firewall/access_rules/rules/${identifier}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      get(identifier, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get(identifier, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/firewall/access_rules/rules/${identifier}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    AccessRuleListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "AccessRuleListResponsesV4PagePaginationArray");
      }
    };
    (function(AccessRules2) {
      AccessRules2.AccessRuleListResponsesV4PagePaginationArray = AccessRuleListResponsesV4PagePaginationArray;
    })(AccessRules || (AccessRules = {}));
  }
});

// node_modules/cloudflare/resources/firewall/lockdowns.mjs
var Lockdowns, LockdownsV4PagePaginationArray;
var init_lockdowns = __esm({
  "node_modules/cloudflare/resources/firewall/lockdowns.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_lockdowns();
    init_pagination();
    Lockdowns = class extends APIResource {
      static {
        __name(this, "Lockdowns");
      }
      /**
       * Creates a new Zone Lockdown rule.
       */
      create(zoneIdentifier, body, options) {
        return this._client.post(`/zones/${zoneIdentifier}/firewall/lockdowns`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an existing Zone Lockdown rule.
       */
      update(zoneIdentifier, id, body, options) {
        return this._client.put(`/zones/${zoneIdentifier}/firewall/lockdowns/${id}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      list(zoneIdentifier, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list(zoneIdentifier, {}, query);
        }
        return this._client.getAPIList(`/zones/${zoneIdentifier}/firewall/lockdowns`, LockdownsV4PagePaginationArray, { query, ...options });
      }
      /**
       * Deletes an existing Zone Lockdown rule.
       */
      delete(zoneIdentifier, id, options) {
        return this._client.delete(`/zones/${zoneIdentifier}/firewall/lockdowns/${id}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the details of a Zone Lockdown rule.
       */
      get(zoneIdentifier, id, options) {
        return this._client.get(`/zones/${zoneIdentifier}/firewall/lockdowns/${id}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    LockdownsV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "LockdownsV4PagePaginationArray");
      }
    };
    (function(Lockdowns2) {
      Lockdowns2.LockdownsV4PagePaginationArray = LockdownsV4PagePaginationArray;
    })(Lockdowns || (Lockdowns = {}));
  }
});

// node_modules/cloudflare/resources/firewall/rules.mjs
var Rules3, FirewallRulesV4PagePaginationArray;
var init_rules3 = __esm({
  "node_modules/cloudflare/resources/firewall/rules.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_rules3();
    init_pagination();
    Rules3 = class extends APIResource {
      static {
        __name(this, "Rules");
      }
      /**
       * Create one or more firewall rules.
       *
       * @deprecated The Firewall Rules API is deprecated in favour of using the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#firewall-rules-api-and-filters-api for full details.
       */
      create(zoneIdentifier, body, options) {
        return this._client.post(`/zones/${zoneIdentifier}/firewall/rules`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an existing firewall rule.
       *
       * @deprecated The Firewall Rules API is deprecated in favour of using the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#firewall-rules-api-and-filters-api for full details.
       */
      update(zoneIdentifier, id, body, options) {
        return this._client.put(`/zones/${zoneIdentifier}/firewall/rules/${id}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      list(zoneIdentifier, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list(zoneIdentifier, {}, query);
        }
        return this._client.getAPIList(`/zones/${zoneIdentifier}/firewall/rules`, FirewallRulesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Deletes an existing firewall rule.
       *
       * @deprecated The Firewall Rules API is deprecated in favour of using the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#firewall-rules-api-and-filters-api for full details.
       */
      delete(zoneIdentifier, id, options) {
        return this._client.delete(`/zones/${zoneIdentifier}/firewall/rules/${id}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates the priority of an existing firewall rule.
       *
       * @deprecated The Firewall Rules API is deprecated in favour of using the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#firewall-rules-api-and-filters-api for full details.
       */
      edit(zoneIdentifier, id, body, options) {
        return this._client.patch(`/zones/${zoneIdentifier}/firewall/rules/${id}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the details of a firewall rule.
       *
       * @deprecated The Firewall Rules API is deprecated in favour of using the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#firewall-rules-api-and-filters-api for full details.
       */
      get(zoneIdentifier, params, options) {
        const { path_id, query_id, ...query } = params;
        return this._client.get(`/zones/${zoneIdentifier}/firewall/rules/${path_id}`, {
          query: { id: query_id, ...query },
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    FirewallRulesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "FirewallRulesV4PagePaginationArray");
      }
    };
    (function(Rules12) {
      Rules12.FirewallRulesV4PagePaginationArray = FirewallRulesV4PagePaginationArray;
    })(Rules3 || (Rules3 = {}));
  }
});

// node_modules/cloudflare/resources/firewall/ua-rules.mjs
var UARules, UARuleListResponsesV4PagePaginationArray;
var init_ua_rules = __esm({
  "node_modules/cloudflare/resources/firewall/ua-rules.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_ua_rules();
    init_pagination();
    UARules = class extends APIResource {
      static {
        __name(this, "UARules");
      }
      /**
       * Creates a new User Agent Blocking rule in a zone.
       */
      create(zoneIdentifier, body, options) {
        return this._client.post(`/zones/${zoneIdentifier}/firewall/ua_rules`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an existing User Agent Blocking rule.
       */
      update(zoneIdentifier, id, body, options) {
        return this._client.put(`/zones/${zoneIdentifier}/firewall/ua_rules/${id}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      list(zoneIdentifier, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list(zoneIdentifier, {}, query);
        }
        return this._client.getAPIList(`/zones/${zoneIdentifier}/firewall/ua_rules`, UARuleListResponsesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Deletes an existing User Agent Blocking rule.
       */
      delete(zoneIdentifier, id, options) {
        return this._client.delete(`/zones/${zoneIdentifier}/firewall/ua_rules/${id}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the details of a User Agent Blocking rule.
       */
      get(zoneIdentifier, id, options) {
        return this._client.get(`/zones/${zoneIdentifier}/firewall/ua_rules/${id}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    UARuleListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "UARuleListResponsesV4PagePaginationArray");
      }
    };
    (function(UARules2) {
      UARules2.UARuleListResponsesV4PagePaginationArray = UARuleListResponsesV4PagePaginationArray;
    })(UARules || (UARules = {}));
  }
});

// node_modules/cloudflare/resources/firewall/waf/overrides.mjs
var Overrides, OverridesV4PagePaginationArray;
var init_overrides = __esm({
  "node_modules/cloudflare/resources/firewall/waf/overrides.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_overrides();
    init_pagination();
    Overrides = class extends APIResource {
      static {
        __name(this, "Overrides");
      }
      /**
       * Creates a URI-based WAF override for a zone.
       *
       * **Note:** Applies only to the
       * [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
       */
      create(zoneIdentifier, body, options) {
        return this._client.post(`/zones/${zoneIdentifier}/firewall/waf/overrides`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an existing URI-based WAF override.
       *
       * **Note:** Applies only to the
       * [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
       */
      update(zoneIdentifier, id, body, options) {
        return this._client.put(`/zones/${zoneIdentifier}/firewall/waf/overrides/${id}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      list(zoneIdentifier, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list(zoneIdentifier, {}, query);
        }
        return this._client.getAPIList(`/zones/${zoneIdentifier}/firewall/waf/overrides`, OverridesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Deletes an existing URI-based WAF override.
       *
       * **Note:** Applies only to the
       * [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
       */
      delete(zoneIdentifier, id, options) {
        return this._client.delete(`/zones/${zoneIdentifier}/firewall/waf/overrides/${id}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the details of a URI-based WAF override.
       *
       * **Note:** Applies only to the
       * [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
       */
      get(zoneIdentifier, id, options) {
        return this._client.get(`/zones/${zoneIdentifier}/firewall/waf/overrides/${id}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    OverridesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "OverridesV4PagePaginationArray");
      }
    };
    (function(Overrides2) {
      Overrides2.OverridesV4PagePaginationArray = OverridesV4PagePaginationArray;
    })(Overrides || (Overrides = {}));
  }
});

// node_modules/cloudflare/resources/firewall/waf/packages/groups.mjs
var Groups, GroupsV4PagePaginationArray;
var init_groups = __esm({
  "node_modules/cloudflare/resources/firewall/waf/packages/groups.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_groups();
    init_pagination();
    Groups = class extends APIResource {
      static {
        __name(this, "Groups");
      }
      /**
       * Fetches the WAF rule groups in a WAF package.
       *
       * **Note:** Applies only to the
       * [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
       */
      list(packageId, params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/firewall/waf/packages/${packageId}/groups`, GroupsV4PagePaginationArray, { query, ...options });
      }
      /**
       * Updates a WAF rule group. You can update the state (`mode` parameter) of a rule
       * group.
       *
       * **Note:** Applies only to the
       * [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
       */
      edit(packageId, groupId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/firewall/waf/packages/${packageId}/groups/${groupId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the details of a WAF rule group.
       *
       * **Note:** Applies only to the
       * [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
       */
      get(packageId, groupId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/firewall/waf/packages/${packageId}/groups/${groupId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    GroupsV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "GroupsV4PagePaginationArray");
      }
    };
    (function(Groups3) {
      Groups3.GroupsV4PagePaginationArray = GroupsV4PagePaginationArray;
    })(Groups || (Groups = {}));
  }
});

// node_modules/cloudflare/resources/firewall/waf/packages/rules.mjs
var Rules4, RuleListResponsesV4PagePaginationArray;
var init_rules4 = __esm({
  "node_modules/cloudflare/resources/firewall/waf/packages/rules.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_rules4();
    init_pagination();
    Rules4 = class extends APIResource {
      static {
        __name(this, "Rules");
      }
      /**
       * Fetches WAF rules in a WAF package.
       *
       * **Note:** Applies only to the
       * [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
       */
      list(packageId, params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/firewall/waf/packages/${packageId}/rules`, RuleListResponsesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Updates a WAF rule. You can only update the mode/action of the rule.
       *
       * **Note:** Applies only to the
       * [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
       */
      edit(packageId, ruleId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/firewall/waf/packages/${packageId}/rules/${ruleId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the details of a WAF rule in a WAF package.
       *
       * **Note:** Applies only to the
       * [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
       */
      get(packageId, ruleId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/firewall/waf/packages/${packageId}/rules/${ruleId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    RuleListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "RuleListResponsesV4PagePaginationArray");
      }
    };
    (function(Rules12) {
      Rules12.RuleListResponsesV4PagePaginationArray = RuleListResponsesV4PagePaginationArray;
    })(Rules4 || (Rules4 = {}));
  }
});

// node_modules/cloudflare/resources/firewall/waf/packages/packages.mjs
var Packages, PackageListResponsesV4PagePaginationArray;
var init_packages = __esm({
  "node_modules/cloudflare/resources/firewall/waf/packages/packages.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_packages();
    init_groups();
    init_rules4();
    init_pagination();
    Packages = class extends APIResource {
      static {
        __name(this, "Packages");
      }
      constructor() {
        super(...arguments);
        this.groups = new Groups(this._client);
        this.rules = new Rules4(this._client);
      }
      list(zoneIdentifier, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list(zoneIdentifier, {}, query);
        }
        return this._client.getAPIList(`/zones/${zoneIdentifier}/firewall/waf/packages`, PackageListResponsesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Fetches the details of a WAF package.
       *
       * **Note:** Applies only to the
       * [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
       */
      get(zoneIdentifier, identifier, options) {
        return this._client.get(`/zones/${zoneIdentifier}/firewall/waf/packages/${identifier}`, options);
      }
    };
    PackageListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "PackageListResponsesV4PagePaginationArray");
      }
    };
    (function(Packages2) {
      Packages2.PackageListResponsesV4PagePaginationArray = PackageListResponsesV4PagePaginationArray;
      Packages2.Groups = Groups;
      Packages2.GroupsV4PagePaginationArray = GroupsV4PagePaginationArray;
      Packages2.Rules = Rules4;
      Packages2.RuleListResponsesV4PagePaginationArray = RuleListResponsesV4PagePaginationArray;
    })(Packages || (Packages = {}));
  }
});

// node_modules/cloudflare/resources/firewall/waf/waf.mjs
var WAF;
var init_waf = __esm({
  "node_modules/cloudflare/resources/firewall/waf/waf.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_overrides();
    init_packages();
    WAF = class extends APIResource {
      static {
        __name(this, "WAF");
      }
      constructor() {
        super(...arguments);
        this.overrides = new Overrides(this._client);
        this.packages = new Packages(this._client);
      }
    };
    (function(WAF2) {
      WAF2.Overrides = Overrides;
      WAF2.OverridesV4PagePaginationArray = OverridesV4PagePaginationArray;
      WAF2.Packages = Packages;
      WAF2.PackageListResponsesV4PagePaginationArray = PackageListResponsesV4PagePaginationArray;
    })(WAF || (WAF = {}));
  }
});

// node_modules/cloudflare/resources/firewall/firewall.mjs
var Firewall;
var init_firewall2 = __esm({
  "node_modules/cloudflare/resources/firewall/firewall.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_access_rules();
    init_lockdowns();
    init_rules3();
    init_ua_rules();
    init_waf();
    Firewall = class extends APIResource {
      static {
        __name(this, "Firewall");
      }
      constructor() {
        super(...arguments);
        this.lockdowns = new Lockdowns(this._client);
        this.rules = new Rules3(this._client);
        this.accessRules = new AccessRules(this._client);
        this.uaRules = new UARules(this._client);
        this.waf = new WAF(this._client);
      }
    };
    (function(Firewall2) {
      Firewall2.Lockdowns = Lockdowns;
      Firewall2.LockdownsV4PagePaginationArray = LockdownsV4PagePaginationArray;
      Firewall2.Rules = Rules3;
      Firewall2.FirewallRulesV4PagePaginationArray = FirewallRulesV4PagePaginationArray;
      Firewall2.AccessRules = AccessRules;
      Firewall2.AccessRuleListResponsesV4PagePaginationArray = AccessRuleListResponsesV4PagePaginationArray;
      Firewall2.UARules = UARules;
      Firewall2.UARuleListResponsesV4PagePaginationArray = UARuleListResponsesV4PagePaginationArray;
      Firewall2.WAF = WAF;
    })(Firewall || (Firewall = {}));
  }
});

// node_modules/cloudflare/resources/healthchecks/previews.mjs
var Previews;
var init_previews = __esm({
  "node_modules/cloudflare/resources/healthchecks/previews.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Previews = class extends APIResource {
      static {
        __name(this, "Previews");
      }
      /**
       * Create a new preview health check.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/healthchecks/preview`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Delete a health check.
       */
      delete(healthcheckId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/healthchecks/preview/${healthcheckId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch a single configured health check preview.
       */
      get(healthcheckId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/healthchecks/preview/${healthcheckId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Previews4) {
    })(Previews || (Previews = {}));
  }
});

// node_modules/cloudflare/resources/healthchecks/healthchecks.mjs
var Healthchecks, HealthchecksSinglePage;
var init_healthchecks = __esm({
  "node_modules/cloudflare/resources/healthchecks/healthchecks.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_previews();
    init_pagination();
    Healthchecks = class extends APIResource {
      static {
        __name(this, "Healthchecks");
      }
      constructor() {
        super(...arguments);
        this.previews = new Previews(this._client);
      }
      /**
       * Create a new health check.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/healthchecks`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a configured health check.
       */
      update(healthcheckId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/healthchecks/${healthcheckId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List configured health checks.
       */
      list(params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/healthchecks`, HealthchecksSinglePage, {
          query,
          ...options
        });
      }
      /**
       * Delete a health check.
       */
      delete(healthcheckId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/healthchecks/${healthcheckId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Patch a configured health check.
       */
      edit(healthcheckId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/healthchecks/${healthcheckId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch a single configured health check.
       */
      get(healthcheckId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/healthchecks/${healthcheckId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    HealthchecksSinglePage = class extends SinglePage {
      static {
        __name(this, "HealthchecksSinglePage");
      }
    };
    (function(Healthchecks2) {
      Healthchecks2.Previews = Previews;
    })(Healthchecks || (Healthchecks = {}));
  }
});

// node_modules/cloudflare/resources/hostnames/settings/tls.mjs
var TLS;
var init_tls = __esm({
  "node_modules/cloudflare/resources/hostnames/settings/tls.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    TLS = class extends APIResource {
      static {
        __name(this, "TLS");
      }
      /**
       * Update the tls setting value for the hostname.
       */
      update(settingId, hostname, params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/hostnames/settings/${settingId}/${hostname}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Delete the tls setting value for the hostname.
       */
      delete(settingId, hostname, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/hostnames/settings/${settingId}/${hostname}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * List the requested TLS setting for the hostnames under this zone.
       */
      get(settingId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/hostnames/settings/${settingId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(TLS2) {
    })(TLS || (TLS = {}));
  }
});

// node_modules/cloudflare/resources/hostnames/settings/settings.mjs
var Settings3;
var init_settings3 = __esm({
  "node_modules/cloudflare/resources/hostnames/settings/settings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_tls();
    Settings3 = class extends APIResource {
      static {
        __name(this, "Settings");
      }
      constructor() {
        super(...arguments);
        this.tls = new TLS(this._client);
      }
    };
    (function(Settings13) {
      Settings13.TLS = TLS;
    })(Settings3 || (Settings3 = {}));
  }
});

// node_modules/cloudflare/resources/hostnames/hostnames.mjs
var Hostnames;
var init_hostnames = __esm({
  "node_modules/cloudflare/resources/hostnames/hostnames.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_settings3();
    Hostnames = class extends APIResource {
      static {
        __name(this, "Hostnames");
      }
      constructor() {
        super(...arguments);
        this.settings = new Settings3(this._client);
      }
    };
    (function(Hostnames4) {
      Hostnames4.Settings = Settings3;
    })(Hostnames || (Hostnames = {}));
  }
});

// node_modules/cloudflare/resources/hyperdrive/configs.mjs
var Configs;
var init_configs = __esm({
  "node_modules/cloudflare/resources/hyperdrive/configs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_hyperdrive();
    Configs = class extends APIResource {
      static {
        __name(this, "Configs");
      }
      /**
       * Creates and returns a new Hyperdrive configuration.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/hyperdrive/configs`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates and returns the specified Hyperdrive configuration.
       */
      update(hyperdriveId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/hyperdrive/configs/${hyperdriveId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Returns a list of Hyperdrives
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/hyperdrive/configs`, HyperdrivesSinglePage, options);
      }
      /**
       * Deletes the specified Hyperdrive.
       */
      delete(hyperdriveId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/hyperdrive/configs/${hyperdriveId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Patches and returns the specified Hyperdrive configuration. Updates to the
       * origin and caching settings are applied with an all-or-nothing approach.
       */
      edit(hyperdriveId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/hyperdrive/configs/${hyperdriveId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Returns the specified Hyperdrive configuration.
       */
      get(hyperdriveId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/hyperdrive/configs/${hyperdriveId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Configs3) {
    })(Configs || (Configs = {}));
  }
});

// node_modules/cloudflare/resources/hyperdrive/hyperdrive.mjs
var HyperdriveResource, HyperdrivesSinglePage;
var init_hyperdrive = __esm({
  "node_modules/cloudflare/resources/hyperdrive/hyperdrive.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_configs();
    init_pagination();
    HyperdriveResource = class extends APIResource {
      static {
        __name(this, "HyperdriveResource");
      }
      constructor() {
        super(...arguments);
        this.configs = new Configs(this._client);
      }
    };
    HyperdrivesSinglePage = class extends SinglePage {
      static {
        __name(this, "HyperdrivesSinglePage");
      }
    };
    (function(HyperdriveResource2) {
      HyperdriveResource2.Configs = Configs;
    })(HyperdriveResource || (HyperdriveResource = {}));
  }
});

// node_modules/cloudflare/resources/iam/permission-groups.mjs
var PermissionGroups, PermissionGroupListResponsesV4PagePaginationArray;
var init_permission_groups = __esm({
  "node_modules/cloudflare/resources/iam/permission-groups.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_permission_groups();
    init_pagination();
    PermissionGroups = class extends APIResource {
      static {
        __name(this, "PermissionGroups");
      }
      /**
       * List all the permissions groups for an account.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/iam/permission_groups`, PermissionGroupListResponsesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Get information about a specific permission group in an account.
       */
      get(permissionGroupId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/iam/permission_groups/${permissionGroupId}`, options);
      }
    };
    PermissionGroupListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "PermissionGroupListResponsesV4PagePaginationArray");
      }
    };
    (function(PermissionGroups3) {
      PermissionGroups3.PermissionGroupListResponsesV4PagePaginationArray = PermissionGroupListResponsesV4PagePaginationArray;
    })(PermissionGroups || (PermissionGroups = {}));
  }
});

// node_modules/cloudflare/resources/iam/resource-groups.mjs
var ResourceGroups, ResourceGroupListResponsesV4PagePaginationArray;
var init_resource_groups = __esm({
  "node_modules/cloudflare/resources/iam/resource-groups.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_resource_groups();
    init_pagination();
    ResourceGroups = class extends APIResource {
      static {
        __name(this, "ResourceGroups");
      }
      /**
       * Create a new Resource Group under the specified account.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/iam/resource_groups`, { body, ...options });
      }
      /**
       * Modify an existing resource group.
       */
      update(resourceGroupId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/iam/resource_groups/${resourceGroupId}`, {
          body,
          ...options
        });
      }
      /**
       * List all the resource groups for an account.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/iam/resource_groups`, ResourceGroupListResponsesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Remove a resource group from an account.
       */
      delete(resourceGroupId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/iam/resource_groups/${resourceGroupId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get information about a specific resource group in an account.
       */
      get(resourceGroupId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/iam/resource_groups/${resourceGroupId}`, options);
      }
    };
    ResourceGroupListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "ResourceGroupListResponsesV4PagePaginationArray");
      }
    };
    (function(ResourceGroups2) {
      ResourceGroups2.ResourceGroupListResponsesV4PagePaginationArray = ResourceGroupListResponsesV4PagePaginationArray;
    })(ResourceGroups || (ResourceGroups = {}));
  }
});

// node_modules/cloudflare/resources/iam/iam.mjs
var IAM;
var init_iam = __esm({
  "node_modules/cloudflare/resources/iam/iam.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_permission_groups();
    init_resource_groups();
    IAM = class extends APIResource {
      static {
        __name(this, "IAM");
      }
      constructor() {
        super(...arguments);
        this.permissionGroups = new PermissionGroups(this._client);
        this.resourceGroups = new ResourceGroups(this._client);
      }
    };
    (function(IAM2) {
      IAM2.PermissionGroups = PermissionGroups;
      IAM2.PermissionGroupListResponsesV4PagePaginationArray = PermissionGroupListResponsesV4PagePaginationArray;
      IAM2.ResourceGroups = ResourceGroups;
      IAM2.ResourceGroupListResponsesV4PagePaginationArray = ResourceGroupListResponsesV4PagePaginationArray;
    })(IAM || (IAM = {}));
  }
});

// node_modules/cloudflare/resources/ips.mjs
var IPs2;
var init_ips2 = __esm({
  "node_modules/cloudflare/resources/ips.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    IPs2 = class extends APIResource {
      static {
        __name(this, "IPs");
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.get("/ips", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
  }
});

// node_modules/cloudflare/resources/images/v1/blobs.mjs
var Blobs;
var init_blobs = __esm({
  "node_modules/cloudflare/resources/images/v1/blobs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Blobs = class extends APIResource {
      static {
        __name(this, "Blobs");
      }
      /**
       * Fetch base image. For most images this will be the originally uploaded file. For
       * larger images it can be a near-lossless version of the original.
       */
      get(imageId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/images/v1/${imageId}/blob`, {
          ...options,
          __binaryResponse: true
        });
      }
    };
    /* @__PURE__ */ (function(Blobs2) {
    })(Blobs || (Blobs = {}));
  }
});

// node_modules/cloudflare/resources/images/v1/keys.mjs
var Keys2;
var init_keys2 = __esm({
  "node_modules/cloudflare/resources/images/v1/keys.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Keys2 = class extends APIResource {
      static {
        __name(this, "Keys");
      }
      /**
       * Create a new signing key with specified name. Returns all keys available.
       */
      update(signingKeyName, params, options) {
        const { account_id } = params;
        return this._client.put(`/accounts/${account_id}/images/v1/keys/${signingKeyName}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists your signing keys. These can be found on your Cloudflare Images dashboard.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/images/v1/keys`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Delete signing key with specified name. Returns all keys available. When last
       * key is removed, a new default signing key will be generated.
       */
      delete(signingKeyName, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/images/v1/keys/${signingKeyName}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Keys6) {
    })(Keys2 || (Keys2 = {}));
  }
});

// node_modules/cloudflare/resources/images/v1/stats.mjs
var Stats;
var init_stats = __esm({
  "node_modules/cloudflare/resources/images/v1/stats.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Stats = class extends APIResource {
      static {
        __name(this, "Stats");
      }
      /**
       * Fetch usage statistics details for Cloudflare Images.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/images/v1/stats`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Stats2) {
    })(Stats || (Stats = {}));
  }
});

// node_modules/cloudflare/resources/images/v1/variants.mjs
var Variants2;
var init_variants2 = __esm({
  "node_modules/cloudflare/resources/images/v1/variants.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Variants2 = class extends APIResource {
      static {
        __name(this, "Variants");
      }
      /**
       * Specify variants that allow you to resize images for different use cases.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/images/v1/variants`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists existing variants.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/images/v1/variants`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Deleting a variant purges the cache for all images associated with the variant.
       */
      delete(variantId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/images/v1/variants/${variantId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updating a variant purges the cache for all images associated with the variant.
       */
      edit(variantId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/images/v1/variants/${variantId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch details for a single variant.
       */
      get(variantId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/images/v1/variants/${variantId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Variants3) {
    })(Variants2 || (Variants2 = {}));
  }
});

// node_modules/cloudflare/resources/images/v1/v1.mjs
var V1, V1ListResponsesV4PagePagination;
var init_v1 = __esm({
  "node_modules/cloudflare/resources/images/v1/v1.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_v1();
    init_blobs();
    init_keys2();
    init_stats();
    init_variants2();
    init_pagination();
    V1 = class extends APIResource {
      static {
        __name(this, "V1");
      }
      constructor() {
        super(...arguments);
        this.keys = new Keys2(this._client);
        this.stats = new Stats(this._client);
        this.variants = new Variants2(this._client);
        this.blobs = new Blobs(this._client);
      }
      /**
       * Upload an image with up to 10 Megabytes using a single HTTP POST
       * (multipart/form-data) request. An image can be uploaded by sending an image file
       * or passing an accessible to an API url.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/images/v1`, multipartFormRequestOptions({ body, ...options }))._thenUnwrap((obj) => obj.result);
      }
      /**
       * List up to 100 images with one request. Use the optional parameters below to get
       * a specific range of images.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/images/v1`, V1ListResponsesV4PagePagination, {
          query,
          ...options
        });
      }
      /**
       * Delete an image on Cloudflare Images. On success, all copies of the image are
       * deleted and purged from cache.
       */
      delete(imageId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/images/v1/${imageId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update image access control. On access control change, all copies of the image
       * are purged from cache.
       */
      edit(imageId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/images/v1/${imageId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch details for a single image.
       */
      get(imageId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/images/v1/${imageId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    V1ListResponsesV4PagePagination = class extends V4PagePagination {
      static {
        __name(this, "V1ListResponsesV4PagePagination");
      }
    };
    (function(V12) {
      V12.V1ListResponsesV4PagePagination = V1ListResponsesV4PagePagination;
      V12.Keys = Keys2;
      V12.Stats = Stats;
      V12.Variants = Variants2;
      V12.Blobs = Blobs;
    })(V1 || (V1 = {}));
  }
});

// node_modules/cloudflare/resources/images/v2/direct-uploads.mjs
var DirectUploads;
var init_direct_uploads = __esm({
  "node_modules/cloudflare/resources/images/v2/direct-uploads.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    DirectUploads = class extends APIResource {
      static {
        __name(this, "DirectUploads");
      }
      /**
       * Direct uploads allow users to upload images without API keys. A common use case
       * are web apps, client-side applications, or mobile devices where users upload
       * content directly to Cloudflare Images. This method creates a draft record for a
       * future image. It returns an upload URL and an image identifier. To verify if the
       * image itself has been uploaded, send an image details request
       * (accounts/:account_identifier/images/v1/:identifier), and check that the
       * `draft: true` property is not present.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/images/v2/direct_upload`, multipartFormRequestOptions({ body, ...options }))._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(DirectUploads2) {
    })(DirectUploads || (DirectUploads = {}));
  }
});

// node_modules/cloudflare/resources/images/v2/v2.mjs
var V2;
var init_v2 = __esm({
  "node_modules/cloudflare/resources/images/v2/v2.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_direct_uploads();
    V2 = class extends APIResource {
      static {
        __name(this, "V2");
      }
      constructor() {
        super(...arguments);
        this.directUploads = new DirectUploads(this._client);
      }
      /**
       * List up to 10000 images with one request. Use the optional parameters below to
       * get a specific range of images. Endpoint returns continuation_token if more
       * images are present.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/images/v2`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(V22) {
      V22.DirectUploads = DirectUploads;
    })(V2 || (V2 = {}));
  }
});

// node_modules/cloudflare/resources/images/images.mjs
var Images;
var init_images = __esm({
  "node_modules/cloudflare/resources/images/images.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_v1();
    init_v2();
    Images = class extends APIResource {
      static {
        __name(this, "Images");
      }
      constructor() {
        super(...arguments);
        this.v1 = new V1(this._client);
        this.v2 = new V2(this._client);
      }
    };
    (function(Images2) {
      Images2.V1 = V1;
      Images2.V1ListResponsesV4PagePagination = V1ListResponsesV4PagePagination;
      Images2.V2 = V2;
    })(Images || (Images = {}));
  }
});

// node_modules/cloudflare/resources/intel/dns.mjs
var DNS3, DNSListResponsesV4PagePagination;
var init_dns3 = __esm({
  "node_modules/cloudflare/resources/intel/dns.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_dns3();
    init_pagination();
    DNS3 = class extends APIResource {
      static {
        __name(this, "DNS");
      }
      /**
       * Get Passive DNS by IP
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/intel/dns`, DNSListResponsesV4PagePagination, {
          query,
          ...options
        });
      }
    };
    DNSListResponsesV4PagePagination = class extends V4PagePagination {
      static {
        __name(this, "DNSListResponsesV4PagePagination");
      }
    };
    (function(DNS5) {
      DNS5.DNS = DNS3;
      DNS5.DNSListResponsesV4PagePagination = DNSListResponsesV4PagePagination;
    })(DNS3 || (DNS3 = {}));
  }
});

// node_modules/cloudflare/resources/intel/domain-history.mjs
var DomainHistoryResource;
var init_domain_history = __esm({
  "node_modules/cloudflare/resources/intel/domain-history.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    DomainHistoryResource = class extends APIResource {
      static {
        __name(this, "DomainHistoryResource");
      }
      /**
       * Get Domain History
       */
      get(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/intel/domain-history`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(DomainHistoryResource2) {
    })(DomainHistoryResource || (DomainHistoryResource = {}));
  }
});

// node_modules/cloudflare/resources/intel/ip-lists.mjs
var IPLists;
var init_ip_lists = __esm({
  "node_modules/cloudflare/resources/intel/ip-lists.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    IPLists = class extends APIResource {
      static {
        __name(this, "IPLists");
      }
      /**
       * Get IP Lists
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/intel/ip-list`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(IPLists2) {
    })(IPLists || (IPLists = {}));
  }
});

// node_modules/cloudflare/resources/intel/ips.mjs
var IPs3;
var init_ips3 = __esm({
  "node_modules/cloudflare/resources/intel/ips.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    IPs3 = class extends APIResource {
      static {
        __name(this, "IPs");
      }
      /**
       * Get IP Overview
       */
      get(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/intel/ip`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(IPs6) {
    })(IPs3 || (IPs3 = {}));
  }
});

// node_modules/cloudflare/resources/intel/miscategorizations.mjs
var Miscategorizations;
var init_miscategorizations = __esm({
  "node_modules/cloudflare/resources/intel/miscategorizations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Miscategorizations = class extends APIResource {
      static {
        __name(this, "Miscategorizations");
      }
      /**
       * Create Miscategorization
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/intel/miscategorization`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Miscategorizations2) {
    })(Miscategorizations || (Miscategorizations = {}));
  }
});

// node_modules/cloudflare/resources/intel/sinkholes.mjs
var Sinkholes, SinkholesSinglePage;
var init_sinkholes = __esm({
  "node_modules/cloudflare/resources/intel/sinkholes.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_sinkholes();
    init_pagination();
    Sinkholes = class extends APIResource {
      static {
        __name(this, "Sinkholes");
      }
      /**
       * List sinkholes owned by this account
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/intel/sinkholes`, SinkholesSinglePage, options);
      }
    };
    SinkholesSinglePage = class extends SinglePage {
      static {
        __name(this, "SinkholesSinglePage");
      }
    };
    (function(Sinkholes2) {
      Sinkholes2.SinkholesSinglePage = SinkholesSinglePage;
    })(Sinkholes || (Sinkholes = {}));
  }
});

// node_modules/cloudflare/resources/intel/whois.mjs
var Whois;
var init_whois = __esm({
  "node_modules/cloudflare/resources/intel/whois.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_whois();
    Whois = class extends APIResource {
      static {
        __name(this, "Whois");
      }
      /**
       * Get WHOIS Record
       */
      get(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/intel/whois`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Whois2) {
      Whois2.Whois = Whois;
    })(Whois || (Whois = {}));
  }
});

// node_modules/cloudflare/resources/intel/asn/subnets.mjs
var Subnets;
var init_subnets = __esm({
  "node_modules/cloudflare/resources/intel/asn/subnets.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Subnets = class extends APIResource {
      static {
        __name(this, "Subnets");
      }
      /**
       * Get ASN Subnets
       */
      get(asn, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/intel/asn/${asn}/subnets`, options);
      }
    };
    /* @__PURE__ */ (function(Subnets2) {
    })(Subnets || (Subnets = {}));
  }
});

// node_modules/cloudflare/resources/intel/asn/asn.mjs
var ASN;
var init_asn = __esm({
  "node_modules/cloudflare/resources/intel/asn/asn.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_subnets();
    ASN = class extends APIResource {
      static {
        __name(this, "ASN");
      }
      constructor() {
        super(...arguments);
        this.subnets = new Subnets(this._client);
      }
      /**
       * Get ASN Overview
       */
      get(asn, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/intel/asn/${asn}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(ASN2) {
      ASN2.Subnets = Subnets;
    })(ASN || (ASN = {}));
  }
});

// node_modules/cloudflare/resources/intel/attack-surface-report/issue-types.mjs
var IssueTypes;
var init_issue_types = __esm({
  "node_modules/cloudflare/resources/intel/attack-surface-report/issue-types.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    IssueTypes = class extends APIResource {
      static {
        __name(this, "IssueTypes");
      }
      /**
       * Get Security Center Issues Types
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/intel/attack-surface-report/issue-types`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(IssueTypes2) {
    })(IssueTypes || (IssueTypes = {}));
  }
});

// node_modules/cloudflare/resources/intel/attack-surface-report/issues.mjs
var Issues, IssueListResponsesV4PagePagination;
var init_issues = __esm({
  "node_modules/cloudflare/resources/intel/attack-surface-report/issues.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_issues();
    init_pagination();
    Issues = class extends APIResource {
      static {
        __name(this, "Issues");
      }
      /**
       * Get Security Center Issues
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/intel/attack-surface-report/issues`, IssueListResponsesV4PagePagination, { query, ...options });
      }
      /**
       * Get Security Center Issue Counts by Class
       */
      class(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/intel/attack-surface-report/issues/class`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Archive Security Center Insight
       */
      dismiss(issueId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/intel/attack-surface-report/${issueId}/dismiss`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get Security Center Issue Counts by Severity
       */
      severity(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/intel/attack-surface-report/issues/severity`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get Security Center Issue Counts by Type
       */
      type(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/intel/attack-surface-report/issues/type`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    IssueListResponsesV4PagePagination = class extends V4PagePagination {
      static {
        __name(this, "IssueListResponsesV4PagePagination");
      }
    };
    (function(Issues2) {
      Issues2.IssueListResponsesV4PagePagination = IssueListResponsesV4PagePagination;
    })(Issues || (Issues = {}));
  }
});

// node_modules/cloudflare/resources/intel/attack-surface-report/attack-surface-report.mjs
var AttackSurfaceReport;
var init_attack_surface_report = __esm({
  "node_modules/cloudflare/resources/intel/attack-surface-report/attack-surface-report.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_issue_types();
    init_issues();
    AttackSurfaceReport = class extends APIResource {
      static {
        __name(this, "AttackSurfaceReport");
      }
      constructor() {
        super(...arguments);
        this.issueTypes = new IssueTypes(this._client);
        this.issues = new Issues(this._client);
      }
    };
    (function(AttackSurfaceReport2) {
      AttackSurfaceReport2.IssueTypes = IssueTypes;
      AttackSurfaceReport2.Issues = Issues;
      AttackSurfaceReport2.IssueListResponsesV4PagePagination = IssueListResponsesV4PagePagination;
    })(AttackSurfaceReport || (AttackSurfaceReport = {}));
  }
});

// node_modules/cloudflare/resources/intel/domains/bulks.mjs
var Bulks;
var init_bulks = __esm({
  "node_modules/cloudflare/resources/intel/domains/bulks.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Bulks = class extends APIResource {
      static {
        __name(this, "Bulks");
      }
      /**
       * Get Multiple Domain Details
       */
      get(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/intel/domain/bulk`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Bulks2) {
    })(Bulks || (Bulks = {}));
  }
});

// node_modules/cloudflare/resources/intel/domains/domains.mjs
var Domains;
var init_domains = __esm({
  "node_modules/cloudflare/resources/intel/domains/domains.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_bulks();
    Domains = class extends APIResource {
      static {
        __name(this, "Domains");
      }
      constructor() {
        super(...arguments);
        this.bulks = new Bulks(this._client);
      }
      /**
       * Get Domain Details
       */
      get(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/intel/domain`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Domains5) {
      Domains5.Bulks = Bulks;
    })(Domains || (Domains = {}));
  }
});

// node_modules/cloudflare/resources/intel/indicator-feeds/permissions.mjs
var Permissions;
var init_permissions = __esm({
  "node_modules/cloudflare/resources/intel/indicator-feeds/permissions.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Permissions = class extends APIResource {
      static {
        __name(this, "Permissions");
      }
      /**
       * Grant permission to indicator feed
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/intel/indicator-feeds/permissions/add`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List indicator feed permissions
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/intel/indicator-feeds/permissions/view`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Revoke permission to indicator feed
       */
      delete(params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/intel/indicator-feeds/permissions/remove`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Permissions2) {
    })(Permissions || (Permissions = {}));
  }
});

// node_modules/cloudflare/resources/intel/indicator-feeds/snapshots.mjs
var Snapshots;
var init_snapshots = __esm({
  "node_modules/cloudflare/resources/intel/indicator-feeds/snapshots.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Snapshots = class extends APIResource {
      static {
        __name(this, "Snapshots");
      }
      /**
       * Update indicator feed data
       */
      update(feedId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/intel/indicator-feeds/${feedId}/snapshot`, multipartFormRequestOptions({ body, ...options }))._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Snapshots2) {
    })(Snapshots || (Snapshots = {}));
  }
});

// node_modules/cloudflare/resources/intel/indicator-feeds/indicator-feeds.mjs
var IndicatorFeeds, IndicatorFeedListResponsesSinglePage;
var init_indicator_feeds = __esm({
  "node_modules/cloudflare/resources/intel/indicator-feeds/indicator-feeds.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_indicator_feeds();
    init_permissions();
    init_snapshots();
    init_pagination();
    IndicatorFeeds = class extends APIResource {
      static {
        __name(this, "IndicatorFeeds");
      }
      constructor() {
        super(...arguments);
        this.snapshots = new Snapshots(this._client);
        this.permissions = new Permissions(this._client);
      }
      /**
       * Create new indicator feed
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/intel/indicator-feeds`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update indicator feed metadata
       */
      update(feedId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/intel/indicator-feeds/${feedId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get indicator feeds owned by this account
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/intel/indicator-feeds`, IndicatorFeedListResponsesSinglePage, options);
      }
      /**
       * Get indicator feed data
       */
      data(feedId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/intel/indicator-feeds/${feedId}/data`, {
          ...options,
          headers: { Accept: "text/csv", ...options?.headers }
        });
      }
      /**
       * Get indicator feed metadata
       */
      get(feedId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/intel/indicator-feeds/${feedId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    IndicatorFeedListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "IndicatorFeedListResponsesSinglePage");
      }
    };
    (function(IndicatorFeeds2) {
      IndicatorFeeds2.IndicatorFeedListResponsesSinglePage = IndicatorFeedListResponsesSinglePage;
      IndicatorFeeds2.Snapshots = Snapshots;
      IndicatorFeeds2.Permissions = Permissions;
    })(IndicatorFeeds || (IndicatorFeeds = {}));
  }
});

// node_modules/cloudflare/resources/intel/intel.mjs
var Intel;
var init_intel = __esm({
  "node_modules/cloudflare/resources/intel/intel.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_dns3();
    init_domain_history();
    init_ip_lists();
    init_ips3();
    init_miscategorizations();
    init_sinkholes();
    init_whois();
    init_asn();
    init_attack_surface_report();
    init_domains();
    init_indicator_feeds();
    Intel = class extends APIResource {
      static {
        __name(this, "Intel");
      }
      constructor() {
        super(...arguments);
        this.asn = new ASN(this._client);
        this.dns = new DNS3(this._client);
        this.domains = new Domains(this._client);
        this.domainHistory = new DomainHistoryResource(this._client);
        this.ips = new IPs3(this._client);
        this.ipLists = new IPLists(this._client);
        this.miscategorizations = new Miscategorizations(this._client);
        this.whois = new Whois(this._client);
        this.indicatorFeeds = new IndicatorFeeds(this._client);
        this.sinkholes = new Sinkholes(this._client);
        this.attackSurfaceReport = new AttackSurfaceReport(this._client);
      }
    };
    (function(Intel2) {
      Intel2.ASN = ASN;
      Intel2.DNS = DNS3;
      Intel2.DNSListResponsesV4PagePagination = DNSListResponsesV4PagePagination;
      Intel2.Domains = Domains;
      Intel2.DomainHistoryResource = DomainHistoryResource;
      Intel2.IPs = IPs3;
      Intel2.IPLists = IPLists;
      Intel2.Miscategorizations = Miscategorizations;
      Intel2.Whois = Whois;
      Intel2.IndicatorFeeds = IndicatorFeeds;
      Intel2.IndicatorFeedListResponsesSinglePage = IndicatorFeedListResponsesSinglePage;
      Intel2.Sinkholes = Sinkholes;
      Intel2.SinkholesSinglePage = SinkholesSinglePage;
      Intel2.AttackSurfaceReport = AttackSurfaceReport;
    })(Intel || (Intel = {}));
  }
});

// node_modules/cloudflare/resources/kv/namespaces/bulk.mjs
var Bulk;
var init_bulk = __esm({
  "node_modules/cloudflare/resources/kv/namespaces/bulk.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Bulk = class extends APIResource {
      static {
        __name(this, "Bulk");
      }
      /**
       * Write multiple keys and values at once. Body should be an array of up to 10,000
       * key-value pairs to be stored, along with optional expiration information.
       * Existing values and expirations will be overwritten. If neither `expiration` nor
       * `expiration_ttl` is specified, the key-value pair will never expire. If both are
       * set, `expiration_ttl` is used and `expiration` is ignored. The entire request
       * size must be 100 megabytes or less.
       */
      update(namespaceId, params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/storage/kv/namespaces/${namespaceId}/bulk`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Remove multiple KV pairs from the namespace. Body should be an array of up to
       * 10,000 keys to be removed.
       */
      delete(namespaceId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/storage/kv/namespaces/${namespaceId}/bulk`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Bulk2) {
    })(Bulk || (Bulk = {}));
  }
});

// node_modules/cloudflare/resources/kv/namespaces/keys.mjs
var Keys3, KeysCursorLimitPagination;
var init_keys3 = __esm({
  "node_modules/cloudflare/resources/kv/namespaces/keys.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_keys3();
    init_pagination();
    Keys3 = class extends APIResource {
      static {
        __name(this, "Keys");
      }
      /**
       * Lists a namespace's keys.
       */
      list(namespaceId, params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/storage/kv/namespaces/${namespaceId}/keys`, KeysCursorLimitPagination, { query, ...options });
      }
    };
    KeysCursorLimitPagination = class extends CursorLimitPagination {
      static {
        __name(this, "KeysCursorLimitPagination");
      }
    };
    (function(Keys6) {
      Keys6.KeysCursorLimitPagination = KeysCursorLimitPagination;
    })(Keys3 || (Keys3 = {}));
  }
});

// node_modules/cloudflare/resources/kv/namespaces/metadata.mjs
var Metadata;
var init_metadata = __esm({
  "node_modules/cloudflare/resources/kv/namespaces/metadata.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Metadata = class extends APIResource {
      static {
        __name(this, "Metadata");
      }
      /**
       * Returns the metadata associated with the given key in the given namespace. Use
       * URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key
       * name.
       */
      get(namespaceId, keyName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/storage/kv/namespaces/${namespaceId}/metadata/${keyName}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Metadata2) {
    })(Metadata || (Metadata = {}));
  }
});

// node_modules/cloudflare/resources/kv/namespaces/values.mjs
var Values;
var init_values = __esm({
  "node_modules/cloudflare/resources/kv/namespaces/values.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Values = class extends APIResource {
      static {
        __name(this, "Values");
      }
      /**
       * Write a value identified by a key. Use URL-encoding to use special characters
       * (for example, `:`, `!`, `%`) in the key name. Body should be the value to be
       * stored along with JSON metadata to be associated with the key/value pair.
       * Existing values, expirations, and metadata will be overwritten. If neither
       * `expiration` nor `expiration_ttl` is specified, the key-value pair will never
       * expire. If both are set, `expiration_ttl` is used and `expiration` is ignored.
       */
      update(namespaceId, keyName, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/storage/kv/namespaces/${namespaceId}/values/${keyName}`, multipartFormRequestOptions({ body, ...options }))._thenUnwrap((obj) => obj.result);
      }
      /**
       * Remove a KV pair from the namespace. Use URL-encoding to use special characters
       * (for example, `:`, `!`, `%`) in the key name.
       */
      delete(namespaceId, keyName, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/storage/kv/namespaces/${namespaceId}/values/${keyName}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Returns the value associated with the given key in the given namespace. Use
       * URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key
       * name. If the KV-pair is set to expire at some point, the expiration time as
       * measured in seconds since the UNIX epoch will be returned in the `expiration`
       * response header.
       */
      get(namespaceId, keyName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/storage/kv/namespaces/${namespaceId}/values/${keyName}`, { ...options, __binaryResponse: true });
      }
    };
    /* @__PURE__ */ (function(Values2) {
    })(Values || (Values = {}));
  }
});

// node_modules/cloudflare/resources/kv/namespaces/namespaces.mjs
var Namespaces2, NamespacesV4PagePaginationArray;
var init_namespaces2 = __esm({
  "node_modules/cloudflare/resources/kv/namespaces/namespaces.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_namespaces2();
    init_bulk();
    init_keys3();
    init_metadata();
    init_values();
    init_pagination();
    Namespaces2 = class extends APIResource {
      static {
        __name(this, "Namespaces");
      }
      constructor() {
        super(...arguments);
        this.bulk = new Bulk(this._client);
        this.keys = new Keys3(this._client);
        this.metadata = new Metadata(this._client);
        this.values = new Values(this._client);
      }
      /**
       * Creates a namespace under the given title. A `400` is returned if the account
       * already owns a namespace with this title. A namespace must be explicitly deleted
       * to be replaced.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/storage/kv/namespaces`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Modifies a namespace's title.
       */
      update(namespaceId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/storage/kv/namespaces/${namespaceId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Returns the namespaces owned by an account.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/storage/kv/namespaces`, NamespacesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Deletes the namespace corresponding to the given ID.
       */
      delete(namespaceId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/storage/kv/namespaces/${namespaceId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get the namespace corresponding to the given ID.
       */
      get(namespaceId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/storage/kv/namespaces/${namespaceId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    NamespacesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "NamespacesV4PagePaginationArray");
      }
    };
    (function(Namespaces4) {
      Namespaces4.NamespacesV4PagePaginationArray = NamespacesV4PagePaginationArray;
      Namespaces4.Bulk = Bulk;
      Namespaces4.Keys = Keys3;
      Namespaces4.KeysCursorLimitPagination = KeysCursorLimitPagination;
      Namespaces4.Metadata = Metadata;
      Namespaces4.Values = Values;
    })(Namespaces2 || (Namespaces2 = {}));
  }
});

// node_modules/cloudflare/resources/kv/kv.mjs
var KV;
var init_kv = __esm({
  "node_modules/cloudflare/resources/kv/kv.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_namespaces2();
    KV = class extends APIResource {
      static {
        __name(this, "KV");
      }
      constructor() {
        super(...arguments);
        this.namespaces = new Namespaces2(this._client);
      }
    };
    (function(KV2) {
      KV2.Namespaces = Namespaces2;
      KV2.NamespacesV4PagePaginationArray = NamespacesV4PagePaginationArray;
    })(KV || (KV = {}));
  }
});

// node_modules/cloudflare/resources/keyless-certificates.mjs
var KeylessCertificates, KeylessCertificatesSinglePage;
var init_keyless_certificates = __esm({
  "node_modules/cloudflare/resources/keyless-certificates.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_pagination();
    KeylessCertificates = class extends APIResource {
      static {
        __name(this, "KeylessCertificates");
      }
      /**
       * Create Keyless SSL Configuration
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/keyless_certificates`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List all Keyless SSL configurations for a given zone.
       */
      list(params, options) {
        const { zone_id } = params;
        return this._client.getAPIList(`/zones/${zone_id}/keyless_certificates`, KeylessCertificatesSinglePage, options);
      }
      /**
       * Delete Keyless SSL Configuration
       */
      delete(keylessCertificateId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/keyless_certificates/${keylessCertificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * This will update attributes of a Keyless SSL. Consists of one or more of the
       * following: host,name,port.
       */
      edit(keylessCertificateId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/keyless_certificates/${keylessCertificateId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get details for one Keyless SSL configuration.
       */
      get(keylessCertificateId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/keyless_certificates/${keylessCertificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    KeylessCertificatesSinglePage = class extends SinglePage {
      static {
        __name(this, "KeylessCertificatesSinglePage");
      }
    };
  }
});

// node_modules/cloudflare/resources/load-balancers/previews.mjs
var Previews2;
var init_previews2 = __esm({
  "node_modules/cloudflare/resources/load-balancers/previews.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Previews2 = class extends APIResource {
      static {
        __name(this, "Previews");
      }
      /**
       * Get the result of a previous preview operation using the provided preview_id.
       */
      get(previewId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/load_balancers/preview/${previewId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Previews4) {
    })(Previews2 || (Previews2 = {}));
  }
});

// node_modules/cloudflare/resources/load-balancers/regions.mjs
var Regions2;
var init_regions2 = __esm({
  "node_modules/cloudflare/resources/load-balancers/regions.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Regions2 = class extends APIResource {
      static {
        __name(this, "Regions");
      }
      /**
       * List all region mappings.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/load_balancers/regions`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a single region mapping.
       */
      get(regionId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/load_balancers/regions/${regionId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Regions3) {
    })(Regions2 || (Regions2 = {}));
  }
});

// node_modules/cloudflare/resources/load-balancers/searches.mjs
var Searches;
var init_searches = __esm({
  "node_modules/cloudflare/resources/load-balancers/searches.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Searches = class extends APIResource {
      static {
        __name(this, "Searches");
      }
      /**
       * Search for Load Balancing resources.
       */
      get(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/load_balancers/search`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Searches2) {
    })(Searches || (Searches = {}));
  }
});

// node_modules/cloudflare/resources/load-balancers/monitors/previews.mjs
var Previews3;
var init_previews3 = __esm({
  "node_modules/cloudflare/resources/load-balancers/monitors/previews.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Previews3 = class extends APIResource {
      static {
        __name(this, "Previews");
      }
      /**
       * Preview pools using the specified monitor with provided monitor details. The
       * returned preview_id can be used in the preview endpoint to retrieve the results.
       */
      create(monitorId, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/load_balancers/monitors/${monitorId}/preview`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Previews4) {
    })(Previews3 || (Previews3 = {}));
  }
});

// node_modules/cloudflare/resources/load-balancers/monitors/references.mjs
var References;
var init_references = __esm({
  "node_modules/cloudflare/resources/load-balancers/monitors/references.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    References = class extends APIResource {
      static {
        __name(this, "References");
      }
      /**
       * Get the list of resources that reference the provided monitor.
       */
      get(monitorId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/load_balancers/monitors/${monitorId}/references`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(References4) {
    })(References || (References = {}));
  }
});

// node_modules/cloudflare/resources/load-balancers/monitors/monitors.mjs
var Monitors, MonitorsSinglePage;
var init_monitors = __esm({
  "node_modules/cloudflare/resources/load-balancers/monitors/monitors.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_monitors();
    init_previews3();
    init_references();
    init_pagination();
    Monitors = class extends APIResource {
      static {
        __name(this, "Monitors");
      }
      constructor() {
        super(...arguments);
        this.previews = new Previews3(this._client);
        this.references = new References(this._client);
      }
      /**
       * Create a configured monitor.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/load_balancers/monitors`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Modify a configured monitor.
       */
      update(monitorId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/load_balancers/monitors/${monitorId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List configured monitors for an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/load_balancers/monitors`, MonitorsSinglePage, options);
      }
      /**
       * Delete a configured monitor.
       */
      delete(monitorId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/load_balancers/monitors/${monitorId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Apply changes to an existing monitor, overwriting the supplied properties.
       */
      edit(monitorId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/load_balancers/monitors/${monitorId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List a single configured monitor for an account.
       */
      get(monitorId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/load_balancers/monitors/${monitorId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    MonitorsSinglePage = class extends SinglePage {
      static {
        __name(this, "MonitorsSinglePage");
      }
    };
    (function(Monitors2) {
      Monitors2.MonitorsSinglePage = MonitorsSinglePage;
      Monitors2.Previews = Previews3;
      Monitors2.References = References;
    })(Monitors || (Monitors = {}));
  }
});

// node_modules/cloudflare/resources/load-balancers/pools/health.mjs
var Health;
var init_health = __esm({
  "node_modules/cloudflare/resources/load-balancers/pools/health.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Health = class extends APIResource {
      static {
        __name(this, "Health");
      }
      /**
       * Preview pool health using provided monitor details. The returned preview_id can
       * be used in the preview endpoint to retrieve the results.
       */
      create(poolId, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/load_balancers/pools/${poolId}/preview`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch the latest pool health status for a single pool.
       */
      get(poolId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/load_balancers/pools/${poolId}/health`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Health2) {
    })(Health || (Health = {}));
  }
});

// node_modules/cloudflare/resources/load-balancers/pools/references.mjs
var References2;
var init_references2 = __esm({
  "node_modules/cloudflare/resources/load-balancers/pools/references.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    References2 = class extends APIResource {
      static {
        __name(this, "References");
      }
      /**
       * Get the list of resources that reference the provided pool.
       */
      get(poolId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/load_balancers/pools/${poolId}/references`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(References4) {
    })(References2 || (References2 = {}));
  }
});

// node_modules/cloudflare/resources/load-balancers/pools/pools.mjs
var Pools, PoolsSinglePage;
var init_pools = __esm({
  "node_modules/cloudflare/resources/load-balancers/pools/pools.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_pools();
    init_health();
    init_references2();
    init_pagination();
    Pools = class extends APIResource {
      static {
        __name(this, "Pools");
      }
      constructor() {
        super(...arguments);
        this.health = new Health(this._client);
        this.references = new References2(this._client);
      }
      /**
       * Create a new pool.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/load_balancers/pools`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Modify a configured pool.
       */
      update(poolId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/load_balancers/pools/${poolId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List configured pools.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/load_balancers/pools`, PoolsSinglePage, {
          query,
          ...options
        });
      }
      /**
       * Delete a configured pool.
       */
      delete(poolId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/load_balancers/pools/${poolId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Apply changes to an existing pool, overwriting the supplied properties.
       */
      edit(poolId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/load_balancers/pools/${poolId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch a single configured pool.
       */
      get(poolId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/load_balancers/pools/${poolId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    PoolsSinglePage = class extends SinglePage {
      static {
        __name(this, "PoolsSinglePage");
      }
    };
    (function(Pools2) {
      Pools2.PoolsSinglePage = PoolsSinglePage;
      Pools2.Health = Health;
      Pools2.References = References2;
    })(Pools || (Pools = {}));
  }
});

// node_modules/cloudflare/resources/load-balancers/load-balancers.mjs
var LoadBalancers, LoadBalancersSinglePage;
var init_load_balancers = __esm({
  "node_modules/cloudflare/resources/load-balancers/load-balancers.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_previews2();
    init_regions2();
    init_searches();
    init_monitors();
    init_pools();
    init_pagination();
    LoadBalancers = class extends APIResource {
      static {
        __name(this, "LoadBalancers");
      }
      constructor() {
        super(...arguments);
        this.monitors = new Monitors(this._client);
        this.pools = new Pools(this._client);
        this.previews = new Previews2(this._client);
        this.regions = new Regions2(this._client);
        this.searches = new Searches(this._client);
      }
      /**
       * Create a new load balancer.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/load_balancers`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a configured load balancer.
       */
      update(loadBalancerId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/load_balancers/${loadBalancerId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List configured load balancers.
       */
      list(params, options) {
        const { zone_id } = params;
        return this._client.getAPIList(`/zones/${zone_id}/load_balancers`, LoadBalancersSinglePage, options);
      }
      /**
       * Delete a configured load balancer.
       */
      delete(loadBalancerId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/load_balancers/${loadBalancerId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Apply changes to an existing load balancer, overwriting the supplied properties.
       */
      edit(loadBalancerId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/load_balancers/${loadBalancerId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch a single configured load balancer.
       */
      get(loadBalancerId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/load_balancers/${loadBalancerId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    LoadBalancersSinglePage = class extends SinglePage {
      static {
        __name(this, "LoadBalancersSinglePage");
      }
    };
    (function(LoadBalancers2) {
      LoadBalancers2.Monitors = Monitors;
      LoadBalancers2.MonitorsSinglePage = MonitorsSinglePage;
      LoadBalancers2.Pools = Pools;
      LoadBalancers2.PoolsSinglePage = PoolsSinglePage;
      LoadBalancers2.Previews = Previews2;
      LoadBalancers2.Regions = Regions2;
      LoadBalancers2.Searches = Searches;
    })(LoadBalancers || (LoadBalancers = {}));
  }
});

// node_modules/cloudflare/resources/logpush/edge.mjs
var Edge;
var init_edge = __esm({
  "node_modules/cloudflare/resources/logpush/edge.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Edge = class extends APIResource {
      static {
        __name(this, "Edge");
      }
      /**
       * Creates a new Instant Logs job for a zone.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/logpush/edge`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists Instant Logs jobs for a zone.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/logpush/edge`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Edge2) {
    })(Edge || (Edge = {}));
  }
});

// node_modules/cloudflare/resources/logpush/jobs.mjs
var Jobs, LogpushJobsSinglePage;
var init_jobs = __esm({
  "node_modules/cloudflare/resources/logpush/jobs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    init_jobs();
    init_pagination();
    Jobs = class extends APIResource {
      static {
        __name(this, "Jobs");
      }
      /**
       * Creates a new Logpush job for an account or zone.
       */
      create(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/logpush/jobs`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a Logpush job.
       */
      update(jobId, params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.put(`/${accountOrZone}/${accountOrZoneId}/logpush/jobs/${jobId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      list(params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list({}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.getAPIList(`/${accountOrZone}/${accountOrZoneId}/logpush/jobs`, LogpushJobsSinglePage, options);
      }
      delete(jobId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.delete(jobId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.delete(`/${accountOrZone}/${accountOrZoneId}/logpush/jobs/${jobId}`, options)._thenUnwrap((obj) => obj.result);
      }
      get(jobId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get(jobId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/logpush/jobs/${jobId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    LogpushJobsSinglePage = class extends SinglePage {
      static {
        __name(this, "LogpushJobsSinglePage");
      }
    };
    (function(Jobs3) {
      Jobs3.LogpushJobsSinglePage = LogpushJobsSinglePage;
    })(Jobs || (Jobs = {}));
  }
});

// node_modules/cloudflare/resources/logpush/ownership.mjs
var Ownership;
var init_ownership = __esm({
  "node_modules/cloudflare/resources/logpush/ownership.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_error();
    Ownership = class extends APIResource {
      static {
        __name(this, "Ownership");
      }
      /**
       * Gets a new ownership challenge sent to your destination.
       */
      create(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/logpush/ownership`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Validates ownership challenge of the destination.
       */
      validate(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/logpush/ownership/validate`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Ownership2) {
    })(Ownership || (Ownership = {}));
  }
});

// node_modules/cloudflare/resources/logpush/validate.mjs
var Validate;
var init_validate = __esm({
  "node_modules/cloudflare/resources/logpush/validate.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_error();
    Validate = class extends APIResource {
      static {
        __name(this, "Validate");
      }
      /**
       * Checks if there is an existing job with a destination.
       */
      destination(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/logpush/validate/destination/exists`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Validates logpull origin with logpull_options.
       */
      origin(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/logpush/validate/origin`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Validate2) {
    })(Validate || (Validate = {}));
  }
});

// node_modules/cloudflare/resources/logpush/datasets/fields.mjs
var Fields;
var init_fields = __esm({
  "node_modules/cloudflare/resources/logpush/datasets/fields.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    Fields = class extends APIResource {
      static {
        __name(this, "Fields");
      }
      get(datasetId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get(datasetId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/logpush/datasets/${datasetId}/fields`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Fields3) {
    })(Fields || (Fields = {}));
  }
});

// node_modules/cloudflare/resources/logpush/datasets/jobs.mjs
var Jobs2;
var init_jobs2 = __esm({
  "node_modules/cloudflare/resources/logpush/datasets/jobs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    Jobs2 = class extends APIResource {
      static {
        __name(this, "Jobs");
      }
      get(datasetId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get(datasetId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/logpush/datasets/${datasetId}/jobs`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Jobs3) {
    })(Jobs2 || (Jobs2 = {}));
  }
});

// node_modules/cloudflare/resources/logpush/datasets/datasets.mjs
var Datasets;
var init_datasets = __esm({
  "node_modules/cloudflare/resources/logpush/datasets/datasets.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_fields();
    init_jobs2();
    Datasets = class extends APIResource {
      static {
        __name(this, "Datasets");
      }
      constructor() {
        super(...arguments);
        this.fields = new Fields(this._client);
        this.jobs = new Jobs2(this._client);
      }
    };
    (function(Datasets4) {
      Datasets4.Fields = Fields;
      Datasets4.Jobs = Jobs2;
    })(Datasets || (Datasets = {}));
  }
});

// node_modules/cloudflare/resources/logpush/logpush.mjs
var Logpush;
var init_logpush = __esm({
  "node_modules/cloudflare/resources/logpush/logpush.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_edge();
    init_jobs();
    init_ownership();
    init_validate();
    init_datasets();
    Logpush = class extends APIResource {
      static {
        __name(this, "Logpush");
      }
      constructor() {
        super(...arguments);
        this.datasets = new Datasets(this._client);
        this.edge = new Edge(this._client);
        this.jobs = new Jobs(this._client);
        this.ownership = new Ownership(this._client);
        this.validate = new Validate(this._client);
      }
    };
    (function(Logpush2) {
      Logpush2.Datasets = Datasets;
      Logpush2.Edge = Edge;
      Logpush2.Jobs = Jobs;
      Logpush2.LogpushJobsSinglePage = LogpushJobsSinglePage;
      Logpush2.Ownership = Ownership;
      Logpush2.Validate = Validate;
    })(Logpush || (Logpush = {}));
  }
});

// node_modules/cloudflare/resources/logs/rayid.mjs
var RayID;
var init_rayid = __esm({
  "node_modules/cloudflare/resources/logs/rayid.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    RayID = class extends APIResource {
      static {
        __name(this, "RayID");
      }
      get(zoneIdentifier, rayIdentifier, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(zoneIdentifier, rayIdentifier, {}, query);
        }
        return this._client.get(`/zones/${zoneIdentifier}/logs/rayids/${rayIdentifier}`, { query, ...options });
      }
    };
    /* @__PURE__ */ (function(RayID2) {
    })(RayID || (RayID = {}));
  }
});

// node_modules/cloudflare/resources/logs/control/retention.mjs
var Retention;
var init_retention = __esm({
  "node_modules/cloudflare/resources/logs/control/retention.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Retention = class extends APIResource {
      static {
        __name(this, "Retention");
      }
      /**
       * Updates log retention flag for Logpull API.
       */
      create(zoneIdentifier, body, options) {
        return this._client.post(`/zones/${zoneIdentifier}/logs/control/retention/flag`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Gets log retention flag for Logpull API.
       */
      get(zoneIdentifier, options) {
        return this._client.get(`/zones/${zoneIdentifier}/logs/control/retention/flag`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Retention2) {
    })(Retention || (Retention = {}));
  }
});

// node_modules/cloudflare/resources/logs/control/cmb/config.mjs
var Config;
var init_config = __esm({
  "node_modules/cloudflare/resources/logs/control/cmb/config.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Config = class extends APIResource {
      static {
        __name(this, "Config");
      }
      /**
       * Updates CMB config.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/logs/control/cmb/config`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Deletes CMB config.
       */
      delete(params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/logs/control/cmb/config`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Gets CMB config.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/logs/control/cmb/config`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Config2) {
    })(Config || (Config = {}));
  }
});

// node_modules/cloudflare/resources/logs/control/cmb/cmb.mjs
var Cmb;
var init_cmb = __esm({
  "node_modules/cloudflare/resources/logs/control/cmb/cmb.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_config();
    Cmb = class extends APIResource {
      static {
        __name(this, "Cmb");
      }
      constructor() {
        super(...arguments);
        this.config = new Config(this._client);
      }
    };
    (function(Cmb2) {
      Cmb2.Config = Config;
    })(Cmb || (Cmb = {}));
  }
});

// node_modules/cloudflare/resources/logs/control/control.mjs
var Control;
var init_control = __esm({
  "node_modules/cloudflare/resources/logs/control/control.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_retention();
    init_cmb();
    Control = class extends APIResource {
      static {
        __name(this, "Control");
      }
      constructor() {
        super(...arguments);
        this.retention = new Retention(this._client);
        this.cmb = new Cmb(this._client);
      }
    };
    (function(Control2) {
      Control2.Retention = Retention;
      Control2.Cmb = Cmb;
    })(Control || (Control = {}));
  }
});

// node_modules/cloudflare/resources/logs/received/fields.mjs
var Fields2;
var init_fields2 = __esm({
  "node_modules/cloudflare/resources/logs/received/fields.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Fields2 = class extends APIResource {
      static {
        __name(this, "Fields");
      }
      /**
       * Lists all fields available. The response is json object with key-value pairs,
       * where keys are field names, and values are descriptions.
       */
      get(zoneIdentifier, options) {
        return this._client.get(`/zones/${zoneIdentifier}/logs/received/fields`, options);
      }
    };
    /* @__PURE__ */ (function(Fields3) {
    })(Fields2 || (Fields2 = {}));
  }
});

// node_modules/cloudflare/resources/logs/received/received.mjs
var Received;
var init_received = __esm({
  "node_modules/cloudflare/resources/logs/received/received.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_fields2();
    Received = class extends APIResource {
      static {
        __name(this, "Received");
      }
      constructor() {
        super(...arguments);
        this.fields = new Fields2(this._client);
      }
      /**
       * The `/received` api route allows customers to retrieve their edge HTTP logs. The
       * basic access pattern is "give me all the logs for zone Z for minute M", where
       * the minute M refers to the time records were received at Cloudflare's central
       * data center. `start` is inclusive, and `end` is exclusive. Because of that, to
       * get all data, at minutely cadence, starting at 10AM, the proper values are:
       * `start=2018-05-20T10:00:00Z&end=2018-05-20T10:01:00Z`, then
       * `start=2018-05-20T10:01:00Z&end=2018-05-20T10:02:00Z` and so on; the overlap
       * will be handled properly.
       */
      get(zoneIdentifier, query, options) {
        return this._client.get(`/zones/${zoneIdentifier}/logs/received`, { query, ...options });
      }
    };
    (function(Received2) {
      Received2.Fields = Fields2;
    })(Received || (Received = {}));
  }
});

// node_modules/cloudflare/resources/logs/logs.mjs
var Logs2;
var init_logs2 = __esm({
  "node_modules/cloudflare/resources/logs/logs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_rayid();
    init_control();
    init_received();
    Logs2 = class extends APIResource {
      static {
        __name(this, "Logs");
      }
      constructor() {
        super(...arguments);
        this.control = new Control(this._client);
        this.RayID = new RayID(this._client);
        this.received = new Received(this._client);
      }
    };
    (function(Logs5) {
      Logs5.Control = Control;
      Logs5.RayID = RayID;
      Logs5.Received = Received;
    })(Logs2 || (Logs2 = {}));
  }
});

// node_modules/cloudflare/resources/mtls-certificates/associations.mjs
var Associations;
var init_associations = __esm({
  "node_modules/cloudflare/resources/mtls-certificates/associations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Associations = class extends APIResource {
      static {
        __name(this, "Associations");
      }
      /**
       * Lists all active associations between the certificate and Cloudflare services.
       */
      get(mtlsCertificateId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/mtls_certificates/${mtlsCertificateId}/associations`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Associations2) {
    })(Associations || (Associations = {}));
  }
});

// node_modules/cloudflare/resources/mtls-certificates/mtls-certificates.mjs
var MTLSCertificates, MTLSCertificatesSinglePage;
var init_mtls_certificates = __esm({
  "node_modules/cloudflare/resources/mtls-certificates/mtls-certificates.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_associations();
    init_pagination();
    MTLSCertificates = class extends APIResource {
      static {
        __name(this, "MTLSCertificates");
      }
      constructor() {
        super(...arguments);
        this.associations = new Associations(this._client);
      }
      /**
       * Upload a certificate that you want to use with mTLS-enabled Cloudflare services.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/mtls_certificates`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists all mTLS certificates.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/mtls_certificates`, MTLSCertificatesSinglePage, options);
      }
      /**
       * Deletes the mTLS certificate unless the certificate is in use by one or more
       * Cloudflare services.
       */
      delete(mtlsCertificateId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/mtls_certificates/${mtlsCertificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a single mTLS certificate.
       */
      get(mtlsCertificateId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/mtls_certificates/${mtlsCertificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    MTLSCertificatesSinglePage = class extends SinglePage {
      static {
        __name(this, "MTLSCertificatesSinglePage");
      }
    };
    (function(MTLSCertificates2) {
      MTLSCertificates2.Associations = Associations;
    })(MTLSCertificates || (MTLSCertificates = {}));
  }
});

// node_modules/cloudflare/resources/magic-network-monitoring/configs/full.mjs
var Full;
var init_full = __esm({
  "node_modules/cloudflare/resources/magic-network-monitoring/configs/full.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Full = class extends APIResource {
      static {
        __name(this, "Full");
      }
      /**
       * Lists default sampling, router IPs, and rules for account.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/mnm/config/full`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Full2) {
    })(Full || (Full = {}));
  }
});

// node_modules/cloudflare/resources/magic-network-monitoring/configs/configs.mjs
var Configs2;
var init_configs2 = __esm({
  "node_modules/cloudflare/resources/magic-network-monitoring/configs/configs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_full();
    Configs2 = class extends APIResource {
      static {
        __name(this, "Configs");
      }
      constructor() {
        super(...arguments);
        this.full = new Full(this._client);
      }
      /**
       * Create a new network monitoring configuration.
       */
      create(params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/mnm/config`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update an existing network monitoring configuration, requires the entire
       * configuration to be updated at once.
       */
      update(params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/mnm/config`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Delete an existing network monitoring configuration.
       */
      delete(params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/mnm/config`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update fields in an existing network monitoring configuration.
       */
      edit(params, options) {
        const { account_id, body } = params;
        return this._client.patch(`/accounts/${account_id}/mnm/config`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists default sampling and router IPs for account.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/mnm/config`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Configs3) {
      Configs3.Full = Full;
    })(Configs2 || (Configs2 = {}));
  }
});

// node_modules/cloudflare/resources/magic-network-monitoring/rules/advertisements.mjs
var Advertisements;
var init_advertisements = __esm({
  "node_modules/cloudflare/resources/magic-network-monitoring/rules/advertisements.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Advertisements = class extends APIResource {
      static {
        __name(this, "Advertisements");
      }
      /**
       * Update advertisement for rule.
       */
      edit(ruleId, params, options) {
        const { account_id, body } = params;
        return this._client.patch(`/accounts/${account_id}/mnm/rules/${ruleId}/advertisement`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Advertisements2) {
    })(Advertisements || (Advertisements = {}));
  }
});

// node_modules/cloudflare/resources/magic-network-monitoring/rules/rules.mjs
var Rules5, MagicNetworkMonitoringRulesSinglePage;
var init_rules5 = __esm({
  "node_modules/cloudflare/resources/magic-network-monitoring/rules/rules.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_rules5();
    init_advertisements();
    init_pagination();
    Rules5 = class extends APIResource {
      static {
        __name(this, "Rules");
      }
      constructor() {
        super(...arguments);
        this.advertisements = new Advertisements(this._client);
      }
      /**
       * Create network monitoring rules for account. Currently only supports creating a
       * single rule per API request.
       */
      create(params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/mnm/rules`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update network monitoring rules for account.
       */
      update(params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/mnm/rules`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists network monitoring rules for account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/mnm/rules`, MagicNetworkMonitoringRulesSinglePage, options);
      }
      /**
       * Delete a network monitoring rule for account.
       */
      delete(ruleId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/mnm/rules/${ruleId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a network monitoring rule for account.
       */
      edit(ruleId, params, options) {
        const { account_id, body } = params;
        return this._client.patch(`/accounts/${account_id}/mnm/rules/${ruleId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List a single network monitoring rule for account.
       */
      get(ruleId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/mnm/rules/${ruleId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    MagicNetworkMonitoringRulesSinglePage = class extends SinglePage {
      static {
        __name(this, "MagicNetworkMonitoringRulesSinglePage");
      }
    };
    (function(Rules12) {
      Rules12.MagicNetworkMonitoringRulesSinglePage = MagicNetworkMonitoringRulesSinglePage;
      Rules12.Advertisements = Advertisements;
    })(Rules5 || (Rules5 = {}));
  }
});

// node_modules/cloudflare/resources/magic-network-monitoring/magic-network-monitoring.mjs
var MagicNetworkMonitoring;
var init_magic_network_monitoring = __esm({
  "node_modules/cloudflare/resources/magic-network-monitoring/magic-network-monitoring.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_configs2();
    init_rules5();
    MagicNetworkMonitoring = class extends APIResource {
      static {
        __name(this, "MagicNetworkMonitoring");
      }
      constructor() {
        super(...arguments);
        this.configs = new Configs2(this._client);
        this.rules = new Rules5(this._client);
      }
    };
    (function(MagicNetworkMonitoring2) {
      MagicNetworkMonitoring2.Configs = Configs2;
      MagicNetworkMonitoring2.Rules = Rules5;
      MagicNetworkMonitoring2.MagicNetworkMonitoringRulesSinglePage = MagicNetworkMonitoringRulesSinglePage;
    })(MagicNetworkMonitoring || (MagicNetworkMonitoring = {}));
  }
});

// node_modules/cloudflare/resources/magic-transit/apps.mjs
var Apps, AppListResponsesSinglePage;
var init_apps = __esm({
  "node_modules/cloudflare/resources/magic-transit/apps.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_apps();
    init_pagination();
    Apps = class extends APIResource {
      static {
        __name(this, "Apps");
      }
      /**
       * Creates a new App for an account
       */
      create(params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/magic/apps`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an Account App
       */
      update(accountAppId, params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/magic/apps/${accountAppId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists Apps associated with an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/magic/apps`, AppListResponsesSinglePage, options);
      }
      /**
       * Deletes specific Account App.
       */
      delete(accountAppId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/magic/apps/${accountAppId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    AppListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "AppListResponsesSinglePage");
      }
    };
    (function(Apps3) {
      Apps3.AppListResponsesSinglePage = AppListResponsesSinglePage;
    })(Apps || (Apps = {}));
  }
});

// node_modules/cloudflare/resources/magic-transit/cf-interconnects.mjs
var CfInterconnects;
var init_cf_interconnects = __esm({
  "node_modules/cloudflare/resources/magic-transit/cf-interconnects.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    CfInterconnects = class extends APIResource {
      static {
        __name(this, "CfInterconnects");
      }
      /**
       * Updates a specific interconnect associated with an account. Use
       * `?validate_only=true` as an optional query parameter to only run validation
       * without persisting changes.
       */
      update(cfInterconnectId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/magic/cf_interconnects/${cfInterconnectId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists interconnects associated with an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/magic/cf_interconnects`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists details for a specific interconnect.
       */
      get(cfInterconnectId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/magic/cf_interconnects/${cfInterconnectId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(CfInterconnects2) {
    })(CfInterconnects || (CfInterconnects = {}));
  }
});

// node_modules/cloudflare/resources/magic-transit/connectors.mjs
var Connectors, ConnectorListResponsesSinglePage;
var init_connectors = __esm({
  "node_modules/cloudflare/resources/magic-transit/connectors.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_connectors();
    init_pagination();
    Connectors = class extends APIResource {
      static {
        __name(this, "Connectors");
      }
      /**
       * Replace Connector
       */
      update(connectorId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/magic/connectors/${connectorId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List Connectors
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/magic/connectors`, ConnectorListResponsesSinglePage, options);
      }
      /**
       * Update Connector
       */
      edit(connectorId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/magic/connectors/${connectorId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch Connector
       */
      get(connectorId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/magic/connectors/${connectorId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ConnectorListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "ConnectorListResponsesSinglePage");
      }
    };
    (function(Connectors3) {
      Connectors3.ConnectorListResponsesSinglePage = ConnectorListResponsesSinglePage;
    })(Connectors || (Connectors = {}));
  }
});

// node_modules/cloudflare/resources/magic-transit/gre-tunnels.mjs
var GRETunnels;
var init_gre_tunnels = __esm({
  "node_modules/cloudflare/resources/magic-transit/gre-tunnels.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    GRETunnels = class extends APIResource {
      static {
        __name(this, "GRETunnels");
      }
      /**
       * Creates new GRE tunnels. Use `?validate_only=true` as an optional query
       * parameter to only run validation without persisting changes.
       */
      create(params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/magic/gre_tunnels`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a specific GRE tunnel. Use `?validate_only=true` as an optional query
       * parameter to only run validation without persisting changes.
       */
      update(greTunnelId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/magic/gre_tunnels/${greTunnelId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists GRE tunnels associated with an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/magic/gre_tunnels`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Disables and removes a specific static GRE tunnel. Use `?validate_only=true` as
       * an optional query parameter to only run validation without persisting changes.
       */
      delete(greTunnelId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/magic/gre_tunnels/${greTunnelId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists informtion for a specific GRE tunnel.
       */
      get(greTunnelId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/magic/gre_tunnels/${greTunnelId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(GRETunnels2) {
    })(GRETunnels || (GRETunnels = {}));
  }
});

// node_modules/cloudflare/resources/magic-transit/ipsec-tunnels.mjs
var IPSECTunnels;
var init_ipsec_tunnels = __esm({
  "node_modules/cloudflare/resources/magic-transit/ipsec-tunnels.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    IPSECTunnels = class extends APIResource {
      static {
        __name(this, "IPSECTunnels");
      }
      /**
       * Creates new IPsec tunnels associated with an account. Use `?validate_only=true`
       * as an optional query parameter to only run validation without persisting
       * changes.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/magic/ipsec_tunnels`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a specific IPsec tunnel associated with an account. Use
       * `?validate_only=true` as an optional query parameter to only run validation
       * without persisting changes.
       */
      update(ipsecTunnelId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/magic/ipsec_tunnels/${ipsecTunnelId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists IPsec tunnels associated with an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/magic/ipsec_tunnels`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Disables and removes a specific static IPsec Tunnel associated with an account.
       * Use `?validate_only=true` as an optional query parameter to only run validation
       * without persisting changes.
       */
      delete(ipsecTunnelId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/magic/ipsec_tunnels/${ipsecTunnelId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists details for a specific IPsec tunnel.
       */
      get(ipsecTunnelId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/magic/ipsec_tunnels/${ipsecTunnelId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Generates a Pre Shared Key for a specific IPsec tunnel used in the IKE session.
       * Use `?validate_only=true` as an optional query parameter to only run validation
       * without persisting changes. After a PSK is generated, the PSK is immediately
       * persisted to Cloudflare's edge and cannot be retrieved later. Note the PSK in a
       * safe place.
       */
      pskGenerate(ipsecTunnelId, params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/magic/ipsec_tunnels/${ipsecTunnelId}/psk_generate`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(IPSECTunnels2) {
    })(IPSECTunnels || (IPSECTunnels = {}));
  }
});

// node_modules/cloudflare/resources/magic-transit/routes.mjs
var Routes;
var init_routes = __esm({
  "node_modules/cloudflare/resources/magic-transit/routes.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Routes = class extends APIResource {
      static {
        __name(this, "Routes");
      }
      /**
       * Creates a new Magic static route. Use `?validate_only=true` as an optional query
       * parameter to run validation only without persisting changes.
       */
      create(params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/magic/routes`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a specific Magic static route. Use `?validate_only=true` as an optional
       * query parameter to run validation only without persisting changes.
       */
      update(routeId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/magic/routes/${routeId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List all Magic static routes.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/magic/routes`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Disable and remove a specific Magic static route.
       */
      delete(routeId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/magic/routes/${routeId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Delete multiple Magic static routes.
       */
      empty(params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/magic/routes`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a specific Magic static route.
       */
      get(routeId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/magic/routes/${routeId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Routes4) {
    })(Routes || (Routes = {}));
  }
});

// node_modules/cloudflare/resources/magic-transit/sites/acls.mjs
var ACLs, ACLsSinglePage;
var init_acls = __esm({
  "node_modules/cloudflare/resources/magic-transit/sites/acls.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_acls();
    init_pagination();
    ACLs = class extends APIResource {
      static {
        __name(this, "ACLs");
      }
      /**
       * Creates a new Site ACL.
       */
      create(siteId, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/magic/sites/${siteId}/acls`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a specific Site ACL.
       */
      update(siteId, aclId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/magic/sites/${siteId}/acls/${aclId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists Site ACLs associated with an account.
       */
      list(siteId, params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/magic/sites/${siteId}/acls`, ACLsSinglePage, options);
      }
      /**
       * Remove a specific Site ACL.
       */
      delete(siteId, aclId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/magic/sites/${siteId}/acls/${aclId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Patch a specific Site ACL.
       */
      edit(siteId, aclId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/magic/sites/${siteId}/acls/${aclId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a specific Site ACL.
       */
      get(siteId, aclId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/magic/sites/${siteId}/acls/${aclId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ACLsSinglePage = class extends SinglePage {
      static {
        __name(this, "ACLsSinglePage");
      }
    };
    (function(ACLs3) {
      ACLs3.ACLsSinglePage = ACLsSinglePage;
    })(ACLs || (ACLs = {}));
  }
});

// node_modules/cloudflare/resources/magic-transit/sites/lans.mjs
var LANs, LANsSinglePage;
var init_lans = __esm({
  "node_modules/cloudflare/resources/magic-transit/sites/lans.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_lans();
    init_pagination();
    LANs = class extends APIResource {
      static {
        __name(this, "LANs");
      }
      /**
       * Creates a new Site LAN. If the site is in high availability mode,
       * static_addressing is required along with secondary and virtual address.
       */
      create(siteId, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/magic/sites/${siteId}/lans`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a specific Site LAN.
       */
      update(siteId, lanId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/magic/sites/${siteId}/lans/${lanId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists Site LANs associated with an account.
       */
      list(siteId, params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/magic/sites/${siteId}/lans`, LANsSinglePage, options);
      }
      /**
       * Remove a specific Site LAN.
       */
      delete(siteId, lanId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/magic/sites/${siteId}/lans/${lanId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Patch a specific Site LAN.
       */
      edit(siteId, lanId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/magic/sites/${siteId}/lans/${lanId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a specific Site LAN.
       */
      get(siteId, lanId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/magic/sites/${siteId}/lans/${lanId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    LANsSinglePage = class extends SinglePage {
      static {
        __name(this, "LANsSinglePage");
      }
    };
    (function(LANs2) {
      LANs2.LANsSinglePage = LANsSinglePage;
    })(LANs || (LANs = {}));
  }
});

// node_modules/cloudflare/resources/magic-transit/sites/wans.mjs
var WANs, WANsSinglePage;
var init_wans = __esm({
  "node_modules/cloudflare/resources/magic-transit/sites/wans.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_wans();
    init_pagination();
    WANs = class extends APIResource {
      static {
        __name(this, "WANs");
      }
      /**
       * Creates a new Site WAN.
       */
      create(siteId, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/magic/sites/${siteId}/wans`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a specific Site WAN.
       */
      update(siteId, wanId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/magic/sites/${siteId}/wans/${wanId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists Site WANs associated with an account.
       */
      list(siteId, params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/magic/sites/${siteId}/wans`, WANsSinglePage, options);
      }
      /**
       * Remove a specific Site WAN.
       */
      delete(siteId, wanId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/magic/sites/${siteId}/wans/${wanId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Patch a specific Site WAN.
       */
      edit(siteId, wanId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/magic/sites/${siteId}/wans/${wanId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a specific Site WAN.
       */
      get(siteId, wanId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/magic/sites/${siteId}/wans/${wanId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    WANsSinglePage = class extends SinglePage {
      static {
        __name(this, "WANsSinglePage");
      }
    };
    (function(WANs2) {
      WANs2.WANsSinglePage = WANsSinglePage;
    })(WANs || (WANs = {}));
  }
});

// node_modules/cloudflare/resources/magic-transit/sites/sites.mjs
var Sites, SitesSinglePage;
var init_sites = __esm({
  "node_modules/cloudflare/resources/magic-transit/sites/sites.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_sites();
    init_acls();
    init_lans();
    init_wans();
    init_pagination();
    Sites = class extends APIResource {
      static {
        __name(this, "Sites");
      }
      constructor() {
        super(...arguments);
        this.acls = new ACLs(this._client);
        this.lans = new LANs(this._client);
        this.wans = new WANs(this._client);
      }
      /**
       * Creates a new Site
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/magic/sites`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a specific Site.
       */
      update(siteId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/magic/sites/${siteId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists Sites associated with an account. Use connector_identifier query param to
       * return sites where connector_identifier matches either site.ConnectorID or
       * site.SecondaryConnectorID.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/magic/sites`, SitesSinglePage, {
          query,
          ...options
        });
      }
      /**
       * Remove a specific Site.
       */
      delete(siteId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/magic/sites/${siteId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Patch a specific Site.
       */
      edit(siteId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/magic/sites/${siteId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a specific Site.
       */
      get(siteId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/magic/sites/${siteId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    SitesSinglePage = class extends SinglePage {
      static {
        __name(this, "SitesSinglePage");
      }
    };
    (function(Sites2) {
      Sites2.SitesSinglePage = SitesSinglePage;
      Sites2.ACLs = ACLs;
      Sites2.ACLsSinglePage = ACLsSinglePage;
      Sites2.LANs = LANs;
      Sites2.LANsSinglePage = LANsSinglePage;
      Sites2.WANs = WANs;
      Sites2.WANsSinglePage = WANsSinglePage;
    })(Sites || (Sites = {}));
  }
});

// node_modules/cloudflare/resources/magic-transit/magic-transit.mjs
var MagicTransit;
var init_magic_transit = __esm({
  "node_modules/cloudflare/resources/magic-transit/magic-transit.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_apps();
    init_cf_interconnects();
    init_connectors();
    init_gre_tunnels();
    init_ipsec_tunnels();
    init_routes();
    init_sites();
    MagicTransit = class extends APIResource {
      static {
        __name(this, "MagicTransit");
      }
      constructor() {
        super(...arguments);
        this.apps = new Apps(this._client);
        this.cfInterconnects = new CfInterconnects(this._client);
        this.greTunnels = new GRETunnels(this._client);
        this.ipsecTunnels = new IPSECTunnels(this._client);
        this.routes = new Routes(this._client);
        this.sites = new Sites(this._client);
        this.connectors = new Connectors(this._client);
      }
    };
    (function(MagicTransit2) {
      MagicTransit2.Apps = Apps;
      MagicTransit2.AppListResponsesSinglePage = AppListResponsesSinglePage;
      MagicTransit2.CfInterconnects = CfInterconnects;
      MagicTransit2.GRETunnels = GRETunnels;
      MagicTransit2.IPSECTunnels = IPSECTunnels;
      MagicTransit2.Routes = Routes;
      MagicTransit2.Sites = Sites;
      MagicTransit2.SitesSinglePage = SitesSinglePage;
      MagicTransit2.Connectors = Connectors;
      MagicTransit2.ConnectorListResponsesSinglePage = ConnectorListResponsesSinglePage;
    })(MagicTransit || (MagicTransit = {}));
  }
});

// node_modules/cloudflare/resources/managed-headers.mjs
var ManagedHeaders;
var init_managed_headers = __esm({
  "node_modules/cloudflare/resources/managed-headers.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    ManagedHeaders = class extends APIResource {
      static {
        __name(this, "ManagedHeaders");
      }
      /**
       * Fetches a list of all Managed Transforms.
       */
      list(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/managed_headers`, options);
      }
      /**
       * Updates the status of one or more Managed Transforms.
       */
      edit(params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/managed_headers`, { body, ...options });
      }
    };
  }
});

// node_modules/cloudflare/resources/memberships.mjs
var Memberships, MembershipsV4PagePaginationArray;
var init_memberships = __esm({
  "node_modules/cloudflare/resources/memberships.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_pagination();
    Memberships = class extends APIResource {
      static {
        __name(this, "Memberships");
      }
      /**
       * Accept or reject this account invitation.
       */
      update(membershipId, body, options) {
        return this._client.put(`/memberships/${membershipId}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/memberships", MembershipsV4PagePaginationArray, { query, ...options });
      }
      /**
       * Remove the associated member from an account.
       */
      delete(membershipId, options) {
        return this._client.delete(`/memberships/${membershipId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a specific membership.
       */
      get(membershipId, options) {
        return this._client.get(`/memberships/${membershipId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    MembershipsV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "MembershipsV4PagePaginationArray");
      }
    };
  }
});

// node_modules/cloudflare/resources/origin-ca-certificates.mjs
var OriginCACertificates, OriginCACertificatesSinglePage;
var init_origin_ca_certificates = __esm({
  "node_modules/cloudflare/resources/origin-ca-certificates.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_pagination();
    OriginCACertificates = class extends APIResource {
      static {
        __name(this, "OriginCACertificates");
      }
      /**
       * Create an Origin CA certificate. Use your Origin CA Key as your User Service Key
       * when calling this endpoint ([see above](#requests)).
       */
      create(body, options) {
        return this._client.post("/certificates", { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/certificates", OriginCACertificatesSinglePage, { query, ...options });
      }
      /**
       * Revoke an existing Origin CA certificate by its serial number. Use your Origin
       * CA Key as your User Service Key when calling this endpoint
       * ([see above](#requests)).
       */
      delete(certificateId, options) {
        return this._client.delete(`/certificates/${certificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get an existing Origin CA certificate by its serial number. Use your Origin CA
       * Key as your User Service Key when calling this endpoint
       * ([see above](#requests)).
       */
      get(certificateId, options) {
        return this._client.get(`/certificates/${certificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    OriginCACertificatesSinglePage = class extends SinglePage {
      static {
        __name(this, "OriginCACertificatesSinglePage");
      }
    };
  }
});

// node_modules/cloudflare/resources/origin-post-quantum-encryption.mjs
var OriginPostQuantumEncryption;
var init_origin_post_quantum_encryption = __esm({
  "node_modules/cloudflare/resources/origin-post-quantum-encryption.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    OriginPostQuantumEncryption = class extends APIResource {
      static {
        __name(this, "OriginPostQuantumEncryption");
      }
      /**
       * Instructs Cloudflare to use Post-Quantum (PQ) key agreement algorithms when
       * connecting to your origin. Preferred instructs Cloudflare to opportunistically
       * send a Post-Quantum keyshare in the first message to the origin (for fastest
       * connections when the origin supports and prefers PQ), supported means that PQ
       * algorithms are advertised but only used when requested by the origin, and off
       * means that PQ algorithms are not advertised
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/cache/origin_post_quantum_encryption`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Instructs Cloudflare to use Post-Quantum (PQ) key agreement algorithms when
       * connecting to your origin. Preferred instructs Cloudflare to opportunistically
       * send a Post-Quantum keyshare in the first message to the origin (for fastest
       * connections when the origin supports and prefers PQ), supported means that PQ
       * algorithms are advertised but only used when requested by the origin, and off
       * means that PQ algorithms are not advertised
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/cache/origin_post_quantum_encryption`, options)._thenUnwrap((obj) => obj.result);
      }
    };
  }
});

// node_modules/cloudflare/resources/origin-tls-client-auth/settings.mjs
var Settings4;
var init_settings4 = __esm({
  "node_modules/cloudflare/resources/origin-tls-client-auth/settings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Settings4 = class extends APIResource {
      static {
        __name(this, "Settings");
      }
      /**
       * Enable or disable zone-level authenticated origin pulls. 'enabled' should be set
       * true either before/after the certificate is uploaded to see the certificate in
       * use.
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/origin_tls_client_auth/settings`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get whether zone-level authenticated origin pulls is enabled or not. It is false
       * by default.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/origin_tls_client_auth/settings`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Settings13) {
    })(Settings4 || (Settings4 = {}));
  }
});

// node_modules/cloudflare/resources/origin-tls-client-auth/hostnames/certificates.mjs
var Certificates;
var init_certificates = __esm({
  "node_modules/cloudflare/resources/origin-tls-client-auth/hostnames/certificates.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_hostnames2();
    Certificates = class extends APIResource {
      static {
        __name(this, "Certificates");
      }
      /**
       * Upload a certificate to be used for client authentication on a hostname. 10
       * hostname certificates per zone are allowed.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/origin_tls_client_auth/hostnames/certificates`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List Certificates
       */
      list(params, options) {
        const { zone_id } = params;
        return this._client.getAPIList(`/zones/${zone_id}/origin_tls_client_auth/hostnames/certificates`, AuthenticatedOriginPullsSinglePage, options);
      }
      /**
       * Delete Hostname Client Certificate
       */
      delete(certificateId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/origin_tls_client_auth/hostnames/certificates/${certificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get the certificate by ID to be used for client authentication on a hostname.
       */
      get(certificateId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/origin_tls_client_auth/hostnames/certificates/${certificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Certificates4) {
    })(Certificates || (Certificates = {}));
  }
});

// node_modules/cloudflare/resources/origin-tls-client-auth/hostnames/hostnames.mjs
var Hostnames2, AuthenticatedOriginPullsSinglePage;
var init_hostnames2 = __esm({
  "node_modules/cloudflare/resources/origin-tls-client-auth/hostnames/hostnames.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_certificates();
    init_pagination();
    Hostnames2 = class extends APIResource {
      static {
        __name(this, "Hostnames");
      }
      constructor() {
        super(...arguments);
        this.certificates = new Certificates(this._client);
      }
      /**
       * Associate a hostname to a certificate and enable, disable or invalidate the
       * association. If disabled, client certificate will not be sent to the hostname
       * even if activated at the zone level. 100 maximum associations on a single
       * certificate are allowed. Note: Use a null value for parameter _enabled_ to
       * invalidate the association.
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/origin_tls_client_auth/hostnames`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get the Hostname Status for Client Authentication
       */
      get(hostname, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/origin_tls_client_auth/hostnames/${hostname}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    AuthenticatedOriginPullsSinglePage = class extends SinglePage {
      static {
        __name(this, "AuthenticatedOriginPullsSinglePage");
      }
    };
    (function(Hostnames4) {
      Hostnames4.Certificates = Certificates;
    })(Hostnames2 || (Hostnames2 = {}));
  }
});

// node_modules/cloudflare/resources/origin-tls-client-auth/origin-tls-client-auth.mjs
var OriginTLSClientAuth, ZoneAuthenticatedOriginPullsSinglePage;
var init_origin_tls_client_auth = __esm({
  "node_modules/cloudflare/resources/origin-tls-client-auth/origin-tls-client-auth.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_settings4();
    init_hostnames2();
    init_pagination();
    OriginTLSClientAuth = class extends APIResource {
      static {
        __name(this, "OriginTLSClientAuth");
      }
      constructor() {
        super(...arguments);
        this.hostnames = new Hostnames2(this._client);
        this.settings = new Settings4(this._client);
      }
      /**
       * Upload your own certificate you want Cloudflare to use for edge-to-origin
       * communication to override the shared certificate. Please note that it is
       * important to keep only one certificate active. Also, make sure to enable
       * zone-level authenticated origin pulls by making a PUT call to settings endpoint
       * to see the uploaded certificate in use.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/origin_tls_client_auth`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List Certificates
       */
      list(params, options) {
        const { zone_id } = params;
        return this._client.getAPIList(`/zones/${zone_id}/origin_tls_client_auth`, ZoneAuthenticatedOriginPullsSinglePage, options);
      }
      /**
       * Delete Certificate
       */
      delete(certificateId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/origin_tls_client_auth/${certificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get Certificate Details
       */
      get(certificateId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/origin_tls_client_auth/${certificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ZoneAuthenticatedOriginPullsSinglePage = class extends SinglePage {
      static {
        __name(this, "ZoneAuthenticatedOriginPullsSinglePage");
      }
    };
    (function(OriginTLSClientAuth2) {
      OriginTLSClientAuth2.Hostnames = Hostnames2;
      OriginTLSClientAuth2.Settings = Settings4;
    })(OriginTLSClientAuth || (OriginTLSClientAuth = {}));
  }
});

// node_modules/cloudflare/resources/pcaps/download.mjs
var Download;
var init_download = __esm({
  "node_modules/cloudflare/resources/pcaps/download.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Download = class extends APIResource {
      static {
        __name(this, "Download");
      }
      /**
       * Download PCAP information into a file. Response is a binary PCAP file.
       */
      get(pcapId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/pcaps/${pcapId}/download`, {
          ...options,
          __binaryResponse: true
        });
      }
    };
    /* @__PURE__ */ (function(Download2) {
    })(Download || (Download = {}));
  }
});

// node_modules/cloudflare/resources/pcaps/ownership.mjs
var OwnershipResource;
var init_ownership2 = __esm({
  "node_modules/cloudflare/resources/pcaps/ownership.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    OwnershipResource = class extends APIResource {
      static {
        __name(this, "OwnershipResource");
      }
      /**
       * Adds an AWS or GCP bucket to use with full packet captures.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/pcaps/ownership`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Deletes buckets added to the packet captures API.
       */
      delete(ownershipId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/pcaps/ownership/${ownershipId}`, {
          ...options,
          headers: { Accept: "*/*", ...options?.headers }
        });
      }
      /**
       * List all buckets configured for use with PCAPs API.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/pcaps/ownership`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Validates buckets added to the packet captures API.
       */
      validate(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/pcaps/ownership/validate`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(OwnershipResource2) {
    })(OwnershipResource || (OwnershipResource = {}));
  }
});

// node_modules/cloudflare/resources/pcaps/pcaps.mjs
var PCAPs, PCAPListResponsesSinglePage;
var init_pcaps = __esm({
  "node_modules/cloudflare/resources/pcaps/pcaps.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_download();
    init_ownership2();
    init_pagination();
    PCAPs = class extends APIResource {
      static {
        __name(this, "PCAPs");
      }
      constructor() {
        super(...arguments);
        this.ownership = new OwnershipResource(this._client);
        this.download = new Download(this._client);
      }
      /**
       * Create new PCAP request for account.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/pcaps`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists all packet capture requests for an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/pcaps`, PCAPListResponsesSinglePage, options);
      }
      /**
       * Get information for a PCAP request by id.
       */
      get(pcapId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/pcaps/${pcapId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    PCAPListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "PCAPListResponsesSinglePage");
      }
    };
    (function(PCAPs2) {
      PCAPs2.OwnershipResource = OwnershipResource;
      PCAPs2.Download = Download;
    })(PCAPs || (PCAPs = {}));
  }
});

// node_modules/cloudflare/resources/page-shield/connections.mjs
var Connections, ConnectionsSinglePage;
var init_connections = __esm({
  "node_modules/cloudflare/resources/page-shield/connections.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_connections();
    init_pagination();
    Connections = class extends APIResource {
      static {
        __name(this, "Connections");
      }
      /**
       * Lists all connections detected by Page Shield.
       */
      list(params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/page_shield/connections`, ConnectionsSinglePage, {
          query,
          ...options
        });
      }
      /**
       * Fetches a connection detected by Page Shield by connection ID.
       */
      get(connectionId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/page_shield/connections/${connectionId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ConnectionsSinglePage = class extends SinglePage {
      static {
        __name(this, "ConnectionsSinglePage");
      }
    };
    (function(Connections3) {
      Connections3.ConnectionsSinglePage = ConnectionsSinglePage;
    })(Connections || (Connections = {}));
  }
});

// node_modules/cloudflare/resources/page-shield/cookies.mjs
var Cookies, CookieListResponsesSinglePage;
var init_cookies = __esm({
  "node_modules/cloudflare/resources/page-shield/cookies.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_cookies();
    init_pagination();
    Cookies = class extends APIResource {
      static {
        __name(this, "Cookies");
      }
      /**
       * Lists all cookies collected by Page Shield.
       */
      list(params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/page_shield/cookies`, CookieListResponsesSinglePage, {
          query,
          ...options
        });
      }
      /**
       * Fetches a cookie collected by Page Shield by cookie ID.
       */
      get(cookieId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/page_shield/cookies/${cookieId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    CookieListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "CookieListResponsesSinglePage");
      }
    };
    (function(Cookies2) {
      Cookies2.CookieListResponsesSinglePage = CookieListResponsesSinglePage;
    })(Cookies || (Cookies = {}));
  }
});

// node_modules/cloudflare/resources/page-shield/policies.mjs
var Policies2, PolicyListResponsesSinglePage;
var init_policies2 = __esm({
  "node_modules/cloudflare/resources/page-shield/policies.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_policies2();
    init_pagination();
    Policies2 = class extends APIResource {
      static {
        __name(this, "Policies");
      }
      /**
       * Create a Page Shield policy.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/page_shield/policies`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a Page Shield policy by ID.
       */
      update(policyId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/page_shield/policies/${policyId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists all Page Shield policies.
       */
      list(params, options) {
        const { zone_id } = params;
        return this._client.getAPIList(`/zones/${zone_id}/page_shield/policies`, PolicyListResponsesSinglePage, options);
      }
      /**
       * Delete a Page Shield policy by ID.
       */
      delete(policyId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/page_shield/policies/${policyId}`, {
          ...options,
          headers: { Accept: "*/*", ...options?.headers }
        });
      }
      /**
       * Fetches a Page Shield policy by ID.
       */
      get(policyId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/page_shield/policies/${policyId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    PolicyListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "PolicyListResponsesSinglePage");
      }
    };
    (function(Policies6) {
      Policies6.PolicyListResponsesSinglePage = PolicyListResponsesSinglePage;
    })(Policies2 || (Policies2 = {}));
  }
});

// node_modules/cloudflare/resources/page-shield/scripts.mjs
var Scripts, ScriptsSinglePage;
var init_scripts = __esm({
  "node_modules/cloudflare/resources/page-shield/scripts.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_scripts();
    init_pagination();
    Scripts = class extends APIResource {
      static {
        __name(this, "Scripts");
      }
      /**
       * Lists all scripts detected by Page Shield.
       */
      list(params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/page_shield/scripts`, ScriptsSinglePage, {
          query,
          ...options
        });
      }
      /**
       * Fetches a script detected by Page Shield by script ID.
       */
      get(scriptId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/page_shield/scripts/${scriptId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ScriptsSinglePage = class extends SinglePage {
      static {
        __name(this, "ScriptsSinglePage");
      }
    };
    (function(Scripts4) {
      Scripts4.ScriptsSinglePage = ScriptsSinglePage;
    })(Scripts || (Scripts = {}));
  }
});

// node_modules/cloudflare/resources/page-shield/page-shield.mjs
var PageShield;
var init_page_shield = __esm({
  "node_modules/cloudflare/resources/page-shield/page-shield.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_connections();
    init_cookies();
    init_policies2();
    init_scripts();
    PageShield = class extends APIResource {
      static {
        __name(this, "PageShield");
      }
      constructor() {
        super(...arguments);
        this.policies = new Policies2(this._client);
        this.connections = new Connections(this._client);
        this.scripts = new Scripts(this._client);
        this.cookies = new Cookies(this._client);
      }
      /**
       * Updates Page Shield settings.
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/page_shield`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the Page Shield settings.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/page_shield`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(PageShield2) {
      PageShield2.Policies = Policies2;
      PageShield2.PolicyListResponsesSinglePage = PolicyListResponsesSinglePage;
      PageShield2.Connections = Connections;
      PageShield2.ConnectionsSinglePage = ConnectionsSinglePage;
      PageShield2.Scripts = Scripts;
      PageShield2.ScriptsSinglePage = ScriptsSinglePage;
      PageShield2.Cookies = Cookies;
      PageShield2.CookieListResponsesSinglePage = CookieListResponsesSinglePage;
    })(PageShield || (PageShield = {}));
  }
});

// node_modules/cloudflare/resources/pagerules/settings.mjs
var Settings5;
var init_settings5 = __esm({
  "node_modules/cloudflare/resources/pagerules/settings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Settings5 = class extends APIResource {
      static {
        __name(this, "Settings");
      }
      /**
       * Returns a list of settings (and their details) that Page Rules can apply to
       * matching requests.
       */
      list(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/pagerules/settings`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Settings13) {
    })(Settings5 || (Settings5 = {}));
  }
});

// node_modules/cloudflare/resources/pagerules/pagerules.mjs
var Pagerules;
var init_pagerules = __esm({
  "node_modules/cloudflare/resources/pagerules/pagerules.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_settings5();
    Pagerules = class extends APIResource {
      static {
        __name(this, "Pagerules");
      }
      constructor() {
        super(...arguments);
        this.settings = new Settings5(this._client);
      }
      /**
       * Creates a new Page Rule.
       *
       * @deprecated The Page Rules API is deprecated in favour of the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#page-rules for full details.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/pagerules`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Replaces the configuration of an existing Page Rule. The configuration of the
       * updated Page Rule will exactly match the data passed in the API request.
       *
       * @deprecated The Page Rules API is deprecated in favour of the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#page-rules for full details.
       */
      update(pageruleId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/pagerules/${pageruleId}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches Page Rules in a zone.
       *
       * @deprecated The Page Rules API is deprecated in favour of the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#page-rules for full details.
       */
      list(params, options) {
        const { zone_id, ...query } = params;
        return this._client.get(`/zones/${zone_id}/pagerules`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Deletes an existing Page Rule.
       *
       * @deprecated The Page Rules API is deprecated in favour of the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#page-rules for full details.
       */
      delete(pageruleId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/pagerules/${pageruleId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates one or more fields of an existing Page Rule.
       *
       * @deprecated The Page Rules API is deprecated in favour of the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#page-rules for full details.
       */
      edit(pageruleId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/pagerules/${pageruleId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the details of a Page Rule.
       *
       * @deprecated The Page Rules API is deprecated in favour of the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#page-rules for full details.
       */
      get(pageruleId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/pagerules/${pageruleId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Pagerules2) {
      Pagerules2.Settings = Settings5;
    })(Pagerules || (Pagerules = {}));
  }
});

// node_modules/cloudflare/resources/pages/projects/domains.mjs
var Domains2, DomainListResponsesSinglePage;
var init_domains2 = __esm({
  "node_modules/cloudflare/resources/pages/projects/domains.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_domains2();
    init_pagination();
    Domains2 = class extends APIResource {
      static {
        __name(this, "Domains");
      }
      /**
       * Add a new domain for the Pages project.
       */
      create(projectName, params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/pages/projects/${projectName}/domains`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch a list of all domains associated with a Pages project.
       */
      list(projectName, params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/pages/projects/${projectName}/domains`, DomainListResponsesSinglePage, options);
      }
      /**
       * Delete a Pages project's domain.
       */
      delete(projectName, domainName, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/pages/projects/${projectName}/domains/${domainName}`, options);
      }
      /**
       * Retry the validation status of a single domain.
       */
      edit(projectName, domainName, params, options) {
        const { account_id, body } = params;
        return this._client.patch(`/accounts/${account_id}/pages/projects/${projectName}/domains/${domainName}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch a single domain.
       */
      get(projectName, domainName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/pages/projects/${projectName}/domains/${domainName}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    DomainListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "DomainListResponsesSinglePage");
      }
    };
    (function(Domains5) {
      Domains5.DomainListResponsesSinglePage = DomainListResponsesSinglePage;
    })(Domains2 || (Domains2 = {}));
  }
});

// node_modules/cloudflare/resources/pages/projects/deployments/history/logs.mjs
var Logs3;
var init_logs3 = __esm({
  "node_modules/cloudflare/resources/pages/projects/deployments/history/logs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Logs3 = class extends APIResource {
      static {
        __name(this, "Logs");
      }
      /**
       * Fetch deployment logs for a project.
       */
      get(projectName, deploymentId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/pages/projects/${projectName}/deployments/${deploymentId}/history/logs`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Logs5) {
    })(Logs3 || (Logs3 = {}));
  }
});

// node_modules/cloudflare/resources/pages/projects/deployments/history/history.mjs
var History;
var init_history2 = __esm({
  "node_modules/cloudflare/resources/pages/projects/deployments/history/history.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_logs3();
    History = class extends APIResource {
      static {
        __name(this, "History");
      }
      constructor() {
        super(...arguments);
        this.logs = new Logs3(this._client);
      }
    };
    (function(History3) {
      History3.Logs = Logs3;
    })(History || (History = {}));
  }
});

// node_modules/cloudflare/resources/pages/projects/deployments/deployments.mjs
var Deployments;
var init_deployments = __esm({
  "node_modules/cloudflare/resources/pages/projects/deployments/deployments.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_projects();
    init_history2();
    Deployments = class extends APIResource {
      static {
        __name(this, "Deployments");
      }
      constructor() {
        super(...arguments);
        this.history = new History(this._client);
      }
      /**
       * Start a new deployment from production. The repository and account must have
       * already been authorized on the Cloudflare Pages dashboard.
       */
      create(projectName, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/pages/projects/${projectName}/deployments`, multipartFormRequestOptions({ body, ...options }))._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch a list of project deployments.
       */
      list(projectName, params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/pages/projects/${projectName}/deployments`, DeploymentsSinglePage, { query, ...options });
      }
      /**
       * Delete a deployment.
       */
      delete(projectName, deploymentId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/pages/projects/${projectName}/deployments/${deploymentId}`, options);
      }
      /**
       * Fetch information about a deployment.
       */
      get(projectName, deploymentId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/pages/projects/${projectName}/deployments/${deploymentId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Retry a previous deployment.
       */
      retry(projectName, deploymentId, params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/pages/projects/${projectName}/deployments/${deploymentId}/retry`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Rollback the production deployment to a previous deployment. You can only
       * rollback to succesful builds on production.
       */
      rollback(projectName, deploymentId, params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/pages/projects/${projectName}/deployments/${deploymentId}/rollback`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Deployments3) {
      Deployments3.History = History;
    })(Deployments || (Deployments = {}));
  }
});

// node_modules/cloudflare/resources/pages/projects/projects.mjs
var Projects, DeploymentsSinglePage;
var init_projects = __esm({
  "node_modules/cloudflare/resources/pages/projects/projects.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_projects();
    init_domains2();
    init_deployments();
    init_pagination();
    Projects = class extends APIResource {
      static {
        __name(this, "Projects");
      }
      constructor() {
        super(...arguments);
        this.deployments = new Deployments(this._client);
        this.domains = new Domains2(this._client);
      }
      /**
       * Create a new project.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/pages/projects`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch a list of all user projects.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/pages/projects`, DeploymentsSinglePage, options);
      }
      /**
       * Delete a project by name.
       */
      delete(projectName, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/pages/projects/${projectName}`, options);
      }
      /**
       * Set new attributes for an existing project. Modify environment variables. To
       * delete an environment variable, set the key to null.
       */
      edit(projectName, params, options) {
        const { account_id, body } = params;
        return this._client.patch(`/accounts/${account_id}/pages/projects/${projectName}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch a project by name.
       */
      get(projectName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/pages/projects/${projectName}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Purge all cached build artifacts for a Pages project
       */
      purgeBuildCache(projectName, params, options) {
        const { account_id } = params;
        return this._client.post(`/accounts/${account_id}/pages/projects/${projectName}/purge_build_cache`, options);
      }
    };
    DeploymentsSinglePage = class extends SinglePage {
      static {
        __name(this, "DeploymentsSinglePage");
      }
    };
    (function(Projects2) {
      Projects2.DeploymentsSinglePage = DeploymentsSinglePage;
      Projects2.Deployments = Deployments;
      Projects2.Domains = Domains2;
      Projects2.DomainListResponsesSinglePage = DomainListResponsesSinglePage;
    })(Projects || (Projects = {}));
  }
});

// node_modules/cloudflare/resources/pages/pages.mjs
var Pages;
var init_pages = __esm({
  "node_modules/cloudflare/resources/pages/pages.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_projects();
    Pages = class extends APIResource {
      static {
        __name(this, "Pages");
      }
      constructor() {
        super(...arguments);
        this.projects = new Projects(this._client);
      }
    };
    (function(Pages3) {
      Pages3.Projects = Projects;
      Pages3.DeploymentsSinglePage = DeploymentsSinglePage;
    })(Pages || (Pages = {}));
  }
});

// node_modules/cloudflare/resources/plans.mjs
var Plans, AvailableRatePlansSinglePage;
var init_plans = __esm({
  "node_modules/cloudflare/resources/plans.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_pagination();
    Plans = class extends APIResource {
      static {
        __name(this, "Plans");
      }
      /**
       * Lists available plans the zone can subscribe to.
       */
      list(zoneIdentifier, options) {
        return this._client.getAPIList(`/zones/${zoneIdentifier}/available_plans`, AvailableRatePlansSinglePage, options);
      }
      /**
       * Details of the available plan that the zone can subscribe to.
       */
      get(zoneIdentifier, planIdentifier, options) {
        return this._client.get(`/zones/${zoneIdentifier}/available_plans/${planIdentifier}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    AvailableRatePlansSinglePage = class extends SinglePage {
      static {
        __name(this, "AvailableRatePlansSinglePage");
      }
    };
  }
});

// node_modules/cloudflare/resources/queues/consumers.mjs
var Consumers;
var init_consumers = __esm({
  "node_modules/cloudflare/resources/queues/consumers.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Consumers = class extends APIResource {
      static {
        __name(this, "Consumers");
      }
      /**
       * Creates a new consumer for a queue.
       */
      create(queueId, params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/queues/${queueId}/consumers`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates the consumer for a queue, or creates one if it does not exist.
       */
      update(queueId, consumerId, params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/queues/${queueId}/consumers/${consumerId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Deletes the consumer for a queue.
       */
      delete(queueId, consumerId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/queues/${queueId}/consumers/${consumerId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Returns the consumers for a queue.
       */
      get(queueId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/queues/${queueId}/consumers`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Consumers2) {
    })(Consumers || (Consumers = {}));
  }
});

// node_modules/cloudflare/resources/queues/messages.mjs
var Messages;
var init_messages = __esm({
  "node_modules/cloudflare/resources/queues/messages.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Messages = class extends APIResource {
      static {
        __name(this, "Messages");
      }
      /**
       * Acknowledge + Retry messages from a Queue.
       */
      ack(queueId, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/queues/${queueId}/messages/ack`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Pull a batch of messages from a Queue.
       */
      pull(queueId, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/queues/${queueId}/messages/pull`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Messages2) {
    })(Messages || (Messages = {}));
  }
});

// node_modules/cloudflare/resources/queues/queues.mjs
var Queues2, QueuesSinglePage;
var init_queues2 = __esm({
  "node_modules/cloudflare/resources/queues/queues.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_consumers();
    init_messages();
    init_pagination();
    Queues2 = class extends APIResource {
      static {
        __name(this, "Queues");
      }
      constructor() {
        super(...arguments);
        this.consumers = new Consumers(this._client);
        this.messages = new Messages(this._client);
      }
      /**
       * Creates a new queue.
       */
      create(params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/queues`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a queue.
       */
      update(queueId, params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/queues/${queueId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Returns the queues owned by an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/queues`, QueuesSinglePage, options);
      }
      /**
       * Deletes a queue.
       */
      delete(queueId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/queues/${queueId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get information about a specific queue.
       */
      get(queueId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/queues/${queueId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    QueuesSinglePage = class extends SinglePage {
      static {
        __name(this, "QueuesSinglePage");
      }
    };
    (function(Queues3) {
      Queues3.Consumers = Consumers;
      Queues3.Messages = Messages;
    })(Queues2 || (Queues2 = {}));
  }
});

// node_modules/cloudflare/resources/r2/buckets.mjs
var Buckets, BucketsCursorPagination;
var init_buckets = __esm({
  "node_modules/cloudflare/resources/r2/buckets.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_buckets();
    init_pagination();
    Buckets = class extends APIResource {
      static {
        __name(this, "Buckets");
      }
      /**
       * Creates a new R2 bucket.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/r2/buckets`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists all R2 buckets on your account
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/r2/buckets`, BucketsCursorPagination, {
          query,
          ...options
        });
      }
      /**
       * Deletes an existing R2 bucket.
       */
      delete(bucketName, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/r2/buckets/${bucketName}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Gets metadata for an existing R2 bucket.
       */
      get(bucketName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/r2/buckets/${bucketName}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    BucketsCursorPagination = class extends CursorPagination {
      static {
        __name(this, "BucketsCursorPagination");
      }
    };
    (function(Buckets2) {
      Buckets2.BucketsCursorPagination = BucketsCursorPagination;
    })(Buckets || (Buckets = {}));
  }
});

// node_modules/cloudflare/resources/r2/sippy.mjs
var SippyResource;
var init_sippy = __esm({
  "node_modules/cloudflare/resources/r2/sippy.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    SippyResource = class extends APIResource {
      static {
        __name(this, "SippyResource");
      }
      /**
       * Sets configuration for Sippy for an existing R2 bucket.
       */
      update(bucketName, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/r2/buckets/${bucketName}/sippy`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Disables Sippy on this bucket
       */
      delete(bucketName, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/r2/buckets/${bucketName}/sippy`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Gets configuration for Sippy for an existing R2 bucket.
       */
      get(bucketName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/r2/buckets/${bucketName}/sippy`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(SippyResource2) {
    })(SippyResource || (SippyResource = {}));
  }
});

// node_modules/cloudflare/resources/r2/temporary-credentials.mjs
var TemporaryCredentials;
var init_temporary_credentials = __esm({
  "node_modules/cloudflare/resources/r2/temporary-credentials.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    TemporaryCredentials = class extends APIResource {
      static {
        __name(this, "TemporaryCredentials");
      }
      /**
       * Creates temporary access credentials on a bucket that can be optionally scoped
       * to prefixes or objects.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/r2/temp-access-credentials`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(TemporaryCredentials2) {
    })(TemporaryCredentials || (TemporaryCredentials = {}));
  }
});

// node_modules/cloudflare/resources/r2/r2.mjs
var R22;
var init_r22 = __esm({
  "node_modules/cloudflare/resources/r2/r2.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_buckets();
    init_sippy();
    init_temporary_credentials();
    R22 = class extends APIResource {
      static {
        __name(this, "R2");
      }
      constructor() {
        super(...arguments);
        this.buckets = new Buckets(this._client);
        this.sippy = new SippyResource(this._client);
        this.temporaryCredentials = new TemporaryCredentials(this._client);
      }
    };
    (function(R23) {
      R23.Buckets = Buckets;
      R23.BucketsCursorPagination = BucketsCursorPagination;
      R23.SippyResource = SippyResource;
      R23.TemporaryCredentials = TemporaryCredentials;
    })(R22 || (R22 = {}));
  }
});

// node_modules/cloudflare/resources/rum/rules.mjs
var Rules6;
var init_rules6 = __esm({
  "node_modules/cloudflare/resources/rum/rules.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Rules6 = class extends APIResource {
      static {
        __name(this, "Rules");
      }
      /**
       * Creates a new rule in a Web Analytics ruleset.
       */
      create(rulesetId, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/rum/v2/${rulesetId}/rule`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a rule in a Web Analytics ruleset.
       */
      update(rulesetId, ruleId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/rum/v2/${rulesetId}/rule/${ruleId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists all the rules in a Web Analytics ruleset.
       */
      list(rulesetId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/rum/v2/${rulesetId}/rules`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Deletes an existing rule from a Web Analytics ruleset.
       */
      delete(rulesetId, ruleId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/rum/v2/${rulesetId}/rule/${ruleId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Rules12) {
    })(Rules6 || (Rules6 = {}));
  }
});

// node_modules/cloudflare/resources/rum/site-info.mjs
var SiteInfo, SitesV4PagePaginationArray;
var init_site_info = __esm({
  "node_modules/cloudflare/resources/rum/site-info.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_site_info();
    init_pagination();
    SiteInfo = class extends APIResource {
      static {
        __name(this, "SiteInfo");
      }
      /**
       * Creates a new Web Analytics site.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/rum/site_info`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an existing Web Analytics site.
       */
      update(siteId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/rum/site_info/${siteId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists all Web Analytics sites of an account.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/rum/site_info/list`, SitesV4PagePaginationArray, {
          query,
          ...options
        });
      }
      /**
       * Deletes an existing Web Analytics site.
       */
      delete(siteId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/rum/site_info/${siteId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Retrieves a Web Analytics site.
       */
      get(siteId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/rum/site_info/${siteId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    SitesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "SitesV4PagePaginationArray");
      }
    };
    (function(SiteInfo2) {
      SiteInfo2.SitesV4PagePaginationArray = SitesV4PagePaginationArray;
    })(SiteInfo || (SiteInfo = {}));
  }
});

// node_modules/cloudflare/resources/rum/rum.mjs
var RUM;
var init_rum = __esm({
  "node_modules/cloudflare/resources/rum/rum.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_rules6();
    init_site_info();
    RUM = class extends APIResource {
      static {
        __name(this, "RUM");
      }
      constructor() {
        super(...arguments);
        this.siteInfo = new SiteInfo(this._client);
        this.rules = new Rules6(this._client);
      }
    };
    (function(RUM2) {
      RUM2.SiteInfo = SiteInfo;
      RUM2.SitesV4PagePaginationArray = SitesV4PagePaginationArray;
      RUM2.Rules = Rules6;
    })(RUM || (RUM = {}));
  }
});

// node_modules/cloudflare/resources/radar/datasets.mjs
var Datasets2;
var init_datasets2 = __esm({
  "node_modules/cloudflare/resources/radar/datasets.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Datasets2 = class extends APIResource {
      static {
        __name(this, "Datasets");
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.get("/radar/datasets", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a url to download a single dataset.
       */
      download(params, options) {
        const { format, ...body } = params;
        return this._client.post("/radar/datasets/download", {
          query: { format },
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get the csv content of a given dataset by alias or id. When getting the content
       * by alias the latest dataset is returned, optionally filtered by the latest
       * available at a given date.
       */
      get(alias, options) {
        return this._client.get(`/radar/datasets/${alias}`, {
          ...options,
          headers: { Accept: "text/csv", ...options?.headers }
        });
      }
    };
    /* @__PURE__ */ (function(Datasets4) {
    })(Datasets2 || (Datasets2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/search.mjs
var Search;
var init_search = __esm({
  "node_modules/cloudflare/resources/radar/search.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Search = class extends APIResource {
      static {
        __name(this, "Search");
      }
      /**
       * Lets you search for locations, autonomous systems (AS) and reports.
       */
      global(query, options) {
        return this._client.get("/radar/search/global", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Search2) {
    })(Search || (Search = {}));
  }
});

// node_modules/cloudflare/resources/radar/tcp-resets-timeouts.mjs
var TCPResetsTimeouts;
var init_tcp_resets_timeouts = __esm({
  "node_modules/cloudflare/resources/radar/tcp-resets-timeouts.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    TCPResetsTimeouts = class extends APIResource {
      static {
        __name(this, "TCPResetsTimeouts");
      }
      summary(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.summary({}, query);
        }
        return this._client.get("/radar/tcp_resets_timeouts/summary", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      timeseriesGroups(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.timeseriesGroups({}, query);
        }
        return this._client.get("/radar/tcp_resets_timeouts/timeseries_groups", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(TCPResetsTimeouts2) {
    })(TCPResetsTimeouts || (TCPResetsTimeouts = {}));
  }
});

// node_modules/cloudflare/resources/radar/annotations/outages.mjs
var Outages;
var init_outages = __esm({
  "node_modules/cloudflare/resources/radar/annotations/outages.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Outages = class extends APIResource {
      static {
        __name(this, "Outages");
      }
      get(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get({}, query);
        }
        return this._client.get("/radar/annotations/outages", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      locations(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.locations({}, query);
        }
        return this._client.get("/radar/annotations/outages/locations", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Outages2) {
    })(Outages || (Outages = {}));
  }
});

// node_modules/cloudflare/resources/radar/annotations/annotations.mjs
var Annotations;
var init_annotations = __esm({
  "node_modules/cloudflare/resources/radar/annotations/annotations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_outages();
    Annotations = class extends APIResource {
      static {
        __name(this, "Annotations");
      }
      constructor() {
        super(...arguments);
        this.outages = new Outages(this._client);
      }
    };
    (function(Annotations2) {
      Annotations2.Outages = Outages;
    })(Annotations || (Annotations = {}));
  }
});

// node_modules/cloudflare/resources/radar/as112/summary.mjs
var Summary;
var init_summary = __esm({
  "node_modules/cloudflare/resources/radar/as112/summary.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Summary = class extends APIResource {
      static {
        __name(this, "Summary");
      }
      dnssec(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.dnssec({}, query);
        }
        return this._client.get("/radar/as112/summary/dnssec", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      edns(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.edns({}, query);
        }
        return this._client.get("/radar/as112/summary/edns", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      ipVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.ipVersion({}, query);
        }
        return this._client.get("/radar/as112/summary/ip_version", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      protocol(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.protocol({}, query);
        }
        return this._client.get("/radar/as112/summary/protocol", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      queryType(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.queryType({}, query);
        }
        return this._client.get("/radar/as112/summary/query_type", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      responseCodes(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.responseCodes({}, query);
        }
        return this._client.get("/radar/as112/summary/response_codes", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Summary8) {
    })(Summary || (Summary = {}));
  }
});

// node_modules/cloudflare/resources/radar/as112/timeseries-groups.mjs
var TimeseriesGroups;
var init_timeseries_groups = __esm({
  "node_modules/cloudflare/resources/radar/as112/timeseries-groups.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    TimeseriesGroups = class extends APIResource {
      static {
        __name(this, "TimeseriesGroups");
      }
      dnssec(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.dnssec({}, query);
        }
        return this._client.get("/radar/as112/timeseries_groups/dnssec", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      edns(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.edns({}, query);
        }
        return this._client.get("/radar/as112/timeseries_groups/edns", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      ipVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.ipVersion({}, query);
        }
        return this._client.get("/radar/as112/timeseries_groups/ip_version", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      protocol(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.protocol({}, query);
        }
        return this._client.get("/radar/as112/timeseries_groups/protocol", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      queryType(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.queryType({}, query);
        }
        return this._client.get("/radar/as112/timeseries_groups/query_type", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      responseCodes(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.responseCodes({}, query);
        }
        return this._client.get("/radar/as112/timeseries_groups/response_codes", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(TimeseriesGroups7) {
    })(TimeseriesGroups || (TimeseriesGroups = {}));
  }
});

// node_modules/cloudflare/resources/radar/as112/top.mjs
var Top;
var init_top = __esm({
  "node_modules/cloudflare/resources/radar/as112/top.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Top = class extends APIResource {
      static {
        __name(this, "Top");
      }
      dnssec(dnssec, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.dnssec(dnssec, {}, query);
        }
        return this._client.get(`/radar/as112/top/locations/dnssec/${dnssec}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      edns(edns, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.edns(edns, {}, query);
        }
        return this._client.get(`/radar/as112/top/locations/edns/${edns}`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      ipVersion(ipVersion, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.ipVersion(ipVersion, {}, query);
        }
        return this._client.get(`/radar/as112/top/locations/ip_version/${ipVersion}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      locations(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.locations({}, query);
        }
        return this._client.get("/radar/as112/top/locations", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Top11) {
    })(Top || (Top = {}));
  }
});

// node_modules/cloudflare/resources/radar/as112/as112.mjs
var AS112;
var init_as112 = __esm({
  "node_modules/cloudflare/resources/radar/as112/as112.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_summary();
    init_timeseries_groups();
    init_top();
    AS112 = class extends APIResource {
      static {
        __name(this, "AS112");
      }
      constructor() {
        super(...arguments);
        this.summary = new Summary(this._client);
        this.timeseriesGroups = new TimeseriesGroups(this._client);
        this.top = new Top(this._client);
      }
      timeseries(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.timeseries({}, query);
        }
        return this._client.get("/radar/as112/timeseries", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(AS1122) {
      AS1122.Summary = Summary;
      AS1122.TimeseriesGroups = TimeseriesGroups;
      AS1122.Top = Top;
    })(AS112 || (AS112 = {}));
  }
});

// node_modules/cloudflare/resources/radar/attacks/layer3/summary.mjs
var Summary2;
var init_summary2 = __esm({
  "node_modules/cloudflare/resources/radar/attacks/layer3/summary.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Summary2 = class extends APIResource {
      static {
        __name(this, "Summary");
      }
      bitrate(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.bitrate({}, query);
        }
        return this._client.get("/radar/attacks/layer3/summary/bitrate", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      duration(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.duration({}, query);
        }
        return this._client.get("/radar/attacks/layer3/summary/duration", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      get(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get({}, query);
        }
        return this._client.get("/radar/attacks/layer3/summary", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      ipVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.ipVersion({}, query);
        }
        return this._client.get("/radar/attacks/layer3/summary/ip_version", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      protocol(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.protocol({}, query);
        }
        return this._client.get("/radar/attacks/layer3/summary/protocol", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      vector(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.vector({}, query);
        }
        return this._client.get("/radar/attacks/layer3/summary/vector", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Summary8) {
    })(Summary2 || (Summary2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/attacks/layer3/timeseries-groups.mjs
var TimeseriesGroups2;
var init_timeseries_groups2 = __esm({
  "node_modules/cloudflare/resources/radar/attacks/layer3/timeseries-groups.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    TimeseriesGroups2 = class extends APIResource {
      static {
        __name(this, "TimeseriesGroups");
      }
      bitrate(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.bitrate({}, query);
        }
        return this._client.get("/radar/attacks/layer3/timeseries_groups/bitrate", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      duration(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.duration({}, query);
        }
        return this._client.get("/radar/attacks/layer3/timeseries_groups/duration", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      get(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get({}, query);
        }
        return this._client.get("/radar/attacks/layer3/timeseries_groups", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      industry(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.industry({}, query);
        }
        return this._client.get("/radar/attacks/layer3/timeseries_groups/industry", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      ipVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.ipVersion({}, query);
        }
        return this._client.get("/radar/attacks/layer3/timeseries_groups/ip_version", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      protocol(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.protocol({}, query);
        }
        return this._client.get("/radar/attacks/layer3/timeseries_groups/protocol", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      vector(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.vector({}, query);
        }
        return this._client.get("/radar/attacks/layer3/timeseries_groups/vector", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      vertical(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.vertical({}, query);
        }
        return this._client.get("/radar/attacks/layer3/timeseries_groups/vertical", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(TimeseriesGroups7) {
    })(TimeseriesGroups2 || (TimeseriesGroups2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/attacks/layer3/top/locations.mjs
var Locations;
var init_locations = __esm({
  "node_modules/cloudflare/resources/radar/attacks/layer3/top/locations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Locations = class extends APIResource {
      static {
        __name(this, "Locations");
      }
      origin(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.origin({}, query);
        }
        return this._client.get("/radar/attacks/layer3/top/locations/origin", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      target(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.target({}, query);
        }
        return this._client.get("/radar/attacks/layer3/top/locations/target", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Locations7) {
    })(Locations || (Locations = {}));
  }
});

// node_modules/cloudflare/resources/radar/attacks/layer3/top/top.mjs
var Top2;
var init_top2 = __esm({
  "node_modules/cloudflare/resources/radar/attacks/layer3/top/top.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_locations();
    Top2 = class extends APIResource {
      static {
        __name(this, "Top");
      }
      constructor() {
        super(...arguments);
        this.locations = new Locations(this._client);
      }
      attacks(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.attacks({}, query);
        }
        return this._client.get("/radar/attacks/layer3/top/attacks", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      industry(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.industry({}, query);
        }
        return this._client.get("/radar/attacks/layer3/top/industry", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      vertical(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.vertical({}, query);
        }
        return this._client.get("/radar/attacks/layer3/top/vertical", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Top11) {
      Top11.Locations = Locations;
    })(Top2 || (Top2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/attacks/layer3/layer3.mjs
var Layer3;
var init_layer3 = __esm({
  "node_modules/cloudflare/resources/radar/attacks/layer3/layer3.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_summary2();
    init_timeseries_groups2();
    init_top2();
    Layer3 = class extends APIResource {
      static {
        __name(this, "Layer3");
      }
      constructor() {
        super(...arguments);
        this.summary = new Summary2(this._client);
        this.timeseriesGroups = new TimeseriesGroups2(this._client);
        this.top = new Top2(this._client);
      }
      timeseries(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.timeseries({}, query);
        }
        return this._client.get("/radar/attacks/layer3/timeseries", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Layer32) {
      Layer32.Summary = Summary2;
      Layer32.TimeseriesGroups = TimeseriesGroups2;
      Layer32.Top = Top2;
    })(Layer3 || (Layer3 = {}));
  }
});

// node_modules/cloudflare/resources/radar/attacks/layer7/summary.mjs
var Summary3;
var init_summary3 = __esm({
  "node_modules/cloudflare/resources/radar/attacks/layer7/summary.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Summary3 = class extends APIResource {
      static {
        __name(this, "Summary");
      }
      get(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get({}, query);
        }
        return this._client.get("/radar/attacks/layer7/summary", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      httpMethod(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.httpMethod({}, query);
        }
        return this._client.get("/radar/attacks/layer7/summary/http_method", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      httpVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.httpVersion({}, query);
        }
        return this._client.get("/radar/attacks/layer7/summary/http_version", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      ipVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.ipVersion({}, query);
        }
        return this._client.get("/radar/attacks/layer7/summary/ip_version", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      managedRules(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.managedRules({}, query);
        }
        return this._client.get("/radar/attacks/layer7/summary/managed_rules", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      mitigationProduct(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.mitigationProduct({}, query);
        }
        return this._client.get("/radar/attacks/layer7/summary/mitigation_product", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Summary8) {
    })(Summary3 || (Summary3 = {}));
  }
});

// node_modules/cloudflare/resources/radar/attacks/layer7/timeseries-groups.mjs
var TimeseriesGroups3;
var init_timeseries_groups3 = __esm({
  "node_modules/cloudflare/resources/radar/attacks/layer7/timeseries-groups.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    TimeseriesGroups3 = class extends APIResource {
      static {
        __name(this, "TimeseriesGroups");
      }
      get(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get({}, query);
        }
        return this._client.get("/radar/attacks/layer7/timeseries_groups", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      httpMethod(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.httpMethod({}, query);
        }
        return this._client.get("/radar/attacks/layer7/timeseries_groups/http_method", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      httpVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.httpVersion({}, query);
        }
        return this._client.get("/radar/attacks/layer7/timeseries_groups/http_version", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      industry(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.industry({}, query);
        }
        return this._client.get("/radar/attacks/layer7/timeseries_groups/industry", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      ipVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.ipVersion({}, query);
        }
        return this._client.get("/radar/attacks/layer7/timeseries_groups/ip_version", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      managedRules(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.managedRules({}, query);
        }
        return this._client.get("/radar/attacks/layer7/timeseries_groups/managed_rules", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      mitigationProduct(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.mitigationProduct({}, query);
        }
        return this._client.get("/radar/attacks/layer7/timeseries_groups/mitigation_product", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      vertical(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.vertical({}, query);
        }
        return this._client.get("/radar/attacks/layer7/timeseries_groups/vertical", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(TimeseriesGroups7) {
    })(TimeseriesGroups3 || (TimeseriesGroups3 = {}));
  }
});

// node_modules/cloudflare/resources/radar/attacks/layer7/top/ases.mjs
var Ases;
var init_ases = __esm({
  "node_modules/cloudflare/resources/radar/attacks/layer7/top/ases.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Ases = class extends APIResource {
      static {
        __name(this, "Ases");
      }
      origin(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.origin({}, query);
        }
        return this._client.get("/radar/attacks/layer7/top/ases/origin", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Ases4) {
    })(Ases || (Ases = {}));
  }
});

// node_modules/cloudflare/resources/radar/attacks/layer7/top/locations.mjs
var Locations2;
var init_locations2 = __esm({
  "node_modules/cloudflare/resources/radar/attacks/layer7/top/locations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Locations2 = class extends APIResource {
      static {
        __name(this, "Locations");
      }
      origin(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.origin({}, query);
        }
        return this._client.get("/radar/attacks/layer7/top/locations/origin", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      target(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.target({}, query);
        }
        return this._client.get("/radar/attacks/layer7/top/locations/target", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Locations7) {
    })(Locations2 || (Locations2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/attacks/layer7/top/top.mjs
var Top3;
var init_top3 = __esm({
  "node_modules/cloudflare/resources/radar/attacks/layer7/top/top.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_ases();
    init_locations2();
    Top3 = class extends APIResource {
      static {
        __name(this, "Top");
      }
      constructor() {
        super(...arguments);
        this.locations = new Locations2(this._client);
        this.ases = new Ases(this._client);
      }
      attacks(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.attacks({}, query);
        }
        return this._client.get("/radar/attacks/layer7/top/attacks", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      industry(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.industry({}, query);
        }
        return this._client.get("/radar/attacks/layer7/top/industry", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      vertical(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.vertical({}, query);
        }
        return this._client.get("/radar/attacks/layer7/top/vertical", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Top11) {
      Top11.Locations = Locations2;
      Top11.Ases = Ases;
    })(Top3 || (Top3 = {}));
  }
});

// node_modules/cloudflare/resources/radar/attacks/layer7/layer7.mjs
var Layer7;
var init_layer7 = __esm({
  "node_modules/cloudflare/resources/radar/attacks/layer7/layer7.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_summary3();
    init_timeseries_groups3();
    init_top3();
    Layer7 = class extends APIResource {
      static {
        __name(this, "Layer7");
      }
      constructor() {
        super(...arguments);
        this.summary = new Summary3(this._client);
        this.timeseriesGroups = new TimeseriesGroups3(this._client);
        this.top = new Top3(this._client);
      }
      timeseries(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.timeseries({}, query);
        }
        return this._client.get("/radar/attacks/layer7/timeseries", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Layer72) {
      Layer72.Summary = Summary3;
      Layer72.TimeseriesGroups = TimeseriesGroups3;
      Layer72.Top = Top3;
    })(Layer7 || (Layer7 = {}));
  }
});

// node_modules/cloudflare/resources/radar/attacks/attacks.mjs
var Attacks;
var init_attacks = __esm({
  "node_modules/cloudflare/resources/radar/attacks/attacks.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_layer3();
    init_layer7();
    Attacks = class extends APIResource {
      static {
        __name(this, "Attacks");
      }
      constructor() {
        super(...arguments);
        this.layer3 = new Layer3(this._client);
        this.layer7 = new Layer7(this._client);
      }
    };
    (function(Attacks2) {
      Attacks2.Layer3 = Layer3;
      Attacks2.Layer7 = Layer7;
    })(Attacks || (Attacks = {}));
  }
});

// node_modules/cloudflare/resources/radar/bgp/ips.mjs
var IPs4;
var init_ips4 = __esm({
  "node_modules/cloudflare/resources/radar/bgp/ips.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    IPs4 = class extends APIResource {
      static {
        __name(this, "IPs");
      }
      timeseries(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.timeseries({}, query);
        }
        return this._client.get("/radar/bgp/ips/timeseries", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(IPs6) {
    })(IPs4 || (IPs4 = {}));
  }
});

// node_modules/cloudflare/resources/radar/bgp/routes.mjs
var Routes2;
var init_routes2 = __esm({
  "node_modules/cloudflare/resources/radar/bgp/routes.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Routes2 = class extends APIResource {
      static {
        __name(this, "Routes");
      }
      ases(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.ases({}, query);
        }
        return this._client.get("/radar/bgp/routes/ases", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      moas(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.moas({}, query);
        }
        return this._client.get("/radar/bgp/routes/moas", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      pfx2as(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.pfx2as({}, query);
        }
        return this._client.get("/radar/bgp/routes/pfx2as", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      stats(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.stats({}, query);
        }
        return this._client.get("/radar/bgp/routes/stats", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Routes4) {
    })(Routes2 || (Routes2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/bgp/hijacks/events.mjs
var Events, EventListResponsesV4PagePagination;
var init_events = __esm({
  "node_modules/cloudflare/resources/radar/bgp/hijacks/events.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_events();
    init_pagination();
    Events = class extends APIResource {
      static {
        __name(this, "Events");
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/radar/bgp/hijacks/events", EventListResponsesV4PagePagination, {
          query,
          ...options
        });
      }
    };
    EventListResponsesV4PagePagination = class extends V4PagePagination {
      static {
        __name(this, "EventListResponsesV4PagePagination");
      }
    };
    (function(Events5) {
      Events5.EventListResponsesV4PagePagination = EventListResponsesV4PagePagination;
    })(Events || (Events = {}));
  }
});

// node_modules/cloudflare/resources/radar/bgp/hijacks/hijacks.mjs
var Hijacks;
var init_hijacks = __esm({
  "node_modules/cloudflare/resources/radar/bgp/hijacks/hijacks.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_events();
    Hijacks = class extends APIResource {
      static {
        __name(this, "Hijacks");
      }
      constructor() {
        super(...arguments);
        this.events = new Events(this._client);
      }
    };
    (function(Hijacks2) {
      Hijacks2.Events = Events;
      Hijacks2.EventListResponsesV4PagePagination = EventListResponsesV4PagePagination;
    })(Hijacks || (Hijacks = {}));
  }
});

// node_modules/cloudflare/resources/radar/bgp/leaks/events.mjs
var Events2, EventListResponsesV4PagePagination2;
var init_events2 = __esm({
  "node_modules/cloudflare/resources/radar/bgp/leaks/events.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_events2();
    init_pagination();
    Events2 = class extends APIResource {
      static {
        __name(this, "Events");
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/radar/bgp/leaks/events", EventListResponsesV4PagePagination2, {
          query,
          ...options
        });
      }
    };
    EventListResponsesV4PagePagination2 = class extends V4PagePagination {
      static {
        __name(this, "EventListResponsesV4PagePagination");
      }
    };
    (function(Events5) {
      Events5.EventListResponsesV4PagePagination = EventListResponsesV4PagePagination2;
    })(Events2 || (Events2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/bgp/leaks/leaks.mjs
var Leaks;
var init_leaks = __esm({
  "node_modules/cloudflare/resources/radar/bgp/leaks/leaks.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_events2();
    Leaks = class extends APIResource {
      static {
        __name(this, "Leaks");
      }
      constructor() {
        super(...arguments);
        this.events = new Events2(this._client);
      }
    };
    (function(Leaks2) {
      Leaks2.Events = Events2;
      Leaks2.EventListResponsesV4PagePagination = EventListResponsesV4PagePagination2;
    })(Leaks || (Leaks = {}));
  }
});

// node_modules/cloudflare/resources/radar/bgp/top/ases.mjs
var Ases2;
var init_ases2 = __esm({
  "node_modules/cloudflare/resources/radar/bgp/top/ases.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Ases2 = class extends APIResource {
      static {
        __name(this, "Ases");
      }
      get(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get({}, query);
        }
        return this._client.get("/radar/bgp/top/ases", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      prefixes(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.prefixes({}, query);
        }
        return this._client.get("/radar/bgp/top/ases/prefixes", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Ases4) {
    })(Ases2 || (Ases2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/bgp/top/top.mjs
var Top4;
var init_top4 = __esm({
  "node_modules/cloudflare/resources/radar/bgp/top/top.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_ases2();
    Top4 = class extends APIResource {
      static {
        __name(this, "Top");
      }
      constructor() {
        super(...arguments);
        this.ases = new Ases2(this._client);
      }
      prefixes(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.prefixes({}, query);
        }
        return this._client.get("/radar/bgp/top/prefixes", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Top11) {
      Top11.Ases = Ases2;
    })(Top4 || (Top4 = {}));
  }
});

// node_modules/cloudflare/resources/radar/bgp/bgp.mjs
var BGP2;
var init_bgp2 = __esm({
  "node_modules/cloudflare/resources/radar/bgp/bgp.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_ips4();
    init_routes2();
    init_hijacks();
    init_leaks();
    init_top4();
    BGP2 = class extends APIResource {
      static {
        __name(this, "BGP");
      }
      constructor() {
        super(...arguments);
        this.leaks = new Leaks(this._client);
        this.top = new Top4(this._client);
        this.hijacks = new Hijacks(this._client);
        this.routes = new Routes2(this._client);
        this.ips = new IPs4(this._client);
      }
      timeseries(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.timeseries({}, query);
        }
        return this._client.get("/radar/bgp/timeseries", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(BGP3) {
      BGP3.Leaks = Leaks;
      BGP3.Top = Top4;
      BGP3.Hijacks = Hijacks;
      BGP3.Routes = Routes2;
      BGP3.IPs = IPs4;
    })(BGP2 || (BGP2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/dns/top.mjs
var Top5;
var init_top5 = __esm({
  "node_modules/cloudflare/resources/radar/dns/top.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Top5 = class extends APIResource {
      static {
        __name(this, "Top");
      }
      /**
       * Get top autonomous systems by DNS queries made to Cloudflare's public DNS
       * resolver.
       */
      ases(query, options) {
        return this._client.get("/radar/dns/top/ases", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get top locations by DNS queries made to Cloudflare's public DNS resolver.
       */
      locations(query, options) {
        return this._client.get("/radar/dns/top/locations", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Top11) {
    })(Top5 || (Top5 = {}));
  }
});

// node_modules/cloudflare/resources/radar/dns/dns.mjs
var DNS4;
var init_dns4 = __esm({
  "node_modules/cloudflare/resources/radar/dns/dns.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_top5();
    DNS4 = class extends APIResource {
      static {
        __name(this, "DNS");
      }
      constructor() {
        super(...arguments);
        this.top = new Top5(this._client);
      }
    };
    (function(DNS5) {
      DNS5.Top = Top5;
    })(DNS4 || (DNS4 = {}));
  }
});

// node_modules/cloudflare/resources/radar/email/routing/summary.mjs
var Summary4;
var init_summary4 = __esm({
  "node_modules/cloudflare/resources/radar/email/routing/summary.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Summary4 = class extends APIResource {
      static {
        __name(this, "Summary");
      }
      arc(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.arc({}, query);
        }
        return this._client.get("/radar/email/routing/summary/arc", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      dkim(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.dkim({}, query);
        }
        return this._client.get("/radar/email/routing/summary/dkim", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      dmarc(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.dmarc({}, query);
        }
        return this._client.get("/radar/email/routing/summary/dmarc", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      encrypted(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.encrypted({}, query);
        }
        return this._client.get("/radar/email/routing/summary/encrypted", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      ipVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.ipVersion({}, query);
        }
        return this._client.get("/radar/email/routing/summary/ip_version", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      spf(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.spf({}, query);
        }
        return this._client.get("/radar/email/routing/summary/spf", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Summary8) {
    })(Summary4 || (Summary4 = {}));
  }
});

// node_modules/cloudflare/resources/radar/email/routing/timeseries-groups.mjs
var TimeseriesGroups4;
var init_timeseries_groups4 = __esm({
  "node_modules/cloudflare/resources/radar/email/routing/timeseries-groups.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    TimeseriesGroups4 = class extends APIResource {
      static {
        __name(this, "TimeseriesGroups");
      }
      arc(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.arc({}, query);
        }
        return this._client.get("/radar/email/routing/timeseries_groups/arc", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      dkim(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.dkim({}, query);
        }
        return this._client.get("/radar/email/routing/timeseries_groups/dkim", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      dmarc(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.dmarc({}, query);
        }
        return this._client.get("/radar/email/routing/timeseries_groups/dmarc", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      encrypted(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.encrypted({}, query);
        }
        return this._client.get("/radar/email/routing/timeseries_groups/encrypted", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      ipVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.ipVersion({}, query);
        }
        return this._client.get("/radar/email/routing/timeseries_groups/ip_version", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      spf(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.spf({}, query);
        }
        return this._client.get("/radar/email/routing/timeseries_groups/spf", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(TimeseriesGroups7) {
    })(TimeseriesGroups4 || (TimeseriesGroups4 = {}));
  }
});

// node_modules/cloudflare/resources/radar/email/routing/routing.mjs
var Routing;
var init_routing = __esm({
  "node_modules/cloudflare/resources/radar/email/routing/routing.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_summary4();
    init_timeseries_groups4();
    Routing = class extends APIResource {
      static {
        __name(this, "Routing");
      }
      constructor() {
        super(...arguments);
        this.summary = new Summary4(this._client);
        this.timeseriesGroups = new TimeseriesGroups4(this._client);
      }
    };
    (function(Routing2) {
      Routing2.Summary = Summary4;
      Routing2.TimeseriesGroups = TimeseriesGroups4;
    })(Routing || (Routing = {}));
  }
});

// node_modules/cloudflare/resources/radar/email/security/summary.mjs
var Summary5;
var init_summary5 = __esm({
  "node_modules/cloudflare/resources/radar/email/security/summary.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Summary5 = class extends APIResource {
      static {
        __name(this, "Summary");
      }
      arc(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.arc({}, query);
        }
        return this._client.get("/radar/email/security/summary/arc", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      dkim(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.dkim({}, query);
        }
        return this._client.get("/radar/email/security/summary/dkim", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      dmarc(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.dmarc({}, query);
        }
        return this._client.get("/radar/email/security/summary/dmarc", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      malicious(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.malicious({}, query);
        }
        return this._client.get("/radar/email/security/summary/malicious", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      spam(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.spam({}, query);
        }
        return this._client.get("/radar/email/security/summary/spam", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      spf(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.spf({}, query);
        }
        return this._client.get("/radar/email/security/summary/spf", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      spoof(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.spoof({}, query);
        }
        return this._client.get("/radar/email/security/summary/spoof", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      threatCategory(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.threatCategory({}, query);
        }
        return this._client.get("/radar/email/security/summary/threat_category", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      tlsVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.tlsVersion({}, query);
        }
        return this._client.get("/radar/email/security/summary/tls_version", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Summary8) {
    })(Summary5 || (Summary5 = {}));
  }
});

// node_modules/cloudflare/resources/radar/email/security/timeseries-groups.mjs
var TimeseriesGroups5;
var init_timeseries_groups5 = __esm({
  "node_modules/cloudflare/resources/radar/email/security/timeseries-groups.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    TimeseriesGroups5 = class extends APIResource {
      static {
        __name(this, "TimeseriesGroups");
      }
      arc(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.arc({}, query);
        }
        return this._client.get("/radar/email/security/timeseries_groups/arc", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      dkim(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.dkim({}, query);
        }
        return this._client.get("/radar/email/security/timeseries_groups/dkim", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      dmarc(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.dmarc({}, query);
        }
        return this._client.get("/radar/email/security/timeseries_groups/dmarc", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      malicious(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.malicious({}, query);
        }
        return this._client.get("/radar/email/security/timeseries_groups/malicious", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      spam(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.spam({}, query);
        }
        return this._client.get("/radar/email/security/timeseries_groups/spam", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      spf(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.spf({}, query);
        }
        return this._client.get("/radar/email/security/timeseries_groups/spf", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      spoof(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.spoof({}, query);
        }
        return this._client.get("/radar/email/security/timeseries_groups/spoof", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      threatCategory(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.threatCategory({}, query);
        }
        return this._client.get("/radar/email/security/timeseries_groups/threat_category", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      tlsVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.tlsVersion({}, query);
        }
        return this._client.get("/radar/email/security/timeseries_groups/tls_version", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(TimeseriesGroups7) {
    })(TimeseriesGroups5 || (TimeseriesGroups5 = {}));
  }
});

// node_modules/cloudflare/resources/radar/email/security/top/tlds/malicious.mjs
var Malicious;
var init_malicious = __esm({
  "node_modules/cloudflare/resources/radar/email/security/top/tlds/malicious.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Malicious = class extends APIResource {
      static {
        __name(this, "Malicious");
      }
      get(malicious, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(malicious, {}, query);
        }
        return this._client.get(`/radar/email/security/top/tlds/malicious/${malicious}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Malicious2) {
    })(Malicious || (Malicious = {}));
  }
});

// node_modules/cloudflare/resources/radar/email/security/top/tlds/spam.mjs
var Spam;
var init_spam = __esm({
  "node_modules/cloudflare/resources/radar/email/security/top/tlds/spam.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Spam = class extends APIResource {
      static {
        __name(this, "Spam");
      }
      get(spam, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(spam, {}, query);
        }
        return this._client.get(`/radar/email/security/top/tlds/spam/${spam}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Spam2) {
    })(Spam || (Spam = {}));
  }
});

// node_modules/cloudflare/resources/radar/email/security/top/tlds/spoof.mjs
var Spoof;
var init_spoof = __esm({
  "node_modules/cloudflare/resources/radar/email/security/top/tlds/spoof.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Spoof = class extends APIResource {
      static {
        __name(this, "Spoof");
      }
      get(spoof, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(spoof, {}, query);
        }
        return this._client.get(`/radar/email/security/top/tlds/spoof/${spoof}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Spoof2) {
    })(Spoof || (Spoof = {}));
  }
});

// node_modules/cloudflare/resources/radar/email/security/top/tlds/tlds.mjs
var Tlds;
var init_tlds = __esm({
  "node_modules/cloudflare/resources/radar/email/security/top/tlds/tlds.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_malicious();
    init_spam();
    init_spoof();
    Tlds = class extends APIResource {
      static {
        __name(this, "Tlds");
      }
      constructor() {
        super(...arguments);
        this.malicious = new Malicious(this._client);
        this.spam = new Spam(this._client);
        this.spoof = new Spoof(this._client);
      }
      get(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get({}, query);
        }
        return this._client.get("/radar/email/security/top/tlds", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Tlds2) {
      Tlds2.Malicious = Malicious;
      Tlds2.Spam = Spam;
      Tlds2.Spoof = Spoof;
    })(Tlds || (Tlds = {}));
  }
});

// node_modules/cloudflare/resources/radar/email/security/top/top.mjs
var Top6;
var init_top6 = __esm({
  "node_modules/cloudflare/resources/radar/email/security/top/top.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_tlds();
    Top6 = class extends APIResource {
      static {
        __name(this, "Top");
      }
      constructor() {
        super(...arguments);
        this.tlds = new Tlds(this._client);
      }
    };
    (function(Top11) {
      Top11.Tlds = Tlds;
    })(Top6 || (Top6 = {}));
  }
});

// node_modules/cloudflare/resources/radar/email/security/security.mjs
var Security;
var init_security = __esm({
  "node_modules/cloudflare/resources/radar/email/security/security.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_summary5();
    init_timeseries_groups5();
    init_top6();
    Security = class extends APIResource {
      static {
        __name(this, "Security");
      }
      constructor() {
        super(...arguments);
        this.top = new Top6(this._client);
        this.summary = new Summary5(this._client);
        this.timeseriesGroups = new TimeseriesGroups5(this._client);
      }
    };
    (function(Security2) {
      Security2.Top = Top6;
      Security2.Summary = Summary5;
      Security2.TimeseriesGroups = TimeseriesGroups5;
    })(Security || (Security = {}));
  }
});

// node_modules/cloudflare/resources/radar/email/email.mjs
var Email;
var init_email = __esm({
  "node_modules/cloudflare/resources/radar/email/email.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_routing();
    init_security();
    Email = class extends APIResource {
      static {
        __name(this, "Email");
      }
      constructor() {
        super(...arguments);
        this.routing = new Routing(this._client);
        this.security = new Security(this._client);
      }
    };
    (function(Email2) {
      Email2.Routing = Routing;
      Email2.Security = Security;
    })(Email || (Email = {}));
  }
});

// node_modules/cloudflare/resources/radar/entities/asns.mjs
var ASNs;
var init_asns = __esm({
  "node_modules/cloudflare/resources/radar/entities/asns.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    ASNs = class extends APIResource {
      static {
        __name(this, "ASNs");
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.get("/radar/entities/asns", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      get(asn, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(asn, {}, query);
        }
        return this._client.get(`/radar/entities/asns/${asn}`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get the requested autonomous system information based on IP address. Population
       * estimates come from APNIC (refer to https://labs.apnic.net/?p=526).
       */
      ip(query, options) {
        return this._client.get("/radar/entities/asns/ip", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      rel(asn, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.rel(asn, {}, query);
        }
        return this._client.get(`/radar/entities/asns/${asn}/rel`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(ASNs2) {
    })(ASNs || (ASNs = {}));
  }
});

// node_modules/cloudflare/resources/radar/entities/locations.mjs
var Locations3;
var init_locations3 = __esm({
  "node_modules/cloudflare/resources/radar/entities/locations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Locations3 = class extends APIResource {
      static {
        __name(this, "Locations");
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.get("/radar/entities/locations", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      get(location, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(location, {}, query);
        }
        return this._client.get(`/radar/entities/locations/${location}`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Locations7) {
    })(Locations3 || (Locations3 = {}));
  }
});

// node_modules/cloudflare/resources/radar/entities/entities.mjs
var Entities;
var init_entities = __esm({
  "node_modules/cloudflare/resources/radar/entities/entities.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_asns();
    init_locations3();
    Entities = class extends APIResource {
      static {
        __name(this, "Entities");
      }
      constructor() {
        super(...arguments);
        this.asns = new ASNs(this._client);
        this.locations = new Locations3(this._client);
      }
      /**
       * Get IP address information.
       */
      get(query, options) {
        return this._client.get("/radar/entities/ip", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Entities2) {
      Entities2.ASNs = ASNs;
      Entities2.Locations = Locations3;
    })(Entities || (Entities = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/summary.mjs
var Summary6;
var init_summary6 = __esm({
  "node_modules/cloudflare/resources/radar/http/summary.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Summary6 = class extends APIResource {
      static {
        __name(this, "Summary");
      }
      botClass(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.botClass({}, query);
        }
        return this._client.get("/radar/http/summary/bot_class", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      deviceType(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.deviceType({}, query);
        }
        return this._client.get("/radar/http/summary/device_type", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      httpProtocol(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.httpProtocol({}, query);
        }
        return this._client.get("/radar/http/summary/http_protocol", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      httpVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.httpVersion({}, query);
        }
        return this._client.get("/radar/http/summary/http_version", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      ipVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.ipVersion({}, query);
        }
        return this._client.get("/radar/http/summary/ip_version", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      os(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.os({}, query);
        }
        return this._client.get("/radar/http/summary/os", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      postQuantum(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.postQuantum({}, query);
        }
        return this._client.get("/radar/http/summary/post_quantum", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      tlsVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.tlsVersion({}, query);
        }
        return this._client.get("/radar/http/summary/tls_version", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Summary8) {
    })(Summary6 || (Summary6 = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/timeseries-groups.mjs
var TimeseriesGroups6;
var init_timeseries_groups6 = __esm({
  "node_modules/cloudflare/resources/radar/http/timeseries-groups.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    TimeseriesGroups6 = class extends APIResource {
      static {
        __name(this, "TimeseriesGroups");
      }
      botClass(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.botClass({}, query);
        }
        return this._client.get("/radar/http/timeseries_groups/bot_class", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      browser(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.browser({}, query);
        }
        return this._client.get("/radar/http/timeseries_groups/browser", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      browserFamily(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.browserFamily({}, query);
        }
        return this._client.get("/radar/http/timeseries_groups/browser_family", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      deviceType(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.deviceType({}, query);
        }
        return this._client.get("/radar/http/timeseries_groups/device_type", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      httpProtocol(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.httpProtocol({}, query);
        }
        return this._client.get("/radar/http/timeseries_groups/http_protocol", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      httpVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.httpVersion({}, query);
        }
        return this._client.get("/radar/http/timeseries_groups/http_version", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      ipVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.ipVersion({}, query);
        }
        return this._client.get("/radar/http/timeseries_groups/ip_version", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      os(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.os({}, query);
        }
        return this._client.get("/radar/http/timeseries_groups/os", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      postQuantum(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.postQuantum({}, query);
        }
        return this._client.get("/radar/http/timeseries_groups/post_quantum", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      tlsVersion(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.tlsVersion({}, query);
        }
        return this._client.get("/radar/http/timeseries_groups/tls_version", {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(TimeseriesGroups7) {
    })(TimeseriesGroups6 || (TimeseriesGroups6 = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/top.mjs
var Top7;
var init_top7 = __esm({
  "node_modules/cloudflare/resources/radar/http/top.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Top7 = class extends APIResource {
      static {
        __name(this, "Top");
      }
      browserFamilies(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.browserFamilies({}, query);
        }
        return this._client.get("/radar/http/top/browser_families", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      browsers(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.browsers({}, query);
        }
        return this._client.get("/radar/http/top/browsers", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Top11) {
    })(Top7 || (Top7 = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/ases/bot-class.mjs
var BotClass;
var init_bot_class = __esm({
  "node_modules/cloudflare/resources/radar/http/ases/bot-class.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    BotClass = class extends APIResource {
      static {
        __name(this, "BotClass");
      }
      get(botClass, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(botClass, {}, query);
        }
        return this._client.get(`/radar/http/top/ases/bot_class/${botClass}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(BotClass3) {
    })(BotClass || (BotClass = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/ases/browser-family.mjs
var BrowserFamily;
var init_browser_family = __esm({
  "node_modules/cloudflare/resources/radar/http/ases/browser-family.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    BrowserFamily = class extends APIResource {
      static {
        __name(this, "BrowserFamily");
      }
      get(browserFamily, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(browserFamily, {}, query);
        }
        return this._client.get(`/radar/http/top/ases/browser_family/${browserFamily}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(BrowserFamily3) {
    })(BrowserFamily || (BrowserFamily = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/ases/device-type.mjs
var DeviceType;
var init_device_type = __esm({
  "node_modules/cloudflare/resources/radar/http/ases/device-type.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    DeviceType = class extends APIResource {
      static {
        __name(this, "DeviceType");
      }
      get(deviceType, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(deviceType, {}, query);
        }
        return this._client.get(`/radar/http/top/ases/device_type/${deviceType}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(DeviceType3) {
    })(DeviceType || (DeviceType = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/ases/http-method.mjs
var HTTPMethod;
var init_http_method = __esm({
  "node_modules/cloudflare/resources/radar/http/ases/http-method.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    HTTPMethod = class extends APIResource {
      static {
        __name(this, "HTTPMethod");
      }
      get(httpVersion, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(httpVersion, {}, query);
        }
        return this._client.get(`/radar/http/top/ases/http_version/${httpVersion}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(HTTPMethod3) {
    })(HTTPMethod || (HTTPMethod = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/ases/http-protocol.mjs
var HTTPProtocol;
var init_http_protocol = __esm({
  "node_modules/cloudflare/resources/radar/http/ases/http-protocol.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    HTTPProtocol = class extends APIResource {
      static {
        __name(this, "HTTPProtocol");
      }
      get(httpProtocol, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(httpProtocol, {}, query);
        }
        return this._client.get(`/radar/http/top/ases/http_protocol/${httpProtocol}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(HTTPProtocol3) {
    })(HTTPProtocol || (HTTPProtocol = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/ases/ip-version.mjs
var IPVersion;
var init_ip_version = __esm({
  "node_modules/cloudflare/resources/radar/http/ases/ip-version.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    IPVersion = class extends APIResource {
      static {
        __name(this, "IPVersion");
      }
      get(ipVersion, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(ipVersion, {}, query);
        }
        return this._client.get(`/radar/http/top/ases/ip_version/${ipVersion}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(IPVersion3) {
    })(IPVersion || (IPVersion = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/ases/os.mjs
var OS;
var init_os = __esm({
  "node_modules/cloudflare/resources/radar/http/ases/os.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    OS = class extends APIResource {
      static {
        __name(this, "OS");
      }
      get(os, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(os, {}, query);
        }
        return this._client.get(`/radar/http/top/ases/os/${os}`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(OS3) {
    })(OS || (OS = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/ases/tls-version.mjs
var TLSVersion;
var init_tls_version = __esm({
  "node_modules/cloudflare/resources/radar/http/ases/tls-version.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    TLSVersion = class extends APIResource {
      static {
        __name(this, "TLSVersion");
      }
      get(tlsVersion, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(tlsVersion, {}, query);
        }
        return this._client.get(`/radar/http/top/ases/tls_version/${tlsVersion}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(TLSVersion3) {
    })(TLSVersion || (TLSVersion = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/ases/ases.mjs
var Ases3;
var init_ases3 = __esm({
  "node_modules/cloudflare/resources/radar/http/ases/ases.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_bot_class();
    init_browser_family();
    init_device_type();
    init_http_method();
    init_http_protocol();
    init_ip_version();
    init_os();
    init_tls_version();
    Ases3 = class extends APIResource {
      static {
        __name(this, "Ases");
      }
      constructor() {
        super(...arguments);
        this.botClass = new BotClass(this._client);
        this.deviceType = new DeviceType(this._client);
        this.httpProtocol = new HTTPProtocol(this._client);
        this.httpMethod = new HTTPMethod(this._client);
        this.ipVersion = new IPVersion(this._client);
        this.os = new OS(this._client);
        this.tlsVersion = new TLSVersion(this._client);
        this.browserFamily = new BrowserFamily(this._client);
      }
      get(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get({}, query);
        }
        return this._client.get("/radar/http/top/ases", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Ases4) {
      Ases4.BotClass = BotClass;
      Ases4.DeviceType = DeviceType;
      Ases4.HTTPProtocol = HTTPProtocol;
      Ases4.HTTPMethod = HTTPMethod;
      Ases4.IPVersion = IPVersion;
      Ases4.OS = OS;
      Ases4.TLSVersion = TLSVersion;
      Ases4.BrowserFamily = BrowserFamily;
    })(Ases3 || (Ases3 = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/locations/bot-class.mjs
var BotClass2;
var init_bot_class2 = __esm({
  "node_modules/cloudflare/resources/radar/http/locations/bot-class.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    BotClass2 = class extends APIResource {
      static {
        __name(this, "BotClass");
      }
      get(botClass, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(botClass, {}, query);
        }
        return this._client.get(`/radar/http/top/locations/bot_class/${botClass}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(BotClass3) {
    })(BotClass2 || (BotClass2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/locations/browser-family.mjs
var BrowserFamily2;
var init_browser_family2 = __esm({
  "node_modules/cloudflare/resources/radar/http/locations/browser-family.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    BrowserFamily2 = class extends APIResource {
      static {
        __name(this, "BrowserFamily");
      }
      get(browserFamily, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(browserFamily, {}, query);
        }
        return this._client.get(`/radar/http/top/locations/browser_family/${browserFamily}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(BrowserFamily3) {
    })(BrowserFamily2 || (BrowserFamily2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/locations/device-type.mjs
var DeviceType2;
var init_device_type2 = __esm({
  "node_modules/cloudflare/resources/radar/http/locations/device-type.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    DeviceType2 = class extends APIResource {
      static {
        __name(this, "DeviceType");
      }
      get(deviceType, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(deviceType, {}, query);
        }
        return this._client.get(`/radar/http/top/locations/device_type/${deviceType}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(DeviceType3) {
    })(DeviceType2 || (DeviceType2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/locations/http-method.mjs
var HTTPMethod2;
var init_http_method2 = __esm({
  "node_modules/cloudflare/resources/radar/http/locations/http-method.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    HTTPMethod2 = class extends APIResource {
      static {
        __name(this, "HTTPMethod");
      }
      get(httpVersion, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(httpVersion, {}, query);
        }
        return this._client.get(`/radar/http/top/locations/http_version/${httpVersion}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(HTTPMethod3) {
    })(HTTPMethod2 || (HTTPMethod2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/locations/http-protocol.mjs
var HTTPProtocol2;
var init_http_protocol2 = __esm({
  "node_modules/cloudflare/resources/radar/http/locations/http-protocol.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    HTTPProtocol2 = class extends APIResource {
      static {
        __name(this, "HTTPProtocol");
      }
      get(httpProtocol, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(httpProtocol, {}, query);
        }
        return this._client.get(`/radar/http/top/locations/http_protocol/${httpProtocol}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(HTTPProtocol3) {
    })(HTTPProtocol2 || (HTTPProtocol2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/locations/ip-version.mjs
var IPVersion2;
var init_ip_version2 = __esm({
  "node_modules/cloudflare/resources/radar/http/locations/ip-version.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    IPVersion2 = class extends APIResource {
      static {
        __name(this, "IPVersion");
      }
      get(ipVersion, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(ipVersion, {}, query);
        }
        return this._client.get(`/radar/http/top/locations/ip_version/${ipVersion}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(IPVersion3) {
    })(IPVersion2 || (IPVersion2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/locations/os.mjs
var OS2;
var init_os2 = __esm({
  "node_modules/cloudflare/resources/radar/http/locations/os.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    OS2 = class extends APIResource {
      static {
        __name(this, "OS");
      }
      get(os, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(os, {}, query);
        }
        return this._client.get(`/radar/http/top/locations/os/${os}`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(OS3) {
    })(OS2 || (OS2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/locations/tls-version.mjs
var TLSVersion2;
var init_tls_version2 = __esm({
  "node_modules/cloudflare/resources/radar/http/locations/tls-version.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    TLSVersion2 = class extends APIResource {
      static {
        __name(this, "TLSVersion");
      }
      get(tlsVersion, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(tlsVersion, {}, query);
        }
        return this._client.get(`/radar/http/top/locations/tls_version/${tlsVersion}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(TLSVersion3) {
    })(TLSVersion2 || (TLSVersion2 = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/locations/locations.mjs
var Locations4;
var init_locations4 = __esm({
  "node_modules/cloudflare/resources/radar/http/locations/locations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_bot_class2();
    init_browser_family2();
    init_device_type2();
    init_http_method2();
    init_http_protocol2();
    init_ip_version2();
    init_os2();
    init_tls_version2();
    Locations4 = class extends APIResource {
      static {
        __name(this, "Locations");
      }
      constructor() {
        super(...arguments);
        this.botClass = new BotClass2(this._client);
        this.deviceType = new DeviceType2(this._client);
        this.httpProtocol = new HTTPProtocol2(this._client);
        this.httpMethod = new HTTPMethod2(this._client);
        this.ipVersion = new IPVersion2(this._client);
        this.os = new OS2(this._client);
        this.tlsVersion = new TLSVersion2(this._client);
        this.browserFamily = new BrowserFamily2(this._client);
      }
      get(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get({}, query);
        }
        return this._client.get("/radar/http/top/locations", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Locations7) {
      Locations7.BotClass = BotClass2;
      Locations7.DeviceType = DeviceType2;
      Locations7.HTTPProtocol = HTTPProtocol2;
      Locations7.HTTPMethod = HTTPMethod2;
      Locations7.IPVersion = IPVersion2;
      Locations7.OS = OS2;
      Locations7.TLSVersion = TLSVersion2;
      Locations7.BrowserFamily = BrowserFamily2;
    })(Locations4 || (Locations4 = {}));
  }
});

// node_modules/cloudflare/resources/radar/http/http.mjs
var HTTP;
var init_http = __esm({
  "node_modules/cloudflare/resources/radar/http/http.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_summary6();
    init_timeseries_groups6();
    init_top7();
    init_ases3();
    init_locations4();
    HTTP = class extends APIResource {
      static {
        __name(this, "HTTP");
      }
      constructor() {
        super(...arguments);
        this.top = new Top7(this._client);
        this.locations = new Locations4(this._client);
        this.ases = new Ases3(this._client);
        this.summary = new Summary6(this._client);
        this.timeseriesGroups = new TimeseriesGroups6(this._client);
      }
      timeseries(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.timeseries({}, query);
        }
        return this._client.get("/radar/http/timeseries", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(HTTP2) {
      HTTP2.Top = Top7;
      HTTP2.Locations = Locations4;
      HTTP2.Ases = Ases3;
      HTTP2.Summary = Summary6;
      HTTP2.TimeseriesGroups = TimeseriesGroups6;
    })(HTTP || (HTTP = {}));
  }
});

// node_modules/cloudflare/resources/radar/netflows/top.mjs
var Top8;
var init_top8 = __esm({
  "node_modules/cloudflare/resources/radar/netflows/top.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Top8 = class extends APIResource {
      static {
        __name(this, "Top");
      }
      ases(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.ases({}, query);
        }
        return this._client.get("/radar/netflows/top/ases", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      locations(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.locations({}, query);
        }
        return this._client.get("/radar/netflows/top/locations", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Top11) {
    })(Top8 || (Top8 = {}));
  }
});

// node_modules/cloudflare/resources/radar/netflows/netflows.mjs
var Netflows;
var init_netflows = __esm({
  "node_modules/cloudflare/resources/radar/netflows/netflows.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_top8();
    Netflows = class extends APIResource {
      static {
        __name(this, "Netflows");
      }
      constructor() {
        super(...arguments);
        this.top = new Top8(this._client);
      }
      timeseries(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.timeseries({}, query);
        }
        return this._client.get("/radar/netflows/timeseries", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Netflows2) {
      Netflows2.Top = Top8;
    })(Netflows || (Netflows = {}));
  }
});

// node_modules/cloudflare/resources/radar/quality/iqi.mjs
var IQI;
var init_iqi = __esm({
  "node_modules/cloudflare/resources/radar/quality/iqi.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    IQI = class extends APIResource {
      static {
        __name(this, "IQI");
      }
      /**
       * Get a summary (percentiles) of bandwidth, latency or DNS response time from the
       * Radar Internet Quality Index (IQI).
       */
      summary(query, options) {
        return this._client.get("/radar/quality/iqi/summary", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a time series (percentiles) of bandwidth, latency or DNS response time from
       * the Radar Internet Quality Index (IQI).
       */
      timeseriesGroups(query, options) {
        return this._client.get("/radar/quality/iqi/timeseries_groups", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(IQI2) {
    })(IQI || (IQI = {}));
  }
});

// node_modules/cloudflare/resources/radar/quality/speed/top.mjs
var Top9;
var init_top9 = __esm({
  "node_modules/cloudflare/resources/radar/quality/speed/top.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Top9 = class extends APIResource {
      static {
        __name(this, "Top");
      }
      ases(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.ases({}, query);
        }
        return this._client.get("/radar/quality/speed/top/ases", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      locations(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.locations({}, query);
        }
        return this._client.get("/radar/quality/speed/top/locations", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Top11) {
    })(Top9 || (Top9 = {}));
  }
});

// node_modules/cloudflare/resources/radar/quality/speed/speed.mjs
var Speed;
var init_speed = __esm({
  "node_modules/cloudflare/resources/radar/quality/speed/speed.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_top9();
    Speed = class extends APIResource {
      static {
        __name(this, "Speed");
      }
      constructor() {
        super(...arguments);
        this.top = new Top9(this._client);
      }
      histogram(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.histogram({}, query);
        }
        return this._client.get("/radar/quality/speed/histogram", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      summary(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.summary({}, query);
        }
        return this._client.get("/radar/quality/speed/summary", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Speed3) {
      Speed3.Top = Top9;
    })(Speed || (Speed = {}));
  }
});

// node_modules/cloudflare/resources/radar/quality/quality.mjs
var Quality;
var init_quality = __esm({
  "node_modules/cloudflare/resources/radar/quality/quality.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_iqi();
    init_speed();
    Quality = class extends APIResource {
      static {
        __name(this, "Quality");
      }
      constructor() {
        super(...arguments);
        this.iqi = new IQI(this._client);
        this.speed = new Speed(this._client);
      }
    };
    (function(Quality2) {
      Quality2.IQI = IQI;
      Quality2.Speed = Speed;
    })(Quality || (Quality = {}));
  }
});

// node_modules/cloudflare/resources/radar/ranking/domain.mjs
var Domain;
var init_domain = __esm({
  "node_modules/cloudflare/resources/radar/ranking/domain.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Domain = class extends APIResource {
      static {
        __name(this, "Domain");
      }
      get(domain, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(domain, {}, query);
        }
        return this._client.get(`/radar/ranking/domain/${domain}`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Domain2) {
    })(Domain || (Domain = {}));
  }
});

// node_modules/cloudflare/resources/radar/ranking/ranking.mjs
var Ranking;
var init_ranking = __esm({
  "node_modules/cloudflare/resources/radar/ranking/ranking.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_domain();
    Ranking = class extends APIResource {
      static {
        __name(this, "Ranking");
      }
      constructor() {
        super(...arguments);
        this.domain = new Domain(this._client);
      }
      timeseriesGroups(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.timeseriesGroups({}, query);
        }
        return this._client.get("/radar/ranking/timeseries_groups", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      top(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.top({}, query);
        }
        return this._client.get("/radar/ranking/top", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Ranking2) {
      Ranking2.Domain = Domain;
    })(Ranking || (Ranking = {}));
  }
});

// node_modules/cloudflare/resources/radar/traffic-anomalies/locations.mjs
var Locations5;
var init_locations5 = __esm({
  "node_modules/cloudflare/resources/radar/traffic-anomalies/locations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Locations5 = class extends APIResource {
      static {
        __name(this, "Locations");
      }
      get(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get({}, query);
        }
        return this._client.get("/radar/traffic_anomalies/locations", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Locations7) {
    })(Locations5 || (Locations5 = {}));
  }
});

// node_modules/cloudflare/resources/radar/traffic-anomalies/traffic-anomalies.mjs
var TrafficAnomalies;
var init_traffic_anomalies = __esm({
  "node_modules/cloudflare/resources/radar/traffic-anomalies/traffic-anomalies.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_locations5();
    TrafficAnomalies = class extends APIResource {
      static {
        __name(this, "TrafficAnomalies");
      }
      constructor() {
        super(...arguments);
        this.locations = new Locations5(this._client);
      }
      get(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get({}, query);
        }
        return this._client.get("/radar/traffic_anomalies", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(TrafficAnomalies2) {
      TrafficAnomalies2.Locations = Locations5;
    })(TrafficAnomalies || (TrafficAnomalies = {}));
  }
});

// node_modules/cloudflare/resources/radar/verified-bots/top.mjs
var Top10;
var init_top10 = __esm({
  "node_modules/cloudflare/resources/radar/verified-bots/top.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Top10 = class extends APIResource {
      static {
        __name(this, "Top");
      }
      bots(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.bots({}, query);
        }
        return this._client.get("/radar/verified_bots/top/bots", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
      categories(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.categories({}, query);
        }
        return this._client.get("/radar/verified_bots/top/categories", { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Top11) {
    })(Top10 || (Top10 = {}));
  }
});

// node_modules/cloudflare/resources/radar/verified-bots/verified-bots.mjs
var VerifiedBots;
var init_verified_bots = __esm({
  "node_modules/cloudflare/resources/radar/verified-bots/verified-bots.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_top10();
    VerifiedBots = class extends APIResource {
      static {
        __name(this, "VerifiedBots");
      }
      constructor() {
        super(...arguments);
        this.top = new Top10(this._client);
      }
    };
    (function(VerifiedBots2) {
      VerifiedBots2.Top = Top10;
    })(VerifiedBots || (VerifiedBots = {}));
  }
});

// node_modules/cloudflare/resources/radar/radar.mjs
var Radar;
var init_radar = __esm({
  "node_modules/cloudflare/resources/radar/radar.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_datasets2();
    init_search();
    init_tcp_resets_timeouts();
    init_annotations();
    init_as112();
    init_attacks();
    init_bgp2();
    init_dns4();
    init_email();
    init_entities();
    init_http();
    init_netflows();
    init_quality();
    init_ranking();
    init_traffic_anomalies();
    init_verified_bots();
    Radar = class extends APIResource {
      static {
        __name(this, "Radar");
      }
      constructor() {
        super(...arguments);
        this.annotations = new Annotations(this._client);
        this.bgp = new BGP2(this._client);
        this.datasets = new Datasets2(this._client);
        this.dns = new DNS4(this._client);
        this.netflows = new Netflows(this._client);
        this.search = new Search(this._client);
        this.verifiedBots = new VerifiedBots(this._client);
        this.as112 = new AS112(this._client);
        this.email = new Email(this._client);
        this.attacks = new Attacks(this._client);
        this.entities = new Entities(this._client);
        this.http = new HTTP(this._client);
        this.quality = new Quality(this._client);
        this.ranking = new Ranking(this._client);
        this.trafficAnomalies = new TrafficAnomalies(this._client);
        this.tcpResetsTimeouts = new TCPResetsTimeouts(this._client);
      }
    };
    (function(Radar2) {
      Radar2.Annotations = Annotations;
      Radar2.BGP = BGP2;
      Radar2.Datasets = Datasets2;
      Radar2.DNS = DNS4;
      Radar2.Netflows = Netflows;
      Radar2.Search = Search;
      Radar2.VerifiedBots = VerifiedBots;
      Radar2.AS112 = AS112;
      Radar2.Email = Email;
      Radar2.Attacks = Attacks;
      Radar2.Entities = Entities;
      Radar2.HTTP = HTTP;
      Radar2.Quality = Quality;
      Radar2.Ranking = Ranking;
      Radar2.TrafficAnomalies = TrafficAnomalies;
      Radar2.TCPResetsTimeouts = TCPResetsTimeouts;
    })(Radar || (Radar = {}));
  }
});

// node_modules/cloudflare/resources/rate-limits.mjs
var RateLimits, RateLimitsV4PagePaginationArray;
var init_rate_limits = __esm({
  "node_modules/cloudflare/resources/rate-limits.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_pagination();
    RateLimits = class extends APIResource {
      static {
        __name(this, "RateLimits");
      }
      /**
       * Creates a new rate limit for a zone. Refer to the object definition for a list
       * of required attributes.
       *
       * @deprecated Rate limiting API is deprecated in favour of using the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#rate-limiting-api-previous-version for full details.
       */
      create(zoneIdentifier, body, options) {
        return this._client.post(`/zones/${zoneIdentifier}/rate_limits`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      list(zoneIdentifier, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list(zoneIdentifier, {}, query);
        }
        return this._client.getAPIList(`/zones/${zoneIdentifier}/rate_limits`, RateLimitsV4PagePaginationArray, {
          query,
          ...options
        });
      }
      /**
       * Deletes an existing rate limit.
       *
       * @deprecated Rate limiting API is deprecated in favour of using the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#rate-limiting-api-previous-version for full details.
       */
      delete(zoneIdentifier, id, options) {
        return this._client.delete(`/zones/${zoneIdentifier}/rate_limits/${id}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an existing rate limit.
       *
       * @deprecated Rate limiting API is deprecated in favour of using the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#rate-limiting-api-previous-version for full details.
       */
      edit(zoneIdentifier, id, body, options) {
        return this._client.put(`/zones/${zoneIdentifier}/rate_limits/${id}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the details of a rate limit.
       *
       * @deprecated Rate limiting API is deprecated in favour of using the Ruleset Engine. See https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#rate-limiting-api-previous-version for full details.
       */
      get(zoneIdentifier, id, options) {
        return this._client.get(`/zones/${zoneIdentifier}/rate_limits/${id}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    RateLimitsV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "RateLimitsV4PagePaginationArray");
      }
    };
  }
});

// node_modules/cloudflare/resources/rate-plans.mjs
var RatePlans;
var init_rate_plans = __esm({
  "node_modules/cloudflare/resources/rate-plans.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    RatePlans = class extends APIResource {
      static {
        __name(this, "RatePlans");
      }
      /**
       * Lists all rate plans the zone can subscribe to.
       */
      get(zoneIdentifier, options) {
        return this._client.get(`/zones/${zoneIdentifier}/available_rate_plans`, options)._thenUnwrap((obj) => obj.result);
      }
    };
  }
});

// node_modules/cloudflare/resources/registrar/domains.mjs
var Domains3, DomainsSinglePage;
var init_domains3 = __esm({
  "node_modules/cloudflare/resources/registrar/domains.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_domains3();
    init_pagination();
    Domains3 = class extends APIResource {
      static {
        __name(this, "Domains");
      }
      /**
       * Update individual domain.
       */
      update(domainName, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/registrar/domains/${domainName}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List domains handled by Registrar.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/registrar/domains`, DomainsSinglePage, options);
      }
      /**
       * Show individual domain.
       */
      get(domainName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/registrar/domains/${domainName}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    DomainsSinglePage = class extends SinglePage {
      static {
        __name(this, "DomainsSinglePage");
      }
    };
    (function(Domains5) {
      Domains5.DomainsSinglePage = DomainsSinglePage;
    })(Domains3 || (Domains3 = {}));
  }
});

// node_modules/cloudflare/resources/registrar/registrar.mjs
var Registrar;
var init_registrar = __esm({
  "node_modules/cloudflare/resources/registrar/registrar.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_domains3();
    Registrar = class extends APIResource {
      static {
        __name(this, "Registrar");
      }
      constructor() {
        super(...arguments);
        this.domains = new Domains3(this._client);
      }
    };
    (function(Registrar2) {
      Registrar2.Domains = Domains3;
      Registrar2.DomainsSinglePage = DomainsSinglePage;
    })(Registrar || (Registrar = {}));
  }
});

// node_modules/cloudflare/resources/request-tracers/traces.mjs
var Traces;
var init_traces = __esm({
  "node_modules/cloudflare/resources/request-tracers/traces.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Traces = class extends APIResource {
      static {
        __name(this, "Traces");
      }
      /**
       * Request Trace
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/request-tracer/trace`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Traces2) {
    })(Traces || (Traces = {}));
  }
});

// node_modules/cloudflare/resources/request-tracers/request-tracers.mjs
var RequestTracers;
var init_request_tracers = __esm({
  "node_modules/cloudflare/resources/request-tracers/request-tracers.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_traces();
    RequestTracers = class extends APIResource {
      static {
        __name(this, "RequestTracers");
      }
      constructor() {
        super(...arguments);
        this.traces = new Traces(this._client);
      }
    };
    (function(RequestTracers2) {
      RequestTracers2.Traces = Traces;
    })(RequestTracers || (RequestTracers = {}));
  }
});

// node_modules/cloudflare/resources/rules/lists/bulk-operations.mjs
var BulkOperations;
var init_bulk_operations = __esm({
  "node_modules/cloudflare/resources/rules/lists/bulk-operations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    BulkOperations = class extends APIResource {
      static {
        __name(this, "BulkOperations");
      }
      /**
       * Gets the current status of an asynchronous operation on a list.
       *
       * The `status` property can have one of the following values: `pending`,
       * `running`, `completed`, or `failed`. If the status is `failed`, the `error`
       * property will contain a message describing the error.
       */
      get(accountIdentifier, operationId, options) {
        return this._client.get(`/accounts/${accountIdentifier}/rules/lists/bulk_operations/${operationId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(BulkOperations2) {
    })(BulkOperations || (BulkOperations = {}));
  }
});

// node_modules/cloudflare/resources/rules/lists/items.mjs
var Items, ItemListResponsesCursorPagination;
var init_items = __esm({
  "node_modules/cloudflare/resources/rules/lists/items.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_items();
    init_pagination();
    Items = class extends APIResource {
      static {
        __name(this, "Items");
      }
      /**
       * Appends new items to the list.
       *
       * This operation is asynchronous. To get current the operation status, invoke the
       * [Get bulk operation status](/operations/lists-get-bulk-operation-status)
       * endpoint with the returned `operation_id`.
       */
      create(listId, params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/rules/lists/${listId}/items`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Removes all existing items from the list and adds the provided items to the
       * list.
       *
       * This operation is asynchronous. To get current the operation status, invoke the
       * [Get bulk operation status](/operations/lists-get-bulk-operation-status)
       * endpoint with the returned `operation_id`.
       */
      update(listId, params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/rules/lists/${listId}/items`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches all the items in the list.
       */
      list(listId, params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/rules/lists/${listId}/items`, ItemListResponsesCursorPagination, { query, ...options });
      }
      /**
       * Removes one or more items from a list.
       *
       * This operation is asynchronous. To get current the operation status, invoke the
       * [Get bulk operation status](/operations/lists-get-bulk-operation-status)
       * endpoint with the returned `operation_id`.
       */
      delete(listId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/rules/lists/${listId}/items`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a list item in the list.
       */
      get(accountIdentifier, listId, itemId, options) {
        return this._client.get(`/accounts/${accountIdentifier}/rules/lists/${listId}/items/${itemId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ItemListResponsesCursorPagination = class extends CursorPagination {
      static {
        __name(this, "ItemListResponsesCursorPagination");
      }
    };
    (function(Items3) {
      Items3.ItemListResponsesCursorPagination = ItemListResponsesCursorPagination;
    })(Items || (Items = {}));
  }
});

// node_modules/cloudflare/resources/rules/lists/lists.mjs
var Lists, ListsListsSinglePage;
var init_lists = __esm({
  "node_modules/cloudflare/resources/rules/lists/lists.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_lists();
    init_bulk_operations();
    init_items();
    init_pagination();
    Lists = class extends APIResource {
      static {
        __name(this, "Lists");
      }
      constructor() {
        super(...arguments);
        this.bulkOperations = new BulkOperations(this._client);
        this.items = new Items(this._client);
      }
      /**
       * Creates a new list of the specified type.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/rules/lists`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates the description of a list.
       */
      update(listId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/rules/lists/${listId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches all lists in the account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/rules/lists`, ListsListsSinglePage, options);
      }
      /**
       * Deletes a specific list and all its items.
       */
      delete(listId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/rules/lists/${listId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the details of a list.
       */
      get(listId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/rules/lists/${listId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ListsListsSinglePage = class extends SinglePage {
      static {
        __name(this, "ListsListsSinglePage");
      }
    };
    (function(Lists3) {
      Lists3.ListsListsSinglePage = ListsListsSinglePage;
      Lists3.BulkOperations = BulkOperations;
      Lists3.Items = Items;
      Lists3.ItemListResponsesCursorPagination = ItemListResponsesCursorPagination;
    })(Lists || (Lists = {}));
  }
});

// node_modules/cloudflare/resources/rules/rules.mjs
var Rules7;
var init_rules7 = __esm({
  "node_modules/cloudflare/resources/rules/rules.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_lists();
    Rules7 = class extends APIResource {
      static {
        __name(this, "Rules");
      }
      constructor() {
        super(...arguments);
        this.lists = new Lists(this._client);
      }
    };
    (function(Rules12) {
      Rules12.Lists = Lists;
      Rules12.ListsListsSinglePage = ListsListsSinglePage;
    })(Rules7 || (Rules7 = {}));
  }
});

// node_modules/cloudflare/resources/rulesets/rules.mjs
var Rules8;
var init_rules8 = __esm({
  "node_modules/cloudflare/resources/rulesets/rules.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    Rules8 = class extends APIResource {
      static {
        __name(this, "Rules");
      }
      /**
       * Adds a new rule to an account or zone ruleset. The rule will be added to the end
       * of the existing list of rules in the ruleset by default.
       */
      create(rulesetId, params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/rulesets/${rulesetId}/rules`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      delete(rulesetId, ruleId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.delete(rulesetId, ruleId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.delete(`/${accountOrZone}/${accountOrZoneId}/rulesets/${rulesetId}/rules/${ruleId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an existing rule in an account or zone ruleset.
       */
      edit(rulesetId, ruleId, params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.patch(`/${accountOrZone}/${accountOrZoneId}/rulesets/${rulesetId}/rules/${ruleId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Rules12) {
    })(Rules8 || (Rules8 = {}));
  }
});

// node_modules/cloudflare/resources/rulesets/phases/versions.mjs
var Versions, VersionListResponsesSinglePage;
var init_versions = __esm({
  "node_modules/cloudflare/resources/rulesets/phases/versions.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    init_versions();
    init_pagination();
    Versions = class extends APIResource {
      static {
        __name(this, "Versions");
      }
      list(rulesetPhase, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list(rulesetPhase, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.getAPIList(`/${accountOrZone}/${accountOrZoneId}/rulesets/phases/${rulesetPhase}/entrypoint/versions`, VersionListResponsesSinglePage, options);
      }
      get(rulesetPhase, rulesetVersion, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get(rulesetPhase, rulesetVersion, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/rulesets/phases/${rulesetPhase}/entrypoint/versions/${rulesetVersion}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    VersionListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "VersionListResponsesSinglePage");
      }
    };
    (function(Versions4) {
      Versions4.VersionListResponsesSinglePage = VersionListResponsesSinglePage;
    })(Versions || (Versions = {}));
  }
});

// node_modules/cloudflare/resources/rulesets/phases/phases.mjs
var Phases;
var init_phases = __esm({
  "node_modules/cloudflare/resources/rulesets/phases/phases.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    init_versions();
    Phases = class extends APIResource {
      static {
        __name(this, "Phases");
      }
      constructor() {
        super(...arguments);
        this.versions = new Versions(this._client);
      }
      /**
       * Updates an account or zone entry point ruleset, creating a new version.
       */
      update(rulesetPhase, params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.put(`/${accountOrZone}/${accountOrZoneId}/rulesets/phases/${rulesetPhase}/entrypoint`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      get(rulesetPhase, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get(rulesetPhase, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/rulesets/phases/${rulesetPhase}/entrypoint`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Phases2) {
      Phases2.Versions = Versions;
      Phases2.VersionListResponsesSinglePage = VersionListResponsesSinglePage;
    })(Phases || (Phases = {}));
  }
});

// node_modules/cloudflare/resources/rulesets/versions/by-tag.mjs
var ByTag;
var init_by_tag = __esm({
  "node_modules/cloudflare/resources/rulesets/versions/by-tag.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    ByTag = class extends APIResource {
      static {
        __name(this, "ByTag");
      }
      /**
       * Fetches the rules of a managed account ruleset version for a given tag.
       */
      get(rulesetId, rulesetVersion, ruleTag, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/rulesets/${rulesetId}/versions/${rulesetVersion}/by_tag/${ruleTag}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(ByTag2) {
    })(ByTag || (ByTag = {}));
  }
});

// node_modules/cloudflare/resources/rulesets/versions/versions.mjs
var Versions2, VersionListResponsesSinglePage2;
var init_versions2 = __esm({
  "node_modules/cloudflare/resources/rulesets/versions/versions.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    init_versions2();
    init_by_tag();
    init_pagination();
    Versions2 = class extends APIResource {
      static {
        __name(this, "Versions");
      }
      constructor() {
        super(...arguments);
        this.byTag = new ByTag(this._client);
      }
      list(rulesetId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list(rulesetId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.getAPIList(`/${accountOrZone}/${accountOrZoneId}/rulesets/${rulesetId}/versions`, VersionListResponsesSinglePage2, options);
      }
      delete(rulesetId, rulesetVersion, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.delete(rulesetId, rulesetVersion, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.delete(`/${accountOrZone}/${accountOrZoneId}/rulesets/${rulesetId}/versions/${rulesetVersion}`, { ...options, headers: { Accept: "*/*", ...options?.headers } });
      }
      get(rulesetId, rulesetVersion, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get(rulesetId, rulesetVersion, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/rulesets/${rulesetId}/versions/${rulesetVersion}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    VersionListResponsesSinglePage2 = class extends SinglePage {
      static {
        __name(this, "VersionListResponsesSinglePage");
      }
    };
    (function(Versions4) {
      Versions4.VersionListResponsesSinglePage = VersionListResponsesSinglePage2;
      Versions4.ByTag = ByTag;
    })(Versions2 || (Versions2 = {}));
  }
});

// node_modules/cloudflare/resources/rulesets/rulesets.mjs
var Rulesets, RulesetListResponsesSinglePage;
var init_rulesets = __esm({
  "node_modules/cloudflare/resources/rulesets/rulesets.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    init_rules8();
    init_phases();
    init_versions2();
    init_pagination();
    Rulesets = class extends APIResource {
      static {
        __name(this, "Rulesets");
      }
      constructor() {
        super(...arguments);
        this.phases = new Phases(this._client);
        this.rules = new Rules8(this._client);
        this.versions = new Versions2(this._client);
      }
      /**
       * Creates a ruleset.
       */
      create(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/rulesets`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an account or zone ruleset, creating a new version.
       */
      update(rulesetId, params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.put(`/${accountOrZone}/${accountOrZoneId}/rulesets/${rulesetId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      list(params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list({}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.getAPIList(`/${accountOrZone}/${accountOrZoneId}/rulesets`, RulesetListResponsesSinglePage, options);
      }
      delete(rulesetId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.delete(rulesetId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.delete(`/${accountOrZone}/${accountOrZoneId}/rulesets/${rulesetId}`, {
          ...options,
          headers: { Accept: "*/*", ...options?.headers }
        });
      }
      get(rulesetId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get(rulesetId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/rulesets/${rulesetId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    RulesetListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "RulesetListResponsesSinglePage");
      }
    };
    (function(Rulesets2) {
      Rulesets2.Phases = Phases;
      Rulesets2.Rules = Rules8;
      Rulesets2.Versions = Versions2;
      Rulesets2.VersionListResponsesSinglePage = VersionListResponsesSinglePage2;
    })(Rulesets || (Rulesets = {}));
  }
});

// node_modules/cloudflare/resources/ssl/analyze.mjs
var Analyze;
var init_analyze = __esm({
  "node_modules/cloudflare/resources/ssl/analyze.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Analyze = class extends APIResource {
      static {
        __name(this, "Analyze");
      }
      /**
       * Returns the set of hostnames, the signature algorithm, and the expiration date
       * of the certificate.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/ssl/analyze`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Analyze2) {
    })(Analyze || (Analyze = {}));
  }
});

// node_modules/cloudflare/resources/ssl/recommendations.mjs
var Recommendations;
var init_recommendations = __esm({
  "node_modules/cloudflare/resources/ssl/recommendations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Recommendations = class extends APIResource {
      static {
        __name(this, "Recommendations");
      }
      /**
       * Retrieve the SSL/TLS Recommender's recommendation for a zone.
       */
      get(zoneIdentifier, options) {
        return this._client.get(`/zones/${zoneIdentifier}/ssl/recommendation`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Recommendations2) {
    })(Recommendations || (Recommendations = {}));
  }
});

// node_modules/cloudflare/resources/ssl/verification.mjs
var VerificationResource;
var init_verification = __esm({
  "node_modules/cloudflare/resources/ssl/verification.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    VerificationResource = class extends APIResource {
      static {
        __name(this, "VerificationResource");
      }
      /**
       * Edit SSL validation method for a certificate pack. A PATCH request will request
       * an immediate validation check on any certificate, and return the updated status.
       * If a validation method is provided, the validation will be immediately attempted
       * using that method.
       */
      edit(certificatePackId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/ssl/verification/${certificatePackId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get SSL Verification Info for a Zone.
       */
      get(params, options) {
        const { zone_id, ...query } = params;
        return this._client.get(`/zones/${zone_id}/ssl/verification`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(VerificationResource2) {
    })(VerificationResource || (VerificationResource = {}));
  }
});

// node_modules/cloudflare/resources/ssl/certificate-packs/order.mjs
var Order;
var init_order = __esm({
  "node_modules/cloudflare/resources/ssl/certificate-packs/order.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Order = class extends APIResource {
      static {
        __name(this, "Order");
      }
      /**
       * For a given zone, order an advanced certificate pack.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/ssl/certificate_packs/order`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Order2) {
    })(Order || (Order = {}));
  }
});

// node_modules/cloudflare/resources/ssl/certificate-packs/quota.mjs
var Quota;
var init_quota = __esm({
  "node_modules/cloudflare/resources/ssl/certificate-packs/quota.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Quota = class extends APIResource {
      static {
        __name(this, "Quota");
      }
      /**
       * For a given zone, list certificate pack quotas.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/ssl/certificate_packs/quota`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Quota2) {
    })(Quota || (Quota = {}));
  }
});

// node_modules/cloudflare/resources/ssl/certificate-packs/certificate-packs.mjs
var CertificatePacks, CertificatePackListResponsesSinglePage;
var init_certificate_packs = __esm({
  "node_modules/cloudflare/resources/ssl/certificate-packs/certificate-packs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_certificate_packs();
    init_order();
    init_quota();
    init_pagination();
    CertificatePacks = class extends APIResource {
      static {
        __name(this, "CertificatePacks");
      }
      constructor() {
        super(...arguments);
        this.order = new Order(this._client);
        this.quota = new Quota(this._client);
      }
      /**
       * For a given zone, list all active certificate packs.
       */
      list(params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/ssl/certificate_packs`, CertificatePackListResponsesSinglePage, { query, ...options });
      }
      /**
       * For a given zone, delete an advanced certificate pack.
       */
      delete(certificatePackId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/ssl/certificate_packs/${certificatePackId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * For a given zone, restart validation for an advanced certificate pack. This is
       * only a validation operation for a Certificate Pack in a validation_timed_out
       * status.
       */
      edit(certificatePackId, params, options) {
        const { zone_id, body } = params;
        return this._client.patch(`/zones/${zone_id}/ssl/certificate_packs/${certificatePackId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * For a given zone, get a certificate pack.
       */
      get(certificatePackId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/ssl/certificate_packs/${certificatePackId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    CertificatePackListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "CertificatePackListResponsesSinglePage");
      }
    };
    (function(CertificatePacks2) {
      CertificatePacks2.CertificatePackListResponsesSinglePage = CertificatePackListResponsesSinglePage;
      CertificatePacks2.Order = Order;
      CertificatePacks2.Quota = Quota;
    })(CertificatePacks || (CertificatePacks = {}));
  }
});

// node_modules/cloudflare/resources/ssl/universal/settings.mjs
var Settings6;
var init_settings6 = __esm({
  "node_modules/cloudflare/resources/ssl/universal/settings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Settings6 = class extends APIResource {
      static {
        __name(this, "Settings");
      }
      /**
       * Patch Universal SSL Settings for a Zone.
       */
      edit(params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/ssl/universal/settings`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get Universal SSL Settings for a Zone.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/ssl/universal/settings`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Settings13) {
    })(Settings6 || (Settings6 = {}));
  }
});

// node_modules/cloudflare/resources/ssl/universal/universal.mjs
var Universal;
var init_universal = __esm({
  "node_modules/cloudflare/resources/ssl/universal/universal.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_settings6();
    Universal = class extends APIResource {
      static {
        __name(this, "Universal");
      }
      constructor() {
        super(...arguments);
        this.settings = new Settings6(this._client);
      }
    };
    (function(Universal2) {
      Universal2.Settings = Settings6;
    })(Universal || (Universal = {}));
  }
});

// node_modules/cloudflare/resources/ssl/ssl.mjs
var SSL;
var init_ssl = __esm({
  "node_modules/cloudflare/resources/ssl/ssl.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_analyze();
    init_recommendations();
    init_verification();
    init_certificate_packs();
    init_universal();
    SSL = class extends APIResource {
      static {
        __name(this, "SSL");
      }
      constructor() {
        super(...arguments);
        this.analyze = new Analyze(this._client);
        this.certificatePacks = new CertificatePacks(this._client);
        this.recommendations = new Recommendations(this._client);
        this.universal = new Universal(this._client);
        this.verification = new VerificationResource(this._client);
      }
    };
    (function(SSL2) {
      SSL2.Analyze = Analyze;
      SSL2.CertificatePacks = CertificatePacks;
      SSL2.CertificatePackListResponsesSinglePage = CertificatePackListResponsesSinglePage;
      SSL2.Recommendations = Recommendations;
      SSL2.Universal = Universal;
      SSL2.VerificationResource = VerificationResource;
    })(SSL || (SSL = {}));
  }
});

// node_modules/cloudflare/resources/secondary-dns/acls.mjs
var ACLs2, ACLsSinglePage2;
var init_acls2 = __esm({
  "node_modules/cloudflare/resources/secondary-dns/acls.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_acls2();
    init_pagination();
    ACLs2 = class extends APIResource {
      static {
        __name(this, "ACLs");
      }
      /**
       * Create ACL.
       */
      create(params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/secondary_dns/acls`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Modify ACL.
       */
      update(aclId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/secondary_dns/acls/${aclId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List ACLs.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/secondary_dns/acls`, ACLsSinglePage2, options);
      }
      /**
       * Delete ACL.
       */
      delete(aclId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/secondary_dns/acls/${aclId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get ACL.
       */
      get(aclId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/secondary_dns/acls/${aclId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ACLsSinglePage2 = class extends SinglePage {
      static {
        __name(this, "ACLsSinglePage");
      }
    };
    (function(ACLs3) {
      ACLs3.ACLsSinglePage = ACLsSinglePage2;
    })(ACLs2 || (ACLs2 = {}));
  }
});

// node_modules/cloudflare/resources/secondary-dns/force-axfr.mjs
var ForceAXFRResource;
var init_force_axfr = __esm({
  "node_modules/cloudflare/resources/secondary-dns/force-axfr.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    ForceAXFRResource = class extends APIResource {
      static {
        __name(this, "ForceAXFRResource");
      }
      /**
       * Sends AXFR zone transfer request to primary nameserver(s).
       */
      create(params, options) {
        const { zone_id, body } = params;
        return this._client.post(`/zones/${zone_id}/secondary_dns/force_axfr`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(ForceAXFRResource2) {
    })(ForceAXFRResource || (ForceAXFRResource = {}));
  }
});

// node_modules/cloudflare/resources/secondary-dns/incoming.mjs
var IncomingResource;
var init_incoming = __esm({
  "node_modules/cloudflare/resources/secondary-dns/incoming.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    IncomingResource = class extends APIResource {
      static {
        __name(this, "IncomingResource");
      }
      /**
       * Create secondary zone configuration for incoming zone transfers.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/secondary_dns/incoming`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update secondary zone configuration for incoming zone transfers.
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/secondary_dns/incoming`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Delete secondary zone configuration for incoming zone transfers.
       */
      delete(params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/secondary_dns/incoming`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get secondary zone configuration for incoming zone transfers.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/secondary_dns/incoming`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(IncomingResource2) {
    })(IncomingResource || (IncomingResource = {}));
  }
});

// node_modules/cloudflare/resources/secondary-dns/peers.mjs
var Peers, PeersSinglePage;
var init_peers = __esm({
  "node_modules/cloudflare/resources/secondary-dns/peers.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_peers();
    init_pagination();
    Peers = class extends APIResource {
      static {
        __name(this, "Peers");
      }
      /**
       * Create Peer.
       */
      create(params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/secondary_dns/peers`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Modify Peer.
       */
      update(peerId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/secondary_dns/peers/${peerId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List Peers.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/secondary_dns/peers`, PeersSinglePage, options);
      }
      /**
       * Delete Peer.
       */
      delete(peerId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/secondary_dns/peers/${peerId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get Peer.
       */
      get(peerId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/secondary_dns/peers/${peerId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    PeersSinglePage = class extends SinglePage {
      static {
        __name(this, "PeersSinglePage");
      }
    };
    (function(Peers2) {
      Peers2.PeersSinglePage = PeersSinglePage;
    })(Peers || (Peers = {}));
  }
});

// node_modules/cloudflare/resources/secondary-dns/tsigs.mjs
var TSIGs, TSIGsSinglePage;
var init_tsigs = __esm({
  "node_modules/cloudflare/resources/secondary-dns/tsigs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_tsigs();
    init_pagination();
    TSIGs = class extends APIResource {
      static {
        __name(this, "TSIGs");
      }
      /**
       * Create TSIG.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/secondary_dns/tsigs`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Modify TSIG.
       */
      update(tsigId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/secondary_dns/tsigs/${tsigId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List TSIGs.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/secondary_dns/tsigs`, TSIGsSinglePage, options);
      }
      /**
       * Delete TSIG.
       */
      delete(tsigId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/secondary_dns/tsigs/${tsigId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get TSIG.
       */
      get(tsigId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/secondary_dns/tsigs/${tsigId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    TSIGsSinglePage = class extends SinglePage {
      static {
        __name(this, "TSIGsSinglePage");
      }
    };
    (function(TSIGs2) {
      TSIGs2.TSIGsSinglePage = TSIGsSinglePage;
    })(TSIGs || (TSIGs = {}));
  }
});

// node_modules/cloudflare/resources/secondary-dns/outgoing/status.mjs
var Status;
var init_status = __esm({
  "node_modules/cloudflare/resources/secondary-dns/outgoing/status.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Status = class extends APIResource {
      static {
        __name(this, "Status");
      }
      /**
       * Get primary zone transfer status.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/secondary_dns/outgoing/status`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Status2) {
    })(Status || (Status = {}));
  }
});

// node_modules/cloudflare/resources/secondary-dns/outgoing/outgoing.mjs
var OutgoingResource;
var init_outgoing = __esm({
  "node_modules/cloudflare/resources/secondary-dns/outgoing/outgoing.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_status();
    OutgoingResource = class extends APIResource {
      static {
        __name(this, "OutgoingResource");
      }
      constructor() {
        super(...arguments);
        this.status = new Status(this._client);
      }
      /**
       * Create primary zone configuration for outgoing zone transfers.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/secondary_dns/outgoing`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update primary zone configuration for outgoing zone transfers.
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/secondary_dns/outgoing`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Delete primary zone configuration for outgoing zone transfers.
       */
      delete(params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/secondary_dns/outgoing`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Disable outgoing zone transfers for primary zone and clears IXFR backlog of
       * primary zone.
       */
      disable(params, options) {
        const { zone_id, body } = params;
        return this._client.post(`/zones/${zone_id}/secondary_dns/outgoing/disable`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Enable outgoing zone transfers for primary zone.
       */
      enable(params, options) {
        const { zone_id, body } = params;
        return this._client.post(`/zones/${zone_id}/secondary_dns/outgoing/enable`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Notifies the secondary nameserver(s) and clears IXFR backlog of primary zone.
       */
      forceNotify(params, options) {
        const { zone_id, body } = params;
        return this._client.post(`/zones/${zone_id}/secondary_dns/outgoing/force_notify`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get primary zone configuration for outgoing zone transfers.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/secondary_dns/outgoing`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(OutgoingResource2) {
      OutgoingResource2.Status = Status;
    })(OutgoingResource || (OutgoingResource = {}));
  }
});

// node_modules/cloudflare/resources/secondary-dns/secondary-dns.mjs
var SecondaryDNS;
var init_secondary_dns = __esm({
  "node_modules/cloudflare/resources/secondary-dns/secondary-dns.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_acls2();
    init_force_axfr();
    init_incoming();
    init_peers();
    init_tsigs();
    init_outgoing();
    SecondaryDNS = class extends APIResource {
      static {
        __name(this, "SecondaryDNS");
      }
      constructor() {
        super(...arguments);
        this.forceAXFR = new ForceAXFRResource(this._client);
        this.incoming = new IncomingResource(this._client);
        this.outgoing = new OutgoingResource(this._client);
        this.acls = new ACLs2(this._client);
        this.peers = new Peers(this._client);
        this.tsigs = new TSIGs(this._client);
      }
    };
    (function(SecondaryDNS2) {
      SecondaryDNS2.ForceAXFRResource = ForceAXFRResource;
      SecondaryDNS2.IncomingResource = IncomingResource;
      SecondaryDNS2.OutgoingResource = OutgoingResource;
      SecondaryDNS2.ACLs = ACLs2;
      SecondaryDNS2.ACLsSinglePage = ACLsSinglePage2;
      SecondaryDNS2.Peers = Peers;
      SecondaryDNS2.PeersSinglePage = PeersSinglePage;
      SecondaryDNS2.TSIGs = TSIGs;
      SecondaryDNS2.TSIGsSinglePage = TSIGsSinglePage;
    })(SecondaryDNS || (SecondaryDNS = {}));
  }
});

// node_modules/cloudflare/resources/snippets/content.mjs
var Content;
var init_content = __esm({
  "node_modules/cloudflare/resources/snippets/content.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Content = class extends APIResource {
      static {
        __name(this, "Content");
      }
      /**
       * Snippet Content
       */
      get(snippetName, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/snippets/${snippetName}/content`, {
          ...options,
          __binaryResponse: true
        });
      }
    };
    /* @__PURE__ */ (function(Content4) {
    })(Content || (Content = {}));
  }
});

// node_modules/cloudflare/resources/snippets/rules.mjs
var Rules9, RuleListResponsesSinglePage2;
var init_rules9 = __esm({
  "node_modules/cloudflare/resources/snippets/rules.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_rules9();
    init_pagination();
    Rules9 = class extends APIResource {
      static {
        __name(this, "Rules");
      }
      /**
       * Put Rules
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/snippets/snippet_rules`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Rules
       */
      list(params, options) {
        const { zone_id } = params;
        return this._client.getAPIList(`/zones/${zone_id}/snippets/snippet_rules`, RuleListResponsesSinglePage2, options);
      }
    };
    RuleListResponsesSinglePage2 = class extends SinglePage {
      static {
        __name(this, "RuleListResponsesSinglePage");
      }
    };
    (function(Rules12) {
      Rules12.RuleListResponsesSinglePage = RuleListResponsesSinglePage2;
    })(Rules9 || (Rules9 = {}));
  }
});

// node_modules/cloudflare/resources/snippets/snippets.mjs
var Snippets, SnippetsSinglePage;
var init_snippets = __esm({
  "node_modules/cloudflare/resources/snippets/snippets.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_content();
    init_rules9();
    init_pagination();
    Snippets = class extends APIResource {
      static {
        __name(this, "Snippets");
      }
      constructor() {
        super(...arguments);
        this.content = new Content(this._client);
        this.rules = new Rules9(this._client);
      }
      /**
       * Put Snippet
       */
      update(snippetName, params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/snippets/${snippetName}`, multipartFormRequestOptions({ body, ...options }))._thenUnwrap((obj) => obj.result);
      }
      /**
       * All Snippets
       */
      list(params, options) {
        const { zone_id } = params;
        return this._client.getAPIList(`/zones/${zone_id}/snippets`, SnippetsSinglePage, options);
      }
      /**
       * Delete Snippet
       */
      delete(snippetName, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/snippets/${snippetName}`, options);
      }
      /**
       * Snippet
       */
      get(snippetName, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/snippets/${snippetName}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    SnippetsSinglePage = class extends SinglePage {
      static {
        __name(this, "SnippetsSinglePage");
      }
    };
    (function(Snippets2) {
      Snippets2.Content = Content;
      Snippets2.Rules = Rules9;
      Snippets2.RuleListResponsesSinglePage = RuleListResponsesSinglePage2;
    })(Snippets || (Snippets = {}));
  }
});

// node_modules/cloudflare/resources/spectrum/apps.mjs
var Apps2, AppListResponsesV4PagePaginationArray;
var init_apps2 = __esm({
  "node_modules/cloudflare/resources/spectrum/apps.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_apps2();
    init_pagination();
    Apps2 = class extends APIResource {
      static {
        __name(this, "Apps");
      }
      /**
       * Creates a new Spectrum application from a configuration using a name for the
       * origin.
       */
      create(zone, body, options) {
        return this._client.post(`/zones/${zone}/spectrum/apps`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a previously existing application's configuration that uses a name for
       * the origin.
       */
      update(zone, appId, body, options) {
        return this._client.put(`/zones/${zone}/spectrum/apps/${appId}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      list(zone, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list(zone, {}, query);
        }
        return this._client.getAPIList(`/zones/${zone}/spectrum/apps`, AppListResponsesV4PagePaginationArray, {
          query,
          ...options
        });
      }
      /**
       * Deletes a previously existing application.
       */
      delete(zone, appId, options) {
        return this._client.delete(`/zones/${zone}/spectrum/apps/${appId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Gets the application configuration of a specific application inside a zone.
       */
      get(zone, appId, options) {
        return this._client.get(`/zones/${zone}/spectrum/apps/${appId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    AppListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "AppListResponsesV4PagePaginationArray");
      }
    };
    (function(Apps3) {
      Apps3.AppListResponsesV4PagePaginationArray = AppListResponsesV4PagePaginationArray;
    })(Apps2 || (Apps2 = {}));
  }
});

// node_modules/cloudflare/resources/spectrum/analytics/aggregates/currents.mjs
var Currents;
var init_currents = __esm({
  "node_modules/cloudflare/resources/spectrum/analytics/aggregates/currents.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Currents = class extends APIResource {
      static {
        __name(this, "Currents");
      }
      get(zone, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(zone, {}, query);
        }
        return this._client.get(`/zones/${zone}/spectrum/analytics/aggregate/current`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Currents2) {
    })(Currents || (Currents = {}));
  }
});

// node_modules/cloudflare/resources/spectrum/analytics/aggregates/aggregates.mjs
var Aggregates;
var init_aggregates = __esm({
  "node_modules/cloudflare/resources/spectrum/analytics/aggregates/aggregates.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_currents();
    Aggregates = class extends APIResource {
      static {
        __name(this, "Aggregates");
      }
      constructor() {
        super(...arguments);
        this.currents = new Currents(this._client);
      }
    };
    (function(Aggregates2) {
      Aggregates2.Currents = Currents;
    })(Aggregates || (Aggregates = {}));
  }
});

// node_modules/cloudflare/resources/spectrum/analytics/events/bytimes.mjs
var Bytimes3;
var init_bytimes3 = __esm({
  "node_modules/cloudflare/resources/spectrum/analytics/events/bytimes.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Bytimes3 = class extends APIResource {
      static {
        __name(this, "Bytimes");
      }
      get(zone, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(zone, {}, query);
        }
        return this._client.get(`/zones/${zone}/spectrum/analytics/events/bytime`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Bytimes4) {
    })(Bytimes3 || (Bytimes3 = {}));
  }
});

// node_modules/cloudflare/resources/spectrum/analytics/events/summaries.mjs
var Summaries;
var init_summaries = __esm({
  "node_modules/cloudflare/resources/spectrum/analytics/events/summaries.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Summaries = class extends APIResource {
      static {
        __name(this, "Summaries");
      }
      get(zone, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(zone, {}, query);
        }
        return this._client.get(`/zones/${zone}/spectrum/analytics/events/summary`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Summaries2) {
    })(Summaries || (Summaries = {}));
  }
});

// node_modules/cloudflare/resources/spectrum/analytics/events/events.mjs
var Events3;
var init_events3 = __esm({
  "node_modules/cloudflare/resources/spectrum/analytics/events/events.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_bytimes3();
    init_summaries();
    Events3 = class extends APIResource {
      static {
        __name(this, "Events");
      }
      constructor() {
        super(...arguments);
        this.bytimes = new Bytimes3(this._client);
        this.summaries = new Summaries(this._client);
      }
    };
    (function(Events5) {
      Events5.Bytimes = Bytimes3;
      Events5.Summaries = Summaries;
    })(Events3 || (Events3 = {}));
  }
});

// node_modules/cloudflare/resources/spectrum/analytics/analytics.mjs
var Analytics3;
var init_analytics3 = __esm({
  "node_modules/cloudflare/resources/spectrum/analytics/analytics.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_aggregates();
    init_events3();
    Analytics3 = class extends APIResource {
      static {
        __name(this, "Analytics");
      }
      constructor() {
        super(...arguments);
        this.aggregates = new Aggregates(this._client);
        this.events = new Events3(this._client);
      }
    };
    (function(Analytics5) {
      Analytics5.Aggregates = Aggregates;
      Analytics5.Events = Events3;
    })(Analytics3 || (Analytics3 = {}));
  }
});

// node_modules/cloudflare/resources/spectrum/spectrum.mjs
var Spectrum;
var init_spectrum = __esm({
  "node_modules/cloudflare/resources/spectrum/spectrum.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_apps2();
    init_analytics3();
    Spectrum = class extends APIResource {
      static {
        __name(this, "Spectrum");
      }
      constructor() {
        super(...arguments);
        this.analytics = new Analytics3(this._client);
        this.apps = new Apps2(this._client);
      }
    };
    (function(Spectrum2) {
      Spectrum2.Analytics = Analytics3;
      Spectrum2.Apps = Apps2;
      Spectrum2.AppListResponsesV4PagePaginationArray = AppListResponsesV4PagePaginationArray;
    })(Spectrum || (Spectrum = {}));
  }
});

// node_modules/cloudflare/resources/speed/availabilities.mjs
var Availabilities;
var init_availabilities = __esm({
  "node_modules/cloudflare/resources/speed/availabilities.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Availabilities = class extends APIResource {
      static {
        __name(this, "Availabilities");
      }
      /**
       * Retrieves quota for all plans, as well as the current zone quota.
       */
      list(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/speed_api/availabilities`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Availabilities2) {
    })(Availabilities || (Availabilities = {}));
  }
});

// node_modules/cloudflare/resources/speed/schedule.mjs
var ScheduleResource;
var init_schedule = __esm({
  "node_modules/cloudflare/resources/speed/schedule.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    ScheduleResource = class extends APIResource {
      static {
        __name(this, "ScheduleResource");
      }
      /**
       * Creates a scheduled test for a page.
       */
      create(url, params, options) {
        const { zone_id, region } = params;
        return this._client.post(`/zones/${zone_id}/speed_api/schedule/${url}`, {
          query: { region },
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Deletes a scheduled test for a page.
       */
      delete(url, params, options) {
        const { zone_id, region } = params;
        return this._client.delete(`/zones/${zone_id}/speed_api/schedule/${url}`, {
          query: { region },
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Retrieves the test schedule for a page in a specific region.
       */
      get(url, params, options) {
        const { zone_id, ...query } = params;
        return this._client.get(`/zones/${zone_id}/speed_api/schedule/${url}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(ScheduleResource2) {
    })(ScheduleResource || (ScheduleResource = {}));
  }
});

// node_modules/cloudflare/resources/speed/pages/tests.mjs
var Tests;
var init_tests = __esm({
  "node_modules/cloudflare/resources/speed/pages/tests.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Tests = class extends APIResource {
      static {
        __name(this, "Tests");
      }
      /**
       * Starts a test for a specific webpage, in a specific region.
       */
      create(url, params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/speed_api/pages/${url}/tests`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Test history (list of tests) for a specific webpage.
       */
      list(url, params, options) {
        const { zone_id, ...query } = params;
        return this._client.get(`/zones/${zone_id}/speed_api/pages/${url}/tests`, { query, ...options });
      }
      /**
       * Deletes all tests for a specific webpage from a specific region. Deleted tests
       * are still counted as part of the quota.
       */
      delete(url, params, options) {
        const { zone_id, region } = params;
        return this._client.delete(`/zones/${zone_id}/speed_api/pages/${url}/tests`, {
          query: { region },
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Retrieves the result of a specific test.
       */
      get(url, testId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/speed_api/pages/${url}/tests/${testId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Tests3) {
    })(Tests || (Tests = {}));
  }
});

// node_modules/cloudflare/resources/speed/pages/pages.mjs
var Pages2, PageListResponsesSinglePage;
var init_pages2 = __esm({
  "node_modules/cloudflare/resources/speed/pages/pages.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_pages2();
    init_tests();
    init_pagination();
    Pages2 = class extends APIResource {
      static {
        __name(this, "Pages");
      }
      constructor() {
        super(...arguments);
        this.tests = new Tests(this._client);
      }
      /**
       * Lists all webpages which have been tested.
       */
      list(params, options) {
        const { zone_id } = params;
        return this._client.getAPIList(`/zones/${zone_id}/speed_api/pages`, PageListResponsesSinglePage, options);
      }
      /**
       * Lists the core web vital metrics trend over time for a specific page.
       */
      trend(url, params, options) {
        const { zone_id, ...query } = params;
        return this._client.get(`/zones/${zone_id}/speed_api/pages/${url}/trend`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    PageListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "PageListResponsesSinglePage");
      }
    };
    (function(Pages3) {
      Pages3.PageListResponsesSinglePage = PageListResponsesSinglePage;
      Pages3.Tests = Tests;
    })(Pages2 || (Pages2 = {}));
  }
});

// node_modules/cloudflare/resources/speed/speed.mjs
var Speed2;
var init_speed2 = __esm({
  "node_modules/cloudflare/resources/speed/speed.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_availabilities();
    init_schedule();
    init_pages2();
    Speed2 = class extends APIResource {
      static {
        __name(this, "Speed");
      }
      constructor() {
        super(...arguments);
        this.schedule = new ScheduleResource(this._client);
        this.availabilities = new Availabilities(this._client);
        this.pages = new Pages2(this._client);
      }
    };
    (function(Speed3) {
      Speed3.ScheduleResource = ScheduleResource;
      Speed3.Availabilities = Availabilities;
      Speed3.Pages = Pages2;
      Speed3.PageListResponsesSinglePage = PageListResponsesSinglePage;
    })(Speed2 || (Speed2 = {}));
  }
});

// node_modules/cloudflare/resources/storage/analytics.mjs
var Analytics4;
var init_analytics4 = __esm({
  "node_modules/cloudflare/resources/storage/analytics.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Analytics4 = class extends APIResource {
      static {
        __name(this, "Analytics");
      }
      /**
       * Retrieves Workers KV request metrics for the given account.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/storage/analytics`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Retrieves Workers KV stored data metrics for the given account.
       */
      stored(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/storage/analytics/stored`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Analytics5) {
    })(Analytics4 || (Analytics4 = {}));
  }
});

// node_modules/cloudflare/resources/storage/storage.mjs
var Storage;
var init_storage = __esm({
  "node_modules/cloudflare/resources/storage/storage.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_analytics4();
    Storage = class extends APIResource {
      static {
        __name(this, "Storage");
      }
      constructor() {
        super(...arguments);
        this.analytics = new Analytics4(this._client);
      }
    };
    (function(Storage2) {
      Storage2.Analytics = Analytics4;
    })(Storage || (Storage = {}));
  }
});

// node_modules/cloudflare/resources/stream/audio-tracks.mjs
var AudioTracks;
var init_audio_tracks = __esm({
  "node_modules/cloudflare/resources/stream/audio-tracks.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    AudioTracks = class extends APIResource {
      static {
        __name(this, "AudioTracks");
      }
      /**
       * Deletes additional audio tracks on a video. Deleting a default audio track is
       * not allowed. You must assign another audio track as default prior to deletion.
       */
      delete(identifier, audioIdentifier, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/stream/${identifier}/audio/${audioIdentifier}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Adds an additional audio track to a video using the provided audio track URL.
       */
      copy(identifier, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/stream/${identifier}/audio/copy`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Edits additional audio tracks on a video. Editing the default status of an audio
       * track to `true` will mark all other audio tracks on the video default status to
       * `false`.
       */
      edit(identifier, audioIdentifier, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/stream/${identifier}/audio/${audioIdentifier}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists additional audio tracks on a video. Note this API will not return
       * information for audio attached to the video upload.
       */
      get(identifier, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/stream/${identifier}/audio`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(AudioTracks2) {
    })(AudioTracks || (AudioTracks = {}));
  }
});

// node_modules/cloudflare/resources/stream/clip.mjs
var ClipResource;
var init_clip = __esm({
  "node_modules/cloudflare/resources/stream/clip.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    ClipResource = class extends APIResource {
      static {
        __name(this, "ClipResource");
      }
      /**
       * Clips a video based on the specified start and end times provided in seconds.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/stream/clip`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(ClipResource2) {
    })(ClipResource || (ClipResource = {}));
  }
});

// node_modules/cloudflare/resources/stream/copy.mjs
var Copy;
var init_copy = __esm({
  "node_modules/cloudflare/resources/stream/copy.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Copy = class extends APIResource {
      static {
        __name(this, "Copy");
      }
      /**
       * Uploads a video to Stream from a provided URL.
       */
      create(params, options) {
        const { account_id, "Upload-Creator": uploadCreator, "Upload-Metadata": uploadMetadata, ...body } = params;
        return this._client.post(`/accounts/${account_id}/stream/copy`, {
          body,
          ...options,
          headers: {
            ...uploadCreator != null ? { "Upload-Creator": uploadCreator } : void 0,
            ...uploadMetadata != null ? { "Upload-Metadata": uploadMetadata } : void 0,
            ...options?.headers
          }
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Copy2) {
    })(Copy || (Copy = {}));
  }
});

// node_modules/cloudflare/resources/stream/direct-upload.mjs
var DirectUpload;
var init_direct_upload = __esm({
  "node_modules/cloudflare/resources/stream/direct-upload.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    DirectUpload = class extends APIResource {
      static {
        __name(this, "DirectUpload");
      }
      /**
       * Creates a direct upload that allows video uploads without an API key.
       */
      create(params, options) {
        const { account_id, "Upload-Creator": uploadCreator, ...body } = params;
        return this._client.post(`/accounts/${account_id}/stream/direct_upload`, {
          body,
          ...options,
          headers: {
            ...uploadCreator != null ? { "Upload-Creator": uploadCreator } : void 0,
            ...options?.headers
          }
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(DirectUpload2) {
    })(DirectUpload || (DirectUpload = {}));
  }
});

// node_modules/cloudflare/resources/stream/downloads.mjs
var Downloads2;
var init_downloads2 = __esm({
  "node_modules/cloudflare/resources/stream/downloads.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Downloads2 = class extends APIResource {
      static {
        __name(this, "Downloads");
      }
      /**
       * Creates a download for a video when a video is ready to view.
       */
      create(identifier, params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/stream/${identifier}/downloads`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Delete the downloads for a video.
       */
      delete(identifier, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/stream/${identifier}/downloads`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists the downloads created for a video.
       */
      get(identifier, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/stream/${identifier}/downloads`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Downloads3) {
    })(Downloads2 || (Downloads2 = {}));
  }
});

// node_modules/cloudflare/resources/stream/embed.mjs
var Embed;
var init_embed = __esm({
  "node_modules/cloudflare/resources/stream/embed.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Embed = class extends APIResource {
      static {
        __name(this, "Embed");
      }
      /**
       * Fetches an HTML code snippet to embed a video in a web page delivered through
       * Cloudflare. On success, returns an HTML fragment for use on web pages to display
       * a video. On failure, returns a JSON response body.
       */
      get(identifier, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/stream/${identifier}/embed`, {
          ...options,
          headers: { Accept: "application/json", ...options?.headers }
        });
      }
    };
    /* @__PURE__ */ (function(Embed2) {
    })(Embed || (Embed = {}));
  }
});

// node_modules/cloudflare/resources/stream/keys.mjs
var Keys4;
var init_keys4 = __esm({
  "node_modules/cloudflare/resources/stream/keys.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_keys4();
    Keys4 = class extends APIResource {
      static {
        __name(this, "Keys");
      }
      /**
       * Creates an RSA private key in PEM and JWK formats. Key files are only displayed
       * once after creation. Keys are created, used, and deleted independently of
       * videos, and every key can sign any video.
       */
      create(params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/stream/keys`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Deletes signing keys and revokes all signed URLs generated with the key.
       */
      delete(identifier, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/stream/keys/${identifier}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists the video ID and creation date and time when a signing key was created.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/stream/keys`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Keys6) {
      Keys6.Keys = Keys4;
    })(Keys4 || (Keys4 = {}));
  }
});

// node_modules/cloudflare/resources/stream/token.mjs
var Token;
var init_token = __esm({
  "node_modules/cloudflare/resources/stream/token.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Token = class extends APIResource {
      static {
        __name(this, "Token");
      }
      /**
       * Creates a signed URL token for a video. If a body is not provided in the
       * request, a token is created with default values.
       */
      create(identifier, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/stream/${identifier}/token`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Token3) {
    })(Token || (Token = {}));
  }
});

// node_modules/cloudflare/resources/stream/videos.mjs
var Videos;
var init_videos = __esm({
  "node_modules/cloudflare/resources/stream/videos.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Videos = class extends APIResource {
      static {
        __name(this, "Videos");
      }
      /**
       * Returns information about an account's storage use.
       */
      storageUsage(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/stream/storage-usage`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Videos2) {
    })(Videos || (Videos = {}));
  }
});

// node_modules/cloudflare/resources/stream/watermarks.mjs
var Watermarks, WatermarksSinglePage;
var init_watermarks = __esm({
  "node_modules/cloudflare/resources/stream/watermarks.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_watermarks();
    init_pagination();
    Watermarks = class extends APIResource {
      static {
        __name(this, "Watermarks");
      }
      /**
       * Creates watermark profiles using a single `HTTP POST multipart/form-data`
       * request.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/stream/watermarks`, multipartFormRequestOptions({ body, ...options }))._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists all watermark profiles for an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/stream/watermarks`, WatermarksSinglePage, options);
      }
      /**
       * Deletes a watermark profile.
       */
      delete(identifier, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/stream/watermarks/${identifier}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Retrieves details for a single watermark profile.
       */
      get(identifier, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/stream/watermarks/${identifier}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    WatermarksSinglePage = class extends SinglePage {
      static {
        __name(this, "WatermarksSinglePage");
      }
    };
    (function(Watermarks2) {
      Watermarks2.WatermarksSinglePage = WatermarksSinglePage;
    })(Watermarks || (Watermarks = {}));
  }
});

// node_modules/cloudflare/resources/stream/webhooks.mjs
var Webhooks2;
var init_webhooks2 = __esm({
  "node_modules/cloudflare/resources/stream/webhooks.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Webhooks2 = class extends APIResource {
      static {
        __name(this, "Webhooks");
      }
      /**
       * Creates a webhook notification.
       */
      update(params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/stream/webhook`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Deletes a webhook.
       */
      delete(params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/stream/webhook`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Retrieves a list of webhooks.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/stream/webhook`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Webhooks3) {
    })(Webhooks2 || (Webhooks2 = {}));
  }
});

// node_modules/cloudflare/resources/stream/captions/language/vtt.mjs
var Vtt;
var init_vtt = __esm({
  "node_modules/cloudflare/resources/stream/captions/language/vtt.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Vtt = class extends APIResource {
      static {
        __name(this, "Vtt");
      }
      /**
       * Return WebVTT captions for a provided language.
       */
      get(identifier, language, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/stream/${identifier}/captions/${language}/vtt`, {
          ...options,
          headers: { Accept: "text/vtt", ...options?.headers }
        });
      }
    };
    /* @__PURE__ */ (function(Vtt2) {
    })(Vtt || (Vtt = {}));
  }
});

// node_modules/cloudflare/resources/stream/captions/language/language.mjs
var Language;
var init_language = __esm({
  "node_modules/cloudflare/resources/stream/captions/language/language.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_vtt();
    Language = class extends APIResource {
      static {
        __name(this, "Language");
      }
      constructor() {
        super(...arguments);
        this.vtt = new Vtt(this._client);
      }
      /**
       * Generate captions or subtitles for provided language via AI.
       */
      create(identifier, language, params, options) {
        const { account_id } = params;
        return this._client.post(`/accounts/${account_id}/stream/${identifier}/captions/${language}/generate`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Uploads the caption or subtitle file to the endpoint for a specific BCP47
       * language. One caption or subtitle file per language is allowed.
       */
      update(identifier, language, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/stream/${identifier}/captions/${language}`, multipartFormRequestOptions({ body, ...options }))._thenUnwrap((obj) => obj.result);
      }
      /**
       * Removes the captions or subtitles from a video.
       */
      delete(identifier, language, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/stream/${identifier}/captions/${language}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists the captions or subtitles for provided language.
       */
      get(identifier, language, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/stream/${identifier}/captions/${language}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Language2) {
      Language2.Vtt = Vtt;
    })(Language || (Language = {}));
  }
});

// node_modules/cloudflare/resources/stream/captions/captions.mjs
var Captions;
var init_captions = __esm({
  "node_modules/cloudflare/resources/stream/captions/captions.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_language();
    Captions = class extends APIResource {
      static {
        __name(this, "Captions");
      }
      constructor() {
        super(...arguments);
        this.language = new Language(this._client);
      }
      /**
       * Lists the available captions or subtitles for a specific video.
       */
      get(identifier, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/stream/${identifier}/captions`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Captions2) {
      Captions2.Language = Language;
    })(Captions || (Captions = {}));
  }
});

// node_modules/cloudflare/resources/stream/live-inputs/outputs.mjs
var Outputs, OutputsSinglePage;
var init_outputs = __esm({
  "node_modules/cloudflare/resources/stream/live-inputs/outputs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_outputs();
    init_pagination();
    Outputs = class extends APIResource {
      static {
        __name(this, "Outputs");
      }
      /**
       * Creates a new output that can be used to simulcast or restream live video to
       * other RTMP or SRT destinations. Outputs are always linked to a specific live
       * input one live input can have many outputs.
       */
      create(liveInputIdentifier, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/stream/live_inputs/${liveInputIdentifier}/outputs`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates the state of an output.
       */
      update(liveInputIdentifier, outputIdentifier, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/stream/live_inputs/${liveInputIdentifier}/outputs/${outputIdentifier}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Retrieves all outputs associated with a specified live input.
       */
      list(liveInputIdentifier, params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/stream/live_inputs/${liveInputIdentifier}/outputs`, OutputsSinglePage, options);
      }
      /**
       * Deletes an output and removes it from the associated live input.
       */
      delete(liveInputIdentifier, outputIdentifier, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/stream/live_inputs/${liveInputIdentifier}/outputs/${outputIdentifier}`, { ...options, headers: { Accept: "*/*", ...options?.headers } });
      }
    };
    OutputsSinglePage = class extends SinglePage {
      static {
        __name(this, "OutputsSinglePage");
      }
    };
    (function(Outputs2) {
      Outputs2.OutputsSinglePage = OutputsSinglePage;
    })(Outputs || (Outputs = {}));
  }
});

// node_modules/cloudflare/resources/stream/live-inputs/live-inputs.mjs
var LiveInputs;
var init_live_inputs = __esm({
  "node_modules/cloudflare/resources/stream/live-inputs/live-inputs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_outputs();
    LiveInputs = class extends APIResource {
      static {
        __name(this, "LiveInputs");
      }
      constructor() {
        super(...arguments);
        this.outputs = new Outputs(this._client);
      }
      /**
       * Creates a live input, and returns credentials that you or your users can use to
       * stream live video to Cloudflare Stream.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/stream/live_inputs`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a specified live input.
       */
      update(liveInputIdentifier, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/stream/live_inputs/${liveInputIdentifier}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists the live inputs created for an account. To get the credentials needed to
       * stream to a specific live input, request a single live input.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/stream/live_inputs`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Prevents a live input from being streamed to and makes the live input
       * inaccessible to any future API calls.
       */
      delete(liveInputIdentifier, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/stream/live_inputs/${liveInputIdentifier}`, {
          ...options,
          headers: { Accept: "*/*", ...options?.headers }
        });
      }
      /**
       * Retrieves details of an existing live input.
       */
      get(liveInputIdentifier, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/stream/live_inputs/${liveInputIdentifier}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(LiveInputs2) {
      LiveInputs2.Outputs = Outputs;
      LiveInputs2.OutputsSinglePage = OutputsSinglePage;
    })(LiveInputs || (LiveInputs = {}));
  }
});

// node_modules/cloudflare/resources/stream/stream.mjs
var Stream, VideosSinglePage;
var init_stream = __esm({
  "node_modules/cloudflare/resources/stream/stream.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_audio_tracks();
    init_clip();
    init_copy();
    init_direct_upload();
    init_downloads2();
    init_embed();
    init_keys4();
    init_token();
    init_videos();
    init_watermarks();
    init_webhooks2();
    init_captions();
    init_live_inputs();
    init_pagination();
    Stream = class extends APIResource {
      static {
        __name(this, "Stream");
      }
      constructor() {
        super(...arguments);
        this.audioTracks = new AudioTracks(this._client);
        this.videos = new Videos(this._client);
        this.clip = new ClipResource(this._client);
        this.copy = new Copy(this._client);
        this.directUpload = new DirectUpload(this._client);
        this.keys = new Keys4(this._client);
        this.liveInputs = new LiveInputs(this._client);
        this.watermarks = new Watermarks(this._client);
        this.webhooks = new Webhooks2(this._client);
        this.captions = new Captions(this._client);
        this.downloads = new Downloads2(this._client);
        this.embed = new Embed(this._client);
        this.token = new Token(this._client);
      }
      /**
       * Initiates a video upload using the TUS protocol. On success, the server responds
       * with a status code 201 (created) and includes a `location` header to indicate
       * where the content should be uploaded. Refer to https://tus.io for protocol
       * details.
       */
      create(params, options) {
        const { account_id, body, "Tus-Resumable": tusResumable, "Upload-Length": uploadLength, "Upload-Creator": uploadCreator, "Upload-Metadata": uploadMetadata } = params;
        return this._client.post(`/accounts/${account_id}/stream`, {
          body,
          ...options,
          headers: {
            Accept: "*/*",
            "Tus-Resumable": tusResumable.toString(),
            "Upload-Length": uploadLength.toString(),
            ...uploadCreator != null ? { "Upload-Creator": uploadCreator } : void 0,
            ...uploadMetadata != null ? { "Upload-Metadata": uploadMetadata } : void 0,
            ...options?.headers
          }
        });
      }
      /**
       * Lists up to 1000 videos from a single request. For a specific range, refer to
       * the optional parameters.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/stream`, VideosSinglePage, { query, ...options });
      }
      /**
       * Deletes a video and its copies from Cloudflare Stream.
       */
      delete(identifier, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/stream/${identifier}`, {
          ...options,
          headers: { Accept: "*/*", ...options?.headers }
        });
      }
      /**
       * Fetches details for a single video.
       */
      get(identifier, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/stream/${identifier}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    VideosSinglePage = class extends SinglePage {
      static {
        __name(this, "VideosSinglePage");
      }
    };
    (function(Stream2) {
      Stream2.AudioTracks = AudioTracks;
      Stream2.Videos = Videos;
      Stream2.ClipResource = ClipResource;
      Stream2.Copy = Copy;
      Stream2.DirectUpload = DirectUpload;
      Stream2.Keys = Keys4;
      Stream2.LiveInputs = LiveInputs;
      Stream2.Watermarks = Watermarks;
      Stream2.WatermarksSinglePage = WatermarksSinglePage;
      Stream2.Webhooks = Webhooks2;
      Stream2.Captions = Captions;
      Stream2.Downloads = Downloads2;
      Stream2.Embed = Embed;
      Stream2.Token = Token;
    })(Stream || (Stream = {}));
  }
});

// node_modules/cloudflare/resources/user/subscriptions.mjs
var Subscriptions, SubscriptionsSinglePage;
var init_subscriptions = __esm({
  "node_modules/cloudflare/resources/user/subscriptions.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_pagination();
    Subscriptions = class extends APIResource {
      static {
        __name(this, "Subscriptions");
      }
      /**
       * Updates a user's subscriptions.
       */
      update(identifier, body, options) {
        return this._client.put(`/user/subscriptions/${identifier}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Deletes a user's subscription.
       */
      delete(identifier, options) {
        return this._client.delete(`/user/subscriptions/${identifier}`, options);
      }
      /**
       * Updates zone subscriptions, either plan or add-ons.
       */
      edit(identifier, body, options) {
        return this._client.put(`/zones/${identifier}/subscription`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists all of a user's subscriptions.
       */
      get(options) {
        return this._client.get("/user/subscriptions", options)._thenUnwrap((obj) => obj.result);
      }
    };
    SubscriptionsSinglePage = class extends SinglePage {
      static {
        __name(this, "SubscriptionsSinglePage");
      }
    };
    /* @__PURE__ */ (function(Subscriptions4) {
    })(Subscriptions || (Subscriptions = {}));
  }
});

// node_modules/cloudflare/resources/subscriptions.mjs
var Subscriptions2;
var init_subscriptions2 = __esm({
  "node_modules/cloudflare/resources/subscriptions.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_subscriptions();
    Subscriptions2 = class extends APIResource {
      static {
        __name(this, "Subscriptions");
      }
      /**
       * Create a zone subscription, either plan or add-ons.
       */
      create(identifier, body, options) {
        return this._client.post(`/zones/${identifier}/subscription`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an account subscription.
       */
      update(accountIdentifier, subscriptionIdentifier, body, options) {
        return this._client.put(`/accounts/${accountIdentifier}/subscriptions/${subscriptionIdentifier}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists all of an account's subscriptions.
       */
      list(accountIdentifier, options) {
        return this._client.getAPIList(`/accounts/${accountIdentifier}/subscriptions`, SubscriptionsSinglePage, options);
      }
      /**
       * Deletes an account's subscription.
       */
      delete(accountIdentifier, subscriptionIdentifier, options) {
        return this._client.delete(`/accounts/${accountIdentifier}/subscriptions/${subscriptionIdentifier}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists zone subscription details.
       */
      get(identifier, options) {
        return this._client.get(`/zones/${identifier}/subscription`, options)._thenUnwrap((obj) => obj.result);
      }
    };
  }
});

// node_modules/cloudflare/resources/url-normalization.mjs
var URLNormalization;
var init_url_normalization = __esm({
  "node_modules/cloudflare/resources/url-normalization.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    URLNormalization = class extends APIResource {
      static {
        __name(this, "URLNormalization");
      }
      /**
       * Updates the URL normalization settings.
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/url_normalization`, { body, ...options });
      }
      /**
       * Fetches the current URL normalization settings.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/url_normalization`, options);
      }
    };
  }
});

// node_modules/cloudflare/resources/url-scanner/scans.mjs
var Scans;
var init_scans = __esm({
  "node_modules/cloudflare/resources/url-scanner/scans.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Scans = class extends APIResource {
      static {
        __name(this, "Scans");
      }
      /**
       * Submit a URL to scan. You can also set some options, like the visibility level
       * and custom headers. Accounts are limited to 1 new scan every 10 seconds and 8000
       * per month. If you need more, please reach out.
       */
      create(accountId, body, options) {
        return this._client.post(`/accounts/${accountId}/urlscanner/scan`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      get(accountId, scanId, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(accountId, scanId, {}, query);
        }
        return this._client.get(`/accounts/${accountId}/urlscanner/scan/${scanId}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a URL scan's HAR file. See HAR spec at
       * http://www.softwareishard.com/blog/har-12-spec/.
       */
      har(accountId, scanId, options) {
        return this._client.get(`/accounts/${accountId}/urlscanner/scan/${scanId}/har`, options)._thenUnwrap((obj) => obj.result);
      }
      screenshot(accountId, scanId, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.screenshot(accountId, scanId, {}, query);
        }
        return this._client.get(`/accounts/${accountId}/urlscanner/scan/${scanId}/screenshot`, {
          query,
          ...options,
          __binaryResponse: true
        });
      }
    };
    /* @__PURE__ */ (function(Scans2) {
    })(Scans || (Scans = {}));
  }
});

// node_modules/cloudflare/resources/url-scanner/url-scanner.mjs
var URLScanner;
var init_url_scanner = __esm({
  "node_modules/cloudflare/resources/url-scanner/url-scanner.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_scans();
    URLScanner = class extends APIResource {
      static {
        __name(this, "URLScanner");
      }
      constructor() {
        super(...arguments);
        this.scans = new Scans(this._client);
      }
      scan(accountId, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.scan(accountId, {}, query);
        }
        return this._client.get(`/accounts/${accountId}/urlscanner/scan`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(URLScanner2) {
      URLScanner2.Scans = Scans;
    })(URLScanner || (URLScanner = {}));
  }
});

// node_modules/cloudflare/resources/user/audit-logs.mjs
var AuditLogs2;
var init_audit_logs2 = __esm({
  "node_modules/cloudflare/resources/user/audit-logs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_shared();
    AuditLogs2 = class extends APIResource {
      static {
        __name(this, "AuditLogs");
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/user/audit_logs", AuditLogsV4PagePaginationArray, { query, ...options });
      }
    };
    /* @__PURE__ */ (function(AuditLogs3) {
    })(AuditLogs2 || (AuditLogs2 = {}));
  }
});

// node_modules/cloudflare/resources/user/invites.mjs
var Invites, InvitesSinglePage;
var init_invites = __esm({
  "node_modules/cloudflare/resources/user/invites.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_invites();
    init_pagination();
    Invites = class extends APIResource {
      static {
        __name(this, "Invites");
      }
      /**
       * Lists all invitations associated with my user.
       */
      list(options) {
        return this._client.getAPIList("/user/invites", InvitesSinglePage, options);
      }
      /**
       * Responds to an invitation.
       */
      edit(inviteId, body, options) {
        return this._client.patch(`/user/invites/${inviteId}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Gets the details of an invitation.
       */
      get(inviteId, options) {
        return this._client.get(`/user/invites/${inviteId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    InvitesSinglePage = class extends SinglePage {
      static {
        __name(this, "InvitesSinglePage");
      }
    };
    (function(Invites2) {
      Invites2.InvitesSinglePage = InvitesSinglePage;
    })(Invites || (Invites = {}));
  }
});

// node_modules/cloudflare/resources/user/organizations.mjs
var Organizations, OrganizationsV4PagePaginationArray;
var init_organizations = __esm({
  "node_modules/cloudflare/resources/user/organizations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_organizations();
    init_pagination();
    Organizations = class extends APIResource {
      static {
        __name(this, "Organizations");
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/user/organizations", OrganizationsV4PagePaginationArray, {
          query,
          ...options
        });
      }
      /**
       * Removes association to an organization.
       */
      delete(organizationId, options) {
        return this._client.delete(`/user/organizations/${organizationId}`, options);
      }
      /**
       * Gets a specific organization the user is associated with.
       */
      get(organizationId, options) {
        return this._client.get(`/user/organizations/${organizationId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    OrganizationsV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "OrganizationsV4PagePaginationArray");
      }
    };
    (function(Organizations3) {
      Organizations3.OrganizationsV4PagePaginationArray = OrganizationsV4PagePaginationArray;
    })(Organizations || (Organizations = {}));
  }
});

// node_modules/cloudflare/resources/user/billing/history.mjs
var History2, BillingHistoriesV4PagePaginationArray;
var init_history3 = __esm({
  "node_modules/cloudflare/resources/user/billing/history.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_history3();
    init_pagination();
    History2 = class extends APIResource {
      static {
        __name(this, "History");
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/user/billing/history", BillingHistoriesV4PagePaginationArray, {
          query,
          ...options
        });
      }
    };
    BillingHistoriesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "BillingHistoriesV4PagePaginationArray");
      }
    };
    (function(History3) {
      History3.BillingHistoriesV4PagePaginationArray = BillingHistoriesV4PagePaginationArray;
    })(History2 || (History2 = {}));
  }
});

// node_modules/cloudflare/resources/user/billing/profile.mjs
var Profile;
var init_profile = __esm({
  "node_modules/cloudflare/resources/user/billing/profile.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Profile = class extends APIResource {
      static {
        __name(this, "Profile");
      }
      /**
       * Accesses your billing profile object.
       */
      get(options) {
        return this._client.get("/user/billing/profile", options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Profile2) {
    })(Profile || (Profile = {}));
  }
});

// node_modules/cloudflare/resources/user/billing/billing.mjs
var Billing2;
var init_billing2 = __esm({
  "node_modules/cloudflare/resources/user/billing/billing.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_history3();
    init_profile();
    Billing2 = class extends APIResource {
      static {
        __name(this, "Billing");
      }
      constructor() {
        super(...arguments);
        this.history = new History2(this._client);
        this.profile = new Profile(this._client);
      }
    };
    (function(Billing3) {
      Billing3.History = History2;
      Billing3.BillingHistoriesV4PagePaginationArray = BillingHistoriesV4PagePaginationArray;
      Billing3.Profile = Profile;
    })(Billing2 || (Billing2 = {}));
  }
});

// node_modules/cloudflare/resources/user/tokens/permission-groups.mjs
var PermissionGroups2, PermissionGroupListResponsesSinglePage;
var init_permission_groups2 = __esm({
  "node_modules/cloudflare/resources/user/tokens/permission-groups.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_permission_groups2();
    init_pagination();
    PermissionGroups2 = class extends APIResource {
      static {
        __name(this, "PermissionGroups");
      }
      /**
       * Find all available permission groups for API Tokens
       */
      list(options) {
        return this._client.getAPIList("/user/tokens/permission_groups", PermissionGroupListResponsesSinglePage, options);
      }
    };
    PermissionGroupListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "PermissionGroupListResponsesSinglePage");
      }
    };
    (function(PermissionGroups3) {
      PermissionGroups3.PermissionGroupListResponsesSinglePage = PermissionGroupListResponsesSinglePage;
    })(PermissionGroups2 || (PermissionGroups2 = {}));
  }
});

// node_modules/cloudflare/resources/user/tokens/value.mjs
var ValueResource;
var init_value = __esm({
  "node_modules/cloudflare/resources/user/tokens/value.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    ValueResource = class extends APIResource {
      static {
        __name(this, "ValueResource");
      }
      /**
       * Roll the token secret.
       */
      update(tokenId, body, options) {
        return this._client.put(`/user/tokens/${tokenId}/value`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(ValueResource2) {
    })(ValueResource || (ValueResource = {}));
  }
});

// node_modules/cloudflare/resources/user/tokens/tokens.mjs
var Tokens, TokenListResponsesV4PagePaginationArray;
var init_tokens = __esm({
  "node_modules/cloudflare/resources/user/tokens/tokens.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_tokens();
    init_permission_groups2();
    init_value();
    init_pagination();
    Tokens = class extends APIResource {
      static {
        __name(this, "Tokens");
      }
      constructor() {
        super(...arguments);
        this.permissionGroups = new PermissionGroups2(this._client);
        this.value = new ValueResource(this._client);
      }
      /**
       * Create a new access token.
       */
      create(body, options) {
        return this._client.post("/user/tokens", { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update an existing token.
       */
      update(tokenId, body, options) {
        return this._client.put(`/user/tokens/${tokenId}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/user/tokens", TokenListResponsesV4PagePaginationArray, {
          query,
          ...options
        });
      }
      /**
       * Destroy a token.
       */
      delete(tokenId, options) {
        return this._client.delete(`/user/tokens/${tokenId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get information about a specific token.
       */
      get(tokenId, options) {
        return this._client.get(`/user/tokens/${tokenId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Test whether a token works.
       */
      verify(options) {
        return this._client.get("/user/tokens/verify", options)._thenUnwrap((obj) => obj.result);
      }
    };
    TokenListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "TokenListResponsesV4PagePaginationArray");
      }
    };
    (function(Tokens2) {
      Tokens2.TokenListResponsesV4PagePaginationArray = TokenListResponsesV4PagePaginationArray;
      Tokens2.PermissionGroups = PermissionGroups2;
      Tokens2.PermissionGroupListResponsesSinglePage = PermissionGroupListResponsesSinglePage;
      Tokens2.ValueResource = ValueResource;
    })(Tokens || (Tokens = {}));
  }
});

// node_modules/cloudflare/resources/user/user.mjs
var User;
var init_user = __esm({
  "node_modules/cloudflare/resources/user/user.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_audit_logs2();
    init_invites();
    init_organizations();
    init_subscriptions();
    init_billing2();
    init_tokens();
    User = class extends APIResource {
      static {
        __name(this, "User");
      }
      constructor() {
        super(...arguments);
        this.auditLogs = new AuditLogs2(this._client);
        this.billing = new Billing2(this._client);
        this.invites = new Invites(this._client);
        this.organizations = new Organizations(this._client);
        this.subscriptions = new Subscriptions(this._client);
        this.tokens = new Tokens(this._client);
      }
      /**
       * Edit part of your user details.
       */
      edit(body, options) {
        return this._client.patch("/user", { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * User Details
       */
      get(options) {
        return this._client.get("/user", options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(User2) {
      User2.AuditLogs = AuditLogs2;
      User2.Billing = Billing2;
      User2.Invites = Invites;
      User2.InvitesSinglePage = InvitesSinglePage;
      User2.Organizations = Organizations;
      User2.OrganizationsV4PagePaginationArray = OrganizationsV4PagePaginationArray;
      User2.Subscriptions = Subscriptions;
      User2.Tokens = Tokens;
      User2.TokenListResponsesV4PagePaginationArray = TokenListResponsesV4PagePaginationArray;
    })(User || (User = {}));
  }
});

// node_modules/cloudflare/resources/vectorize/indexes.mjs
var Indexes, CreateIndicesSinglePage;
var init_indexes = __esm({
  "node_modules/cloudflare/resources/vectorize/indexes.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_indexes();
    init_pagination();
    Indexes = class extends APIResource {
      static {
        __name(this, "Indexes");
      }
      /**
       * Creates and returns a new Vectorize Index.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/vectorize/indexes`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates and returns the specified Vectorize Index.
       */
      update(indexName, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/vectorize/indexes/${indexName}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Returns a list of Vectorize Indexes
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/vectorize/indexes`, CreateIndicesSinglePage, options);
      }
      /**
       * Deletes the specified Vectorize Index.
       */
      delete(indexName, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/vectorize/indexes/${indexName}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Delete a set of vectors from an index by their vector identifiers.
       */
      deleteByIds(indexName, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/vectorize/indexes/${indexName}/delete-by-ids`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Returns the specified Vectorize Index.
       */
      get(indexName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/vectorize/indexes/${indexName}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a set of vectors from an index by their vector identifiers.
       */
      getByIds(indexName, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/vectorize/indexes/${indexName}/get-by-ids`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Inserts vectors into the specified index and returns the count of the vectors
       * successfully inserted.
       */
      insert(indexName, params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/vectorize/indexes/${indexName}/insert`, {
          body,
          ...options,
          headers: { "Content-Type": "application/x-ndjson", ...options?.headers },
          __binaryRequest: true
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Finds vectors closest to a given vector in an index.
       */
      query(indexName, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/vectorize/indexes/${indexName}/query`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Upserts vectors into the specified index, creating them if they do not exist and
       * returns the count of values and ids successfully inserted.
       */
      upsert(indexName, params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/vectorize/indexes/${indexName}/upsert`, {
          body,
          ...options,
          headers: { "Content-Type": "application/x-ndjson", ...options?.headers },
          __binaryRequest: true
        })._thenUnwrap((obj) => obj.result);
      }
    };
    CreateIndicesSinglePage = class extends SinglePage {
      static {
        __name(this, "CreateIndicesSinglePage");
      }
    };
    (function(Indexes2) {
      Indexes2.CreateIndicesSinglePage = CreateIndicesSinglePage;
    })(Indexes || (Indexes = {}));
  }
});

// node_modules/cloudflare/resources/vectorize/vectorize.mjs
var Vectorize;
var init_vectorize = __esm({
  "node_modules/cloudflare/resources/vectorize/vectorize.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_indexes();
    Vectorize = class extends APIResource {
      static {
        __name(this, "Vectorize");
      }
      constructor() {
        super(...arguments);
        this.indexes = new Indexes(this._client);
      }
    };
    (function(Vectorize2) {
      Vectorize2.Indexes = Indexes;
      Vectorize2.CreateIndicesSinglePage = CreateIndicesSinglePage;
    })(Vectorize || (Vectorize = {}));
  }
});

// node_modules/cloudflare/resources/warp-connector.mjs
var WARPConnector, WARPConnectorListResponsesV4PagePaginationArray;
var init_warp_connector = __esm({
  "node_modules/cloudflare/resources/warp-connector.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_pagination();
    WARPConnector = class extends APIResource {
      static {
        __name(this, "WARPConnector");
      }
      /**
       * Creates a new Warp Connector Tunnel in an account.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/warp_connector`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists and filters Warp Connector Tunnels in an account.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/warp_connector`, WARPConnectorListResponsesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Deletes a Warp Connector Tunnel from an account.
       */
      delete(tunnelId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/warp_connector/${tunnelId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an existing Warp Connector Tunnel.
       */
      edit(tunnelId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/warp_connector/${tunnelId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a single Warp Connector Tunnel.
       */
      get(tunnelId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/warp_connector/${tunnelId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Gets the token used to associate warp device with a specific Warp Connector
       * tunnel.
       */
      token(tunnelId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/warp_connector/${tunnelId}/token`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    WARPConnectorListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "WARPConnectorListResponsesV4PagePaginationArray");
      }
    };
  }
});

// node_modules/cloudflare/resources/waiting-rooms/page.mjs
var Page;
var init_page = __esm({
  "node_modules/cloudflare/resources/waiting-rooms/page.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Page = class extends APIResource {
      static {
        __name(this, "Page");
      }
      /**
       * Creates a waiting room page preview. Upload a custom waiting room page for
       * preview. You will receive a preview URL in the form
       * `http://waitingrooms.dev/preview/<uuid>`. You can use the following query
       * parameters to change the state of the preview:
       *
       * 1. `force_queue`: Boolean indicating if all users will be queued in the waiting
       *    room and no one will be let into the origin website (also known as queueAll).
       * 2. `queue_is_full`: Boolean indicating if the waiting room's queue is currently
       *    full and not accepting new users at the moment.
       * 3. `queueing_method`: The queueing method currently used by the waiting room.
       *    - **fifo** indicates a FIFO queue.
       *    - **random** indicates a Random queue.
       *    - **passthrough** indicates a Passthrough queue. Keep in mind that the
       *      waiting room page will only be displayed if `force_queue=true` or
       *      `event=prequeueing`  for other cases the request will pass through to the
       *      origin. For our preview, this will be a fake origin website returning
       *      "Welcome".
       *    - **reject** indicates a Reject queue.
       * 4. `event`: Used to preview a waiting room event.
       *    - **none** indicates no event is occurring.
       *    - **prequeueing** indicates that an event is prequeueing (between
       *      `prequeue_start_time` and `event_start_time`).
       *    - **started** indicates that an event has started (between `event_start_time`
       *      and `event_end_time`).
       * 5. `shuffle_at_event_start`: Boolean indicating if the event will shuffle users
       *    in the prequeue when it starts. This can only be set to **true** if an event
       *    is active (`event` is not **none**).
       *
       * For example, you can make a request to
       * `http://waitingrooms.dev/preview/<uuid>?force_queue=false&queue_is_full=false&queueing_method=random&event=started&shuffle_at_event_start=true` 6.
       * `waitTime`: Non-zero, positive integer indicating the estimated wait time in
       * minutes. The default value is 10 minutes.
       *
       * For example, you can make a request to
       * `http://waitingrooms.dev/preview/<uuid>?waitTime=50` to configure the estimated
       * wait time as 50 minutes.
       */
      preview(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/waiting_rooms/preview`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Page2) {
    })(Page || (Page = {}));
  }
});

// node_modules/cloudflare/resources/waiting-rooms/rules.mjs
var Rules10, WaitingRoomRulesSinglePage;
var init_rules10 = __esm({
  "node_modules/cloudflare/resources/waiting-rooms/rules.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_rules10();
    init_pagination();
    Rules10 = class extends APIResource {
      static {
        __name(this, "Rules");
      }
      /**
       * Only available for the Waiting Room Advanced subscription. Creates a rule for a
       * waiting room.
       */
      create(waitingRoomId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}/rules`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Only available for the Waiting Room Advanced subscription. Replaces all rules
       * for a waiting room.
       */
      update(waitingRoomId, params, options) {
        const { zone_id, body } = params;
        return this._client.put(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}/rules`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists rules for a waiting room.
       */
      list(waitingRoomId, params, options) {
        const { zone_id } = params;
        return this._client.getAPIList(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}/rules`, WaitingRoomRulesSinglePage, options);
      }
      /**
       * Deletes a rule for a waiting room.
       */
      delete(waitingRoomId, ruleId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}/rules/${ruleId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Patches a rule for a waiting room.
       */
      edit(waitingRoomId, ruleId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}/rules/${ruleId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    WaitingRoomRulesSinglePage = class extends SinglePage {
      static {
        __name(this, "WaitingRoomRulesSinglePage");
      }
    };
    (function(Rules12) {
      Rules12.WaitingRoomRulesSinglePage = WaitingRoomRulesSinglePage;
    })(Rules10 || (Rules10 = {}));
  }
});

// node_modules/cloudflare/resources/waiting-rooms/settings.mjs
var Settings7;
var init_settings7 = __esm({
  "node_modules/cloudflare/resources/waiting-rooms/settings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Settings7 = class extends APIResource {
      static {
        __name(this, "Settings");
      }
      /**
       * Update zone-level Waiting Room settings
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/waiting_rooms/settings`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Patch zone-level Waiting Room settings
       */
      edit(params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/waiting_rooms/settings`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get zone-level Waiting Room settings
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/waiting_rooms/settings`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Settings13) {
    })(Settings7 || (Settings7 = {}));
  }
});

// node_modules/cloudflare/resources/waiting-rooms/statuses.mjs
var Statuses2;
var init_statuses2 = __esm({
  "node_modules/cloudflare/resources/waiting-rooms/statuses.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Statuses2 = class extends APIResource {
      static {
        __name(this, "Statuses");
      }
      /**
       * Fetches the status of a configured waiting room. Response fields include:
       *
       * 1. `status`: String indicating the status of the waiting room. The possible
       *    status are:
       *    - **not_queueing** indicates that the configured thresholds have not been met
       *      and all users are going through to the origin.
       *    - **queueing** indicates that the thresholds have been met and some users are
       *      held in the waiting room.
       *    - **event_prequeueing** indicates that an event is active and is currently
       *      prequeueing users before it starts.
       * 2. `event_id`: String of the current event's `id` if an event is active,
       *    otherwise an empty string.
       * 3. `estimated_queued_users`: Integer of the estimated number of users currently
       *    waiting in the queue.
       * 4. `estimated_total_active_users`: Integer of the estimated number of users
       *    currently active on the origin.
       * 5. `max_estimated_time_minutes`: Integer of the maximum estimated time currently
       *    presented to the users.
       */
      get(waitingRoomId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}/status`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Statuses3) {
    })(Statuses2 || (Statuses2 = {}));
  }
});

// node_modules/cloudflare/resources/waiting-rooms/events/details.mjs
var Details;
var init_details = __esm({
  "node_modules/cloudflare/resources/waiting-rooms/events/details.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Details = class extends APIResource {
      static {
        __name(this, "Details");
      }
      /**
       * Previews an event's configuration as if it was active. Inherited fields from the
       * waiting room will be displayed with their current values.
       */
      get(waitingRoomId, eventId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}/events/${eventId}/details`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Details2) {
    })(Details || (Details = {}));
  }
});

// node_modules/cloudflare/resources/waiting-rooms/events/events.mjs
var Events4, EventsSinglePage;
var init_events4 = __esm({
  "node_modules/cloudflare/resources/waiting-rooms/events/events.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_events4();
    init_details();
    init_pagination();
    Events4 = class extends APIResource {
      static {
        __name(this, "Events");
      }
      constructor() {
        super(...arguments);
        this.details = new Details(this._client);
      }
      /**
       * Only available for the Waiting Room Advanced subscription. Creates an event for
       * a waiting room. An event takes place during a specified period of time,
       * temporarily changing the behavior of a waiting room. While the event is active,
       * some of the properties in the event's configuration may either override or
       * inherit from the waiting room's configuration. Note that events cannot overlap
       * with each other, so only one event can be active at a time.
       */
      create(waitingRoomId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}/events`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a configured event for a waiting room.
       */
      update(waitingRoomId, eventId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}/events/${eventId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists events for a waiting room.
       */
      list(waitingRoomId, params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}/events`, EventsSinglePage, { query, ...options });
      }
      /**
       * Deletes an event for a waiting room.
       */
      delete(waitingRoomId, eventId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}/events/${eventId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Patches a configured event for a waiting room.
       */
      edit(waitingRoomId, eventId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}/events/${eventId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a single configured event for a waiting room.
       */
      get(waitingRoomId, eventId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}/events/${eventId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    EventsSinglePage = class extends SinglePage {
      static {
        __name(this, "EventsSinglePage");
      }
    };
    (function(Events5) {
      Events5.EventsSinglePage = EventsSinglePage;
      Events5.Details = Details;
    })(Events4 || (Events4 = {}));
  }
});

// node_modules/cloudflare/resources/waiting-rooms/waiting-rooms.mjs
var WaitingRooms, WaitingRoomsSinglePage;
var init_waiting_rooms = __esm({
  "node_modules/cloudflare/resources/waiting-rooms/waiting-rooms.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_page();
    init_rules10();
    init_settings7();
    init_statuses2();
    init_events4();
    init_pagination();
    WaitingRooms = class extends APIResource {
      static {
        __name(this, "WaitingRooms");
      }
      constructor() {
        super(...arguments);
        this.page = new Page(this._client);
        this.events = new Events4(this._client);
        this.rules = new Rules10(this._client);
        this.statuses = new Statuses2(this._client);
        this.settings = new Settings7(this._client);
      }
      /**
       * Creates a new waiting room.
       */
      create(params, options) {
        const { zone_id, ...body } = params;
        return this._client.post(`/zones/${zone_id}/waiting_rooms`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a configured waiting room.
       */
      update(waitingRoomId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists waiting rooms.
       */
      list(params, options) {
        const { zone_id, ...query } = params;
        return this._client.getAPIList(`/zones/${zone_id}/waiting_rooms`, WaitingRoomsSinglePage, {
          query,
          ...options
        });
      }
      /**
       * Deletes a waiting room.
       */
      delete(waitingRoomId, params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Patches a configured waiting room.
       */
      edit(waitingRoomId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a single configured waiting room.
       */
      get(waitingRoomId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/waiting_rooms/${waitingRoomId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    WaitingRoomsSinglePage = class extends SinglePage {
      static {
        __name(this, "WaitingRoomsSinglePage");
      }
    };
    (function(WaitingRooms2) {
      WaitingRooms2.Page = Page;
      WaitingRooms2.Events = Events4;
      WaitingRooms2.EventsSinglePage = EventsSinglePage;
      WaitingRooms2.Rules = Rules10;
      WaitingRooms2.WaitingRoomRulesSinglePage = WaitingRoomRulesSinglePage;
      WaitingRooms2.Statuses = Statuses2;
      WaitingRooms2.Settings = Settings7;
    })(WaitingRooms || (WaitingRooms = {}));
  }
});

// node_modules/cloudflare/resources/web3/hostnames/ipfs-universal-paths/content-lists/entries.mjs
var Entries;
var init_entries = __esm({
  "node_modules/cloudflare/resources/web3/hostnames/ipfs-universal-paths/content-lists/entries.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Entries = class extends APIResource {
      static {
        __name(this, "Entries");
      }
      /**
       * Create IPFS Universal Path Gateway Content List Entry
       */
      create(zoneIdentifier, identifier, body, options) {
        return this._client.post(`/zones/${zoneIdentifier}/web3/hostnames/${identifier}/ipfs_universal_path/content_list/entries`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Edit IPFS Universal Path Gateway Content List Entry
       */
      update(zoneIdentifier, identifier, contentListEntryIdentifier, body, options) {
        return this._client.put(`/zones/${zoneIdentifier}/web3/hostnames/${identifier}/ipfs_universal_path/content_list/entries/${contentListEntryIdentifier}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List IPFS Universal Path Gateway Content List Entries
       */
      list(zoneIdentifier, identifier, options) {
        return this._client.get(`/zones/${zoneIdentifier}/web3/hostnames/${identifier}/ipfs_universal_path/content_list/entries`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Delete IPFS Universal Path Gateway Content List Entry
       */
      delete(zoneIdentifier, identifier, contentListEntryIdentifier, options) {
        return this._client.delete(`/zones/${zoneIdentifier}/web3/hostnames/${identifier}/ipfs_universal_path/content_list/entries/${contentListEntryIdentifier}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * IPFS Universal Path Gateway Content List Entry Details
       */
      get(zoneIdentifier, identifier, contentListEntryIdentifier, options) {
        return this._client.get(`/zones/${zoneIdentifier}/web3/hostnames/${identifier}/ipfs_universal_path/content_list/entries/${contentListEntryIdentifier}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Entries2) {
    })(Entries || (Entries = {}));
  }
});

// node_modules/cloudflare/resources/web3/hostnames/ipfs-universal-paths/content-lists/content-lists.mjs
var ContentLists;
var init_content_lists = __esm({
  "node_modules/cloudflare/resources/web3/hostnames/ipfs-universal-paths/content-lists/content-lists.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_entries();
    ContentLists = class extends APIResource {
      static {
        __name(this, "ContentLists");
      }
      constructor() {
        super(...arguments);
        this.entries = new Entries(this._client);
      }
      /**
       * Update IPFS Universal Path Gateway Content List
       */
      update(zoneIdentifier, identifier, body, options) {
        return this._client.put(`/zones/${zoneIdentifier}/web3/hostnames/${identifier}/ipfs_universal_path/content_list`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * IPFS Universal Path Gateway Content List Details
       */
      get(zoneIdentifier, identifier, options) {
        return this._client.get(`/zones/${zoneIdentifier}/web3/hostnames/${identifier}/ipfs_universal_path/content_list`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(ContentLists2) {
      ContentLists2.Entries = Entries;
    })(ContentLists || (ContentLists = {}));
  }
});

// node_modules/cloudflare/resources/web3/hostnames/ipfs-universal-paths/ipfs-universal-paths.mjs
var IPFSUniversalPaths;
var init_ipfs_universal_paths = __esm({
  "node_modules/cloudflare/resources/web3/hostnames/ipfs-universal-paths/ipfs-universal-paths.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_content_lists();
    IPFSUniversalPaths = class extends APIResource {
      static {
        __name(this, "IPFSUniversalPaths");
      }
      constructor() {
        super(...arguments);
        this.contentLists = new ContentLists(this._client);
      }
    };
    (function(IPFSUniversalPaths2) {
      IPFSUniversalPaths2.ContentLists = ContentLists;
    })(IPFSUniversalPaths || (IPFSUniversalPaths = {}));
  }
});

// node_modules/cloudflare/resources/web3/hostnames/hostnames.mjs
var Hostnames3, HostnamesSinglePage;
var init_hostnames3 = __esm({
  "node_modules/cloudflare/resources/web3/hostnames/hostnames.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_hostnames3();
    init_ipfs_universal_paths();
    init_pagination();
    Hostnames3 = class extends APIResource {
      static {
        __name(this, "Hostnames");
      }
      constructor() {
        super(...arguments);
        this.ipfsUniversalPaths = new IPFSUniversalPaths(this._client);
      }
      /**
       * Create Web3 Hostname
       */
      create(zoneIdentifier, body, options) {
        return this._client.post(`/zones/${zoneIdentifier}/web3/hostnames`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List Web3 Hostnames
       */
      list(zoneIdentifier, options) {
        return this._client.getAPIList(`/zones/${zoneIdentifier}/web3/hostnames`, HostnamesSinglePage, options);
      }
      /**
       * Delete Web3 Hostname
       */
      delete(zoneIdentifier, identifier, options) {
        return this._client.delete(`/zones/${zoneIdentifier}/web3/hostnames/${identifier}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Edit Web3 Hostname
       */
      edit(zoneIdentifier, identifier, body, options) {
        return this._client.patch(`/zones/${zoneIdentifier}/web3/hostnames/${identifier}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Web3 Hostname Details
       */
      get(zoneIdentifier, identifier, options) {
        return this._client.get(`/zones/${zoneIdentifier}/web3/hostnames/${identifier}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    HostnamesSinglePage = class extends SinglePage {
      static {
        __name(this, "HostnamesSinglePage");
      }
    };
    (function(Hostnames4) {
      Hostnames4.HostnamesSinglePage = HostnamesSinglePage;
      Hostnames4.IPFSUniversalPaths = IPFSUniversalPaths;
    })(Hostnames3 || (Hostnames3 = {}));
  }
});

// node_modules/cloudflare/resources/web3/web3.mjs
var Web3;
var init_web3 = __esm({
  "node_modules/cloudflare/resources/web3/web3.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_hostnames3();
    Web3 = class extends APIResource {
      static {
        __name(this, "Web3");
      }
      constructor() {
        super(...arguments);
        this.hostnames = new Hostnames3(this._client);
      }
    };
    (function(Web32) {
      Web32.Hostnames = Hostnames3;
      Web32.HostnamesSinglePage = HostnamesSinglePage;
    })(Web3 || (Web3 = {}));
  }
});

// node_modules/cloudflare/resources/workers/account-settings.mjs
var AccountSettings;
var init_account_settings = __esm({
  "node_modules/cloudflare/resources/workers/account-settings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    AccountSettings = class extends APIResource {
      static {
        __name(this, "AccountSettings");
      }
      /**
       * Creates Worker account settings for an account.
       */
      update(params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/workers/account-settings`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches Worker account settings for an account.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/workers/account-settings`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(AccountSettings2) {
    })(AccountSettings || (AccountSettings = {}));
  }
});

// node_modules/cloudflare/resources/workers/domains.mjs
var Domains4, DomainsSinglePage2;
var init_domains4 = __esm({
  "node_modules/cloudflare/resources/workers/domains.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_domains4();
    init_pagination();
    Domains4 = class extends APIResource {
      static {
        __name(this, "Domains");
      }
      /**
       * Attaches a Worker to a zone and hostname.
       */
      update(params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/workers/domains`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists all Worker Domains for an account.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/workers/domains`, DomainsSinglePage2, {
          query,
          ...options
        });
      }
      /**
       * Detaches a Worker from a zone and hostname.
       */
      delete(domainId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/workers/domains/${domainId}`, {
          ...options,
          headers: { Accept: "*/*", ...options?.headers }
        });
      }
      /**
       * Gets a Worker domain.
       */
      get(domainId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/workers/domains/${domainId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    DomainsSinglePage2 = class extends SinglePage {
      static {
        __name(this, "DomainsSinglePage");
      }
    };
    (function(Domains5) {
      Domains5.DomainsSinglePage = DomainsSinglePage2;
    })(Domains4 || (Domains4 = {}));
  }
});

// node_modules/cloudflare/resources/workers/subdomains.mjs
var Subdomains;
var init_subdomains = __esm({
  "node_modules/cloudflare/resources/workers/subdomains.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Subdomains = class extends APIResource {
      static {
        __name(this, "Subdomains");
      }
      /**
       * Creates a Workers subdomain for an account.
       */
      update(params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/workers/subdomain`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Returns a Workers subdomain for an account.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/workers/subdomain`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Subdomains2) {
    })(Subdomains || (Subdomains = {}));
  }
});

// node_modules/cloudflare/resources/workers/ai/models/schema.mjs
var Schema;
var init_schema = __esm({
  "node_modules/cloudflare/resources/workers/ai/models/schema.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Schema = class extends APIResource {
      static {
        __name(this, "Schema");
      }
      /**
       * Get Model Schema
       */
      get(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/ai/models/schema`, { query, ...options })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Schema2) {
    })(Schema || (Schema = {}));
  }
});

// node_modules/cloudflare/resources/workers/ai/models/models.mjs
var Models;
var init_models = __esm({
  "node_modules/cloudflare/resources/workers/ai/models/models.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_schema();
    Models = class extends APIResource {
      static {
        __name(this, "Models");
      }
      constructor() {
        super(...arguments);
        this.schema = new Schema(this._client);
      }
    };
    (function(Models2) {
      Models2.Schema = Schema;
    })(Models || (Models = {}));
  }
});

// node_modules/cloudflare/resources/workers/ai/ai.mjs
var AI;
var init_ai = __esm({
  "node_modules/cloudflare/resources/workers/ai/ai.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_models();
    AI = class extends APIResource {
      static {
        __name(this, "AI");
      }
      constructor() {
        super(...arguments);
        this.models = new Models(this._client);
      }
      /**
       * This endpoint provides users with the capability to run specific AI models
       * on-demand.
       *
       * By submitting the required input data, users can receive real-time predictions
       * or results generated by the chosen AI model. The endpoint supports various AI
       * model types, ensuring flexibility and adaptability for diverse use cases.
       *
       * Model specific inputs available in
       * [Cloudflare Docs](https://developers.cloudflare.com/workers-ai/models/).
       */
      run(modelName, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/ai/run/${modelName}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(AI2) {
      AI2.Models = Models;
    })(AI || (AI = {}));
  }
});

// node_modules/cloudflare/resources/workers/scripts/content.mjs
var Content2;
var init_content2 = __esm({
  "node_modules/cloudflare/resources/workers/scripts/content.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Content2 = class extends APIResource {
      static {
        __name(this, "Content");
      }
      /**
       * Put script content without touching config or metadata
       */
      update(scriptName, params, options) {
        const { account_id, "CF-WORKER-BODY-PART": cfWorkerBodyPart, "CF-WORKER-MAIN-MODULE-PART": cfWorkerMainModulePart, ...body } = params;
        return this._client.put(`/accounts/${account_id}/workers/scripts/${scriptName}/content`, multipartFormRequestOptions({
          body,
          ...options,
          headers: {
            ...cfWorkerBodyPart != null ? { "CF-WORKER-BODY-PART": cfWorkerBodyPart } : void 0,
            ...cfWorkerMainModulePart != null ? { "CF-WORKER-MAIN-MODULE-PART": cfWorkerMainModulePart } : void 0,
            ...options?.headers
          }
        }))._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch script content only
       */
      get(scriptName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/workers/scripts/${scriptName}/content/v2`, {
          ...options,
          __binaryResponse: true
        });
      }
    };
    /* @__PURE__ */ (function(Content4) {
    })(Content2 || (Content2 = {}));
  }
});

// node_modules/cloudflare/resources/workers/scripts/deployments.mjs
var Deployments2;
var init_deployments2 = __esm({
  "node_modules/cloudflare/resources/workers/scripts/deployments.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Deployments2 = class extends APIResource {
      static {
        __name(this, "Deployments");
      }
      /**
       * Deployments configure how
       * [Worker Versions](https://developers.cloudflare.com/api/operations/worker-versions-list-versions)
       * are deployed to traffic. A deployment can consist of one or two versions of a
       * Worker.
       */
      create(scriptName, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/workers/scripts/${scriptName}/deployments`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List of Worker Deployments. The first deployment in the list is the latest
       * deployment actively serving traffic.
       */
      get(scriptName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/workers/scripts/${scriptName}/deployments`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Deployments3) {
    })(Deployments2 || (Deployments2 = {}));
  }
});

// node_modules/cloudflare/resources/workers/scripts/schedules.mjs
var Schedules;
var init_schedules = __esm({
  "node_modules/cloudflare/resources/workers/scripts/schedules.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Schedules = class extends APIResource {
      static {
        __name(this, "Schedules");
      }
      /**
       * Updates Cron Triggers for a Worker.
       */
      update(scriptName, params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/workers/scripts/${scriptName}/schedules`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches Cron Triggers for a Worker.
       */
      get(scriptName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/workers/scripts/${scriptName}/schedules`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Schedules2) {
    })(Schedules || (Schedules = {}));
  }
});

// node_modules/cloudflare/resources/workers/scripts/settings.mjs
var Settings8;
var init_settings8 = __esm({
  "node_modules/cloudflare/resources/workers/scripts/settings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Settings8 = class extends APIResource {
      static {
        __name(this, "Settings");
      }
      /**
       * Patch script-level settings when using
       * [Worker Versions](https://developers.cloudflare.com/api/operations/worker-versions-list-versions).
       * Includes Logpush and Tail Consumers.
       */
      edit(scriptName, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/workers/scripts/${scriptName}/script-settings`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get script-level settings when using
       * [Worker Versions](https://developers.cloudflare.com/api/operations/worker-versions-list-versions).
       * Includes Logpush and Tail Consumers.
       */
      get(scriptName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/workers/scripts/${scriptName}/script-settings`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Settings13) {
    })(Settings8 || (Settings8 = {}));
  }
});

// node_modules/cloudflare/resources/workers/scripts/tail.mjs
var Tail;
var init_tail = __esm({
  "node_modules/cloudflare/resources/workers/scripts/tail.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Tail = class extends APIResource {
      static {
        __name(this, "Tail");
      }
      /**
       * Starts a tail that receives logs and exception from a Worker.
       */
      create(scriptName, params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/workers/scripts/${scriptName}/tails`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Deletes a tail from a Worker.
       */
      delete(scriptName, id, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/workers/scripts/${scriptName}/tails/${id}`, options);
      }
      /**
       * Get list of tails currently deployed on a Worker.
       */
      get(scriptName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/workers/scripts/${scriptName}/tails`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Tail2) {
    })(Tail || (Tail = {}));
  }
});

// node_modules/cloudflare/resources/workers/scripts/versions.mjs
var Versions3, VersionListResponsesV4PagePagination;
var init_versions3 = __esm({
  "node_modules/cloudflare/resources/workers/scripts/versions.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_versions3();
    init_pagination();
    Versions3 = class extends APIResource {
      static {
        __name(this, "Versions");
      }
      /**
       * Upload a Worker Version without deploying to Cloudflare's network.
       */
      create(scriptName, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/workers/scripts/${scriptName}/versions`, multipartFormRequestOptions({ body, ...options }))._thenUnwrap((obj) => obj.result);
      }
      /**
       * List of Worker Versions. The first version in the list is the latest version.
       */
      list(scriptName, params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/workers/scripts/${scriptName}/versions`, VersionListResponsesV4PagePagination, { query, ...options });
      }
      /**
       * Get Version Detail
       */
      get(scriptName, versionId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/workers/scripts/${scriptName}/versions/${versionId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    VersionListResponsesV4PagePagination = class extends V4PagePagination {
      static {
        __name(this, "VersionListResponsesV4PagePagination");
      }
    };
    (function(Versions4) {
      Versions4.VersionListResponsesV4PagePagination = VersionListResponsesV4PagePagination;
    })(Versions3 || (Versions3 = {}));
  }
});

// node_modules/cloudflare/resources/workers/scripts/scripts.mjs
var Scripts2, ScriptsSinglePage2;
var init_scripts2 = __esm({
  "node_modules/cloudflare/resources/workers/scripts/scripts.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_scripts2();
    init_content2();
    init_deployments2();
    init_schedules();
    init_settings8();
    init_tail();
    init_versions3();
    init_pagination();
    Scripts2 = class extends APIResource {
      static {
        __name(this, "Scripts");
      }
      constructor() {
        super(...arguments);
        this.schedules = new Schedules(this._client);
        this.tail = new Tail(this._client);
        this.content = new Content2(this._client);
        this.settings = new Settings8(this._client);
        this.deployments = new Deployments2(this._client);
        this.versions = new Versions3(this._client);
      }
      /**
       * Upload a worker module.
       */
      update(scriptName, params, options) {
        const { account_id, rollback_to, ...body } = params;
        return this._client.put(`/accounts/${account_id}/workers/scripts/${scriptName}`, maybeMultipartFormRequestOptions({
          query: { rollback_to },
          body,
          ...options,
          headers: { "Content-Type": "application/javascript", ...options?.headers }
        }))._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch a list of uploaded workers.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/workers/scripts`, ScriptsSinglePage2, options);
      }
      /**
       * Delete your worker. This call has no response body on a successful delete.
       */
      delete(scriptName, params, options) {
        const { account_id, force } = params;
        return this._client.delete(`/accounts/${account_id}/workers/scripts/${scriptName}`, {
          query: { force },
          ...options,
          headers: { Accept: "*/*", ...options?.headers }
        });
      }
      /**
       * Fetch raw script content for your worker. Note this is the original script
       * content, not JSON encoded.
       */
      get(scriptName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/workers/scripts/${scriptName}`, {
          ...options,
          __binaryResponse: true
        });
      }
    };
    ScriptsSinglePage2 = class extends SinglePage {
      static {
        __name(this, "ScriptsSinglePage");
      }
    };
    (function(Scripts4) {
      Scripts4.ScriptsSinglePage = ScriptsSinglePage2;
      Scripts4.Schedules = Schedules;
      Scripts4.Tail = Tail;
      Scripts4.Content = Content2;
      Scripts4.Settings = Settings8;
      Scripts4.Deployments = Deployments2;
      Scripts4.Versions = Versions3;
      Scripts4.VersionListResponsesV4PagePagination = VersionListResponsesV4PagePagination;
    })(Scripts2 || (Scripts2 = {}));
  }
});

// node_modules/cloudflare/resources/workers/workers.mjs
var Workers;
var init_workers = __esm({
  "node_modules/cloudflare/resources/workers/workers.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_account_settings();
    init_domains4();
    init_subdomains();
    init_ai();
    init_scripts2();
    Workers = class extends APIResource {
      static {
        __name(this, "Workers");
      }
      constructor() {
        super(...arguments);
        this.ai = new AI(this._client);
        this.scripts = new Scripts2(this._client);
        this.accountSettings = new AccountSettings(this._client);
        this.domains = new Domains4(this._client);
        this.subdomains = new Subdomains(this._client);
      }
    };
    (function(Workers2) {
      Workers2.AI = AI;
      Workers2.Scripts = Scripts2;
      Workers2.ScriptsSinglePage = ScriptsSinglePage2;
      Workers2.AccountSettings = AccountSettings;
      Workers2.Domains = Domains4;
      Workers2.DomainsSinglePage = DomainsSinglePage2;
      Workers2.Subdomains = Subdomains;
    })(Workers || (Workers = {}));
  }
});

// node_modules/cloudflare/resources/workers-for-platforms/dispatch/namespaces/scripts/bindings.mjs
var Bindings2;
var init_bindings2 = __esm({
  "node_modules/cloudflare/resources/workers-for-platforms/dispatch/namespaces/scripts/bindings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Bindings2 = class extends APIResource {
      static {
        __name(this, "Bindings");
      }
      /**
       * Fetch script bindings from a script uploaded to a Workers for Platforms
       * namespace.
       */
      get(dispatchNamespace, scriptName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/workers/dispatch/namespaces/${dispatchNamespace}/scripts/${scriptName}/bindings`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Bindings3) {
    })(Bindings2 || (Bindings2 = {}));
  }
});

// node_modules/cloudflare/resources/workers-for-platforms/dispatch/namespaces/scripts/content.mjs
var Content3;
var init_content3 = __esm({
  "node_modules/cloudflare/resources/workers-for-platforms/dispatch/namespaces/scripts/content.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Content3 = class extends APIResource {
      static {
        __name(this, "Content");
      }
      /**
       * Put script content for a script uploaded to a Workers for Platforms namespace.
       */
      update(dispatchNamespace, scriptName, params, options) {
        const { account_id, "CF-WORKER-BODY-PART": cfWorkerBodyPart, "CF-WORKER-MAIN-MODULE-PART": cfWorkerMainModulePart, ...body } = params;
        return this._client.put(`/accounts/${account_id}/workers/dispatch/namespaces/${dispatchNamespace}/scripts/${scriptName}/content`, multipartFormRequestOptions({
          body,
          ...options,
          headers: {
            ...cfWorkerBodyPart != null ? { "CF-WORKER-BODY-PART": cfWorkerBodyPart } : void 0,
            ...cfWorkerMainModulePart != null ? { "CF-WORKER-MAIN-MODULE-PART": cfWorkerMainModulePart } : void 0,
            ...options?.headers
          }
        }))._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch script content from a script uploaded to a Workers for Platforms
       * namespace.
       */
      get(dispatchNamespace, scriptName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/workers/dispatch/namespaces/${dispatchNamespace}/scripts/${scriptName}/content`, { ...options, __binaryResponse: true });
      }
    };
    /* @__PURE__ */ (function(Content4) {
    })(Content3 || (Content3 = {}));
  }
});

// node_modules/cloudflare/resources/workers-for-platforms/dispatch/namespaces/scripts/secrets.mjs
var Secrets, SecretListResponsesSinglePage;
var init_secrets = __esm({
  "node_modules/cloudflare/resources/workers-for-platforms/dispatch/namespaces/scripts/secrets.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_secrets();
    init_pagination();
    Secrets = class extends APIResource {
      static {
        __name(this, "Secrets");
      }
      /**
       * Put secrets to a script uploaded to a Workers for Platforms namespace.
       */
      update(dispatchNamespace, scriptName, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/workers/dispatch/namespaces/${dispatchNamespace}/scripts/${scriptName}/secrets`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch secrets from a script uploaded to a Workers for Platforms namespace.
       */
      list(dispatchNamespace, scriptName, params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/workers/dispatch/namespaces/${dispatchNamespace}/scripts/${scriptName}/secrets`, SecretListResponsesSinglePage, options);
      }
    };
    SecretListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "SecretListResponsesSinglePage");
      }
    };
    (function(Secrets2) {
      Secrets2.SecretListResponsesSinglePage = SecretListResponsesSinglePage;
    })(Secrets || (Secrets = {}));
  }
});

// node_modules/cloudflare/resources/workers-for-platforms/dispatch/namespaces/scripts/settings.mjs
var Settings9;
var init_settings9 = __esm({
  "node_modules/cloudflare/resources/workers-for-platforms/dispatch/namespaces/scripts/settings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Settings9 = class extends APIResource {
      static {
        __name(this, "Settings");
      }
      /**
       * Patch script metadata, such as bindings
       */
      edit(dispatchNamespace, scriptName, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/workers/dispatch/namespaces/${dispatchNamespace}/scripts/${scriptName}/settings`, multipartFormRequestOptions({ body, ...options }))._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get script settings from a script uploaded to a Workers for Platforms namespace.
       */
      get(dispatchNamespace, scriptName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/workers/dispatch/namespaces/${dispatchNamespace}/scripts/${scriptName}/settings`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Settings13) {
    })(Settings9 || (Settings9 = {}));
  }
});

// node_modules/cloudflare/resources/workers-for-platforms/dispatch/namespaces/scripts/tags.mjs
var Tags, TagListResponsesSinglePage;
var init_tags = __esm({
  "node_modules/cloudflare/resources/workers-for-platforms/dispatch/namespaces/scripts/tags.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_tags();
    init_pagination();
    Tags = class extends APIResource {
      static {
        __name(this, "Tags");
      }
      /**
       * Put script tags for a script uploaded to a Workers for Platforms namespace.
       */
      update(dispatchNamespace, scriptName, params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/workers/dispatch/namespaces/${dispatchNamespace}/scripts/${scriptName}/tags`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch tags from a script uploaded to a Workers for Platforms namespace.
       */
      list(dispatchNamespace, scriptName, params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/workers/dispatch/namespaces/${dispatchNamespace}/scripts/${scriptName}/tags`, TagListResponsesSinglePage, options);
      }
      /**
       * Delete script tag for a script uploaded to a Workers for Platforms namespace.
       */
      delete(dispatchNamespace, scriptName, tag, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/workers/dispatch/namespaces/${dispatchNamespace}/scripts/${scriptName}/tags/${tag}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    TagListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "TagListResponsesSinglePage");
      }
    };
    (function(Tags3) {
      Tags3.TagListResponsesSinglePage = TagListResponsesSinglePage;
    })(Tags || (Tags = {}));
  }
});

// node_modules/cloudflare/resources/workers-for-platforms/dispatch/namespaces/scripts/scripts.mjs
var Scripts3;
var init_scripts3 = __esm({
  "node_modules/cloudflare/resources/workers-for-platforms/dispatch/namespaces/scripts/scripts.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_bindings2();
    init_content3();
    init_secrets();
    init_settings9();
    init_tags();
    Scripts3 = class extends APIResource {
      static {
        __name(this, "Scripts");
      }
      constructor() {
        super(...arguments);
        this.content = new Content3(this._client);
        this.settings = new Settings9(this._client);
        this.bindings = new Bindings2(this._client);
        this.secrets = new Secrets(this._client);
        this.tags = new Tags(this._client);
      }
      /**
       * Upload a worker module to a Workers for Platforms namespace. You can find an
       * example of the metadata on our docs:
       * https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms/reference/metadata/
       */
      update(dispatchNamespace, scriptName, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/workers/dispatch/namespaces/${dispatchNamespace}/scripts/${scriptName}`, maybeMultipartFormRequestOptions({
          body,
          ...options,
          headers: { "Content-Type": "application/javascript", ...options?.headers }
        }))._thenUnwrap((obj) => obj.result);
      }
      /**
       * Delete a worker from a Workers for Platforms namespace. This call has no
       * response body on a successful delete.
       */
      delete(dispatchNamespace, scriptName, params, options) {
        const { account_id, force } = params;
        return this._client.delete(`/accounts/${account_id}/workers/dispatch/namespaces/${dispatchNamespace}/scripts/${scriptName}`, { query: { force }, ...options, headers: { Accept: "*/*", ...options?.headers } });
      }
      /**
       * Fetch information about a script uploaded to a Workers for Platforms namespace.
       */
      get(dispatchNamespace, scriptName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/workers/dispatch/namespaces/${dispatchNamespace}/scripts/${scriptName}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Scripts4) {
      Scripts4.Content = Content3;
      Scripts4.Settings = Settings9;
      Scripts4.Bindings = Bindings2;
      Scripts4.Secrets = Secrets;
      Scripts4.SecretListResponsesSinglePage = SecretListResponsesSinglePage;
      Scripts4.Tags = Tags;
      Scripts4.TagListResponsesSinglePage = TagListResponsesSinglePage;
    })(Scripts3 || (Scripts3 = {}));
  }
});

// node_modules/cloudflare/resources/workers-for-platforms/dispatch/namespaces/namespaces.mjs
var Namespaces3, NamespaceListResponsesSinglePage;
var init_namespaces3 = __esm({
  "node_modules/cloudflare/resources/workers-for-platforms/dispatch/namespaces/namespaces.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_namespaces3();
    init_scripts3();
    init_pagination();
    Namespaces3 = class extends APIResource {
      static {
        __name(this, "Namespaces");
      }
      constructor() {
        super(...arguments);
        this.scripts = new Scripts3(this._client);
      }
      /**
       * Create a new Workers for Platforms namespace.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/workers/dispatch/namespaces`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch a list of Workers for Platforms namespaces.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/workers/dispatch/namespaces`, NamespaceListResponsesSinglePage, options);
      }
      /**
       * Delete a Workers for Platforms namespace.
       */
      delete(dispatchNamespace, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/workers/dispatch/namespaces/${dispatchNamespace}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a Workers for Platforms namespace.
       */
      get(dispatchNamespace, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/workers/dispatch/namespaces/${dispatchNamespace}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    NamespaceListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "NamespaceListResponsesSinglePage");
      }
    };
    (function(Namespaces4) {
      Namespaces4.NamespaceListResponsesSinglePage = NamespaceListResponsesSinglePage;
      Namespaces4.Scripts = Scripts3;
    })(Namespaces3 || (Namespaces3 = {}));
  }
});

// node_modules/cloudflare/resources/workers-for-platforms/dispatch/dispatch.mjs
var Dispatch;
var init_dispatch = __esm({
  "node_modules/cloudflare/resources/workers-for-platforms/dispatch/dispatch.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_namespaces3();
    Dispatch = class extends APIResource {
      static {
        __name(this, "Dispatch");
      }
      constructor() {
        super(...arguments);
        this.namespaces = new Namespaces3(this._client);
      }
    };
    (function(Dispatch2) {
      Dispatch2.Namespaces = Namespaces3;
      Dispatch2.NamespaceListResponsesSinglePage = NamespaceListResponsesSinglePage;
    })(Dispatch || (Dispatch = {}));
  }
});

// node_modules/cloudflare/resources/workers-for-platforms/workers-for-platforms.mjs
var WorkersForPlatforms;
var init_workers_for_platforms = __esm({
  "node_modules/cloudflare/resources/workers-for-platforms/workers-for-platforms.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_dispatch();
    WorkersForPlatforms = class extends APIResource {
      static {
        __name(this, "WorkersForPlatforms");
      }
      constructor() {
        super(...arguments);
        this.dispatch = new Dispatch(this._client);
      }
    };
    (function(WorkersForPlatforms2) {
      WorkersForPlatforms2.Dispatch = Dispatch;
    })(WorkersForPlatforms || (WorkersForPlatforms = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/connectivity-settings.mjs
var ConnectivitySettings;
var init_connectivity_settings = __esm({
  "node_modules/cloudflare/resources/zero-trust/connectivity-settings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    ConnectivitySettings = class extends APIResource {
      static {
        __name(this, "ConnectivitySettings");
      }
      /**
       * Updates the Zero Trust Connectivity Settings for the given account.
       */
      edit(params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/zerotrust/connectivity_settings`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Gets the Zero Trust Connectivity Settings for the given account.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/zerotrust/connectivity_settings`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(ConnectivitySettings2) {
    })(ConnectivitySettings || (ConnectivitySettings = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/identity-providers.mjs
var IdentityProviders, IdentityProviderListResponsesSinglePage;
var init_identity_providers = __esm({
  "node_modules/cloudflare/resources/zero-trust/identity-providers.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    init_identity_providers();
    init_pagination();
    IdentityProviders = class extends APIResource {
      static {
        __name(this, "IdentityProviders");
      }
      /**
       * Adds a new identity provider to Access.
       */
      create(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/access/identity_providers`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a configured identity provider.
       */
      update(identityProviderId, params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.put(`/${accountOrZone}/${accountOrZoneId}/access/identity_providers/${identityProviderId}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      list(params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list({}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.getAPIList(`/${accountOrZone}/${accountOrZoneId}/access/identity_providers`, IdentityProviderListResponsesSinglePage, options);
      }
      delete(identityProviderId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.delete(identityProviderId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.delete(`/${accountOrZone}/${accountOrZoneId}/access/identity_providers/${identityProviderId}`, options)._thenUnwrap((obj) => obj.result);
      }
      get(identityProviderId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get(identityProviderId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/access/identity_providers/${identityProviderId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    IdentityProviderListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "IdentityProviderListResponsesSinglePage");
      }
    };
    (function(IdentityProviders2) {
      IdentityProviders2.IdentityProviderListResponsesSinglePage = IdentityProviderListResponsesSinglePage;
    })(IdentityProviders || (IdentityProviders = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/organizations.mjs
var Organizations2;
var init_organizations2 = __esm({
  "node_modules/cloudflare/resources/zero-trust/organizations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    Organizations2 = class extends APIResource {
      static {
        __name(this, "Organizations");
      }
      /**
       * Sets up a Zero Trust organization for your account or zone.
       */
      create(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/access/organizations`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates the configuration for your Zero Trust organization.
       */
      update(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.put(`/${accountOrZone}/${accountOrZoneId}/access/organizations`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      list(params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list({}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/access/organizations`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Revokes a user's access across all applications.
       */
      revokeUsers(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/access/organizations/revoke_user`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Organizations3) {
    })(Organizations2 || (Organizations2 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/seats.mjs
var Seats;
var init_seats = __esm({
  "node_modules/cloudflare/resources/zero-trust/seats.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Seats = class extends APIResource {
      static {
        __name(this, "Seats");
      }
      /**
       * Removes a user from a Zero Trust seat when both `access_seat` and `gateway_seat`
       * are set to false.
       */
      edit(params, options) {
        const { account_id, body } = params;
        return this._client.patch(`/accounts/${account_id}/access/seats`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Seats2) {
    })(Seats || (Seats = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/bookmarks.mjs
var Bookmarks, BookmarksSinglePage;
var init_bookmarks = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/bookmarks.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_bookmarks();
    init_pagination();
    Bookmarks = class extends APIResource {
      static {
        __name(this, "Bookmarks");
      }
      /**
       * Create a new Bookmark application.
       */
      create(bookmarkId, params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/access/bookmarks/${bookmarkId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a configured Bookmark application.
       */
      update(bookmarkId, params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/access/bookmarks/${bookmarkId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists Bookmark applications.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/access/bookmarks`, BookmarksSinglePage, options);
      }
      /**
       * Deletes a Bookmark application.
       */
      delete(bookmarkId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/access/bookmarks/${bookmarkId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a single Bookmark application.
       */
      get(bookmarkId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/access/bookmarks/${bookmarkId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    BookmarksSinglePage = class extends SinglePage {
      static {
        __name(this, "BookmarksSinglePage");
      }
    };
    (function(Bookmarks2) {
      Bookmarks2.BookmarksSinglePage = BookmarksSinglePage;
    })(Bookmarks || (Bookmarks = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/custom-pages.mjs
var CustomPages, CustomPageWithoutHTMLsSinglePage;
var init_custom_pages = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/custom-pages.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_custom_pages();
    init_pagination();
    CustomPages = class extends APIResource {
      static {
        __name(this, "CustomPages");
      }
      /**
       * Create a custom page
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/access/custom_pages`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a custom page
       */
      update(customPageId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/access/custom_pages/${customPageId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List custom pages
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/access/custom_pages`, CustomPageWithoutHTMLsSinglePage, options);
      }
      /**
       * Delete a custom page
       */
      delete(customPageId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/access/custom_pages/${customPageId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a custom page and also returns its HTML.
       */
      get(customPageId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/access/custom_pages/${customPageId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    CustomPageWithoutHTMLsSinglePage = class extends SinglePage {
      static {
        __name(this, "CustomPageWithoutHTMLsSinglePage");
      }
    };
    (function(CustomPages2) {
      CustomPages2.CustomPageWithoutHTMLsSinglePage = CustomPageWithoutHTMLsSinglePage;
    })(CustomPages || (CustomPages = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/groups.mjs
var Groups2, ZeroTrustGroupsSinglePage;
var init_groups2 = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/groups.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    init_groups2();
    init_pagination();
    Groups2 = class extends APIResource {
      static {
        __name(this, "Groups");
      }
      /**
       * Creates a new Access group.
       */
      create(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/access/groups`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a configured Access group.
       */
      update(groupId, params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.put(`/${accountOrZone}/${accountOrZoneId}/access/groups/${groupId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      list(params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list({}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.getAPIList(`/${accountOrZone}/${accountOrZoneId}/access/groups`, ZeroTrustGroupsSinglePage, options);
      }
      delete(groupId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.delete(groupId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.delete(`/${accountOrZone}/${accountOrZoneId}/access/groups/${groupId}`, options)._thenUnwrap((obj) => obj.result);
      }
      get(groupId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get(groupId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/access/groups/${groupId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ZeroTrustGroupsSinglePage = class extends SinglePage {
      static {
        __name(this, "ZeroTrustGroupsSinglePage");
      }
    };
    (function(Groups3) {
      Groups3.ZeroTrustGroupsSinglePage = ZeroTrustGroupsSinglePage;
    })(Groups2 || (Groups2 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/keys.mjs
var Keys5;
var init_keys5 = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/keys.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Keys5 = class extends APIResource {
      static {
        __name(this, "Keys");
      }
      /**
       * Updates the Access key rotation settings for an account.
       */
      update(params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/access/keys`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Gets the Access key rotation settings for an account.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/access/keys`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Perfoms a key rotation for an account.
       */
      rotate(params, options) {
        const { account_id } = params;
        return this._client.post(`/accounts/${account_id}/access/keys/rotate`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Keys6) {
    })(Keys5 || (Keys5 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/policies.mjs
var Policies3, PolicyListResponsesSinglePage2;
var init_policies3 = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/policies.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_policies3();
    init_pagination();
    Policies3 = class extends APIResource {
      static {
        __name(this, "Policies");
      }
      /**
       * Creates a new Access reusable policy.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/access/policies`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a Access reusable policy.
       */
      update(policyId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/access/policies/${policyId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists Access reusable policies.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/access/policies`, PolicyListResponsesSinglePage2, options);
      }
      /**
       * Deletes an Access reusable policy.
       */
      delete(policyId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/access/policies/${policyId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a single Access reusable policy.
       */
      get(policyId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/access/policies/${policyId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    PolicyListResponsesSinglePage2 = class extends SinglePage {
      static {
        __name(this, "PolicyListResponsesSinglePage");
      }
    };
    (function(Policies6) {
      Policies6.PolicyListResponsesSinglePage = PolicyListResponsesSinglePage2;
    })(Policies3 || (Policies3 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/service-tokens.mjs
var ServiceTokens, ServiceTokensSinglePage;
var init_service_tokens = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/service-tokens.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    init_service_tokens();
    init_pagination();
    ServiceTokens = class extends APIResource {
      static {
        __name(this, "ServiceTokens");
      }
      /**
       * Generates a new service token. **Note:** This is the only time you can get the
       * Client Secret. If you lose the Client Secret, you will have to rotate the Client
       * Secret or create a new service token.
       */
      create(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/access/service_tokens`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a configured service token.
       */
      update(serviceTokenId, params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.put(`/${accountOrZone}/${accountOrZoneId}/access/service_tokens/${serviceTokenId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      list(params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list({}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.getAPIList(`/${accountOrZone}/${accountOrZoneId}/access/service_tokens`, ServiceTokensSinglePage, options);
      }
      delete(serviceTokenId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.delete(serviceTokenId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.delete(`/${accountOrZone}/${accountOrZoneId}/access/service_tokens/${serviceTokenId}`, options)._thenUnwrap((obj) => obj.result);
      }
      get(serviceTokenId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get(serviceTokenId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/access/service_tokens/${serviceTokenId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Refreshes the expiration of a service token.
       */
      refresh(serviceTokenId, params, options) {
        const { account_id } = params;
        return this._client.post(`/accounts/${account_id}/access/service_tokens/${serviceTokenId}/refresh`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Generates a new Client Secret for a service token and revokes the old one.
       */
      rotate(serviceTokenId, params, options) {
        const { account_id } = params;
        return this._client.post(`/accounts/${account_id}/access/service_tokens/${serviceTokenId}/rotate`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ServiceTokensSinglePage = class extends SinglePage {
      static {
        __name(this, "ServiceTokensSinglePage");
      }
    };
    (function(ServiceTokens2) {
      ServiceTokens2.ServiceTokensSinglePage = ServiceTokensSinglePage;
    })(ServiceTokens || (ServiceTokens = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/tags.mjs
var Tags2, TagsSinglePage;
var init_tags2 = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/tags.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_tags2();
    init_pagination();
    Tags2 = class extends APIResource {
      static {
        __name(this, "Tags");
      }
      /**
       * Create a tag
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/access/tags`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a tag
       */
      update(tagName, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/access/tags/${tagName}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List tags
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/access/tags`, TagsSinglePage, options);
      }
      /**
       * Delete a tag
       */
      delete(tagName, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/access/tags/${tagName}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a tag
       */
      get(tagName, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/access/tags/${tagName}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    TagsSinglePage = class extends SinglePage {
      static {
        __name(this, "TagsSinglePage");
      }
    };
    (function(Tags3) {
      Tags3.TagsSinglePage = TagsSinglePage;
    })(Tags2 || (Tags2 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/applications/cas.mjs
var CAs, CAsSinglePage;
var init_cas = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/applications/cas.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    init_cas();
    init_pagination();
    CAs = class extends APIResource {
      static {
        __name(this, "CAs");
      }
      create(appId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.create(appId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/access/apps/${appId}/ca`, options)._thenUnwrap((obj) => obj.result);
      }
      list(params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list({}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.getAPIList(`/${accountOrZone}/${accountOrZoneId}/access/apps/ca`, CAsSinglePage, options);
      }
      delete(appId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.delete(appId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.delete(`/${accountOrZone}/${accountOrZoneId}/access/apps/${appId}/ca`, options)._thenUnwrap((obj) => obj.result);
      }
      get(appId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get(appId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/access/apps/${appId}/ca`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    CAsSinglePage = class extends SinglePage {
      static {
        __name(this, "CAsSinglePage");
      }
    };
    (function(CAs2) {
      CAs2.CAsSinglePage = CAsSinglePage;
    })(CAs || (CAs = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/applications/policies.mjs
var Policies4, PolicyListResponsesSinglePage3;
var init_policies4 = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/applications/policies.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    init_policies4();
    init_pagination();
    Policies4 = class extends APIResource {
      static {
        __name(this, "Policies");
      }
      /**
       * Creates a policy applying exclusive to a single application that defines the
       * users or groups who can reach it. We recommend creating a reusable policy
       * instead and subsequently referencing its ID in the application's 'policies'
       * array.
       */
      create(appId, params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/access/apps/${appId}/policies`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an Access policy specific to an application. To update a reusable
       * policy, use the /account or zones/{account or zone_id}/policies/{uid} endpoint.
       */
      update(appId, policyId, params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.put(`/${accountOrZone}/${accountOrZoneId}/access/apps/${appId}/policies/${policyId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      list(appId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list(appId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.getAPIList(`/${accountOrZone}/${accountOrZoneId}/access/apps/${appId}/policies`, PolicyListResponsesSinglePage3, options);
      }
      delete(appId, policyId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.delete(appId, policyId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.delete(`/${accountOrZone}/${accountOrZoneId}/access/apps/${appId}/policies/${policyId}`, options)._thenUnwrap((obj) => obj.result);
      }
      get(appId, policyId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get(appId, policyId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/access/apps/${appId}/policies/${policyId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    PolicyListResponsesSinglePage3 = class extends SinglePage {
      static {
        __name(this, "PolicyListResponsesSinglePage");
      }
    };
    (function(Policies6) {
      Policies6.PolicyListResponsesSinglePage = PolicyListResponsesSinglePage3;
    })(Policies4 || (Policies4 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/applications/user-policy-checks.mjs
var UserPolicyChecks;
var init_user_policy_checks = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/applications/user-policy-checks.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    UserPolicyChecks = class extends APIResource {
      static {
        __name(this, "UserPolicyChecks");
      }
      list(appId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list(appId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/access/apps/${appId}/user_policy_checks`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(UserPolicyChecks2) {
    })(UserPolicyChecks || (UserPolicyChecks = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/applications/applications.mjs
var Applications, ApplicationListResponsesSinglePage;
var init_applications = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/applications/applications.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    init_applications();
    init_cas();
    init_policies4();
    init_user_policy_checks();
    init_pagination();
    Applications = class extends APIResource {
      static {
        __name(this, "Applications");
      }
      constructor() {
        super(...arguments);
        this.cas = new CAs(this._client);
        this.userPolicyChecks = new UserPolicyChecks(this._client);
        this.policies = new Policies4(this._client);
      }
      /**
       * Adds a new application to Access.
       */
      create(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/access/apps`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an Access application.
       */
      update(appId, params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.put(`/${accountOrZone}/${accountOrZoneId}/access/apps/${appId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      list(params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list({}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.getAPIList(`/${accountOrZone}/${accountOrZoneId}/access/apps`, ApplicationListResponsesSinglePage, options);
      }
      delete(appId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.delete(appId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.delete(`/${accountOrZone}/${accountOrZoneId}/access/apps/${appId}`, options)._thenUnwrap((obj) => obj.result);
      }
      get(appId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get(appId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/access/apps/${appId}`, options)._thenUnwrap((obj) => obj.result);
      }
      revokeTokens(appId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.revokeTokens(appId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/access/apps/${appId}/revoke_tokens`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ApplicationListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "ApplicationListResponsesSinglePage");
      }
    };
    (function(Applications2) {
      Applications2.ApplicationListResponsesSinglePage = ApplicationListResponsesSinglePage;
      Applications2.CAs = CAs;
      Applications2.CAsSinglePage = CAsSinglePage;
      Applications2.UserPolicyChecks = UserPolicyChecks;
      Applications2.Policies = Policies4;
      Applications2.PolicyListResponsesSinglePage = PolicyListResponsesSinglePage3;
    })(Applications || (Applications = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/certificates/settings.mjs
var Settings10;
var init_settings10 = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/certificates/settings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    Settings10 = class extends APIResource {
      static {
        __name(this, "Settings");
      }
      /**
       * Updates an mTLS certificate's hostname settings.
       */
      update(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.put(`/${accountOrZone}/${accountOrZoneId}/access/certificates/settings`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      get(params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get({}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/access/certificates/settings`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Settings13) {
    })(Settings10 || (Settings10 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/certificates/certificates.mjs
var Certificates2, CertificatesSinglePage;
var init_certificates2 = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/certificates/certificates.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_error();
    init_certificates2();
    init_settings10();
    init_pagination();
    Certificates2 = class extends APIResource {
      static {
        __name(this, "Certificates");
      }
      constructor() {
        super(...arguments);
        this.settings = new Settings10(this._client);
      }
      /**
       * Adds a new mTLS root certificate to Access.
       */
      create(params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.post(`/${accountOrZone}/${accountOrZoneId}/access/certificates`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a configured mTLS certificate.
       */
      update(certificateId, params, options) {
        const { account_id, zone_id, ...body } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.put(`/${accountOrZone}/${accountOrZoneId}/access/certificates/${certificateId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      list(params = {}, options) {
        if (isRequestOptions(params)) {
          return this.list({}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.getAPIList(`/${accountOrZone}/${accountOrZoneId}/access/certificates`, CertificatesSinglePage, options);
      }
      delete(certificateId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.delete(certificateId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.delete(`/${accountOrZone}/${accountOrZoneId}/access/certificates/${certificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
      get(certificateId, params = {}, options) {
        if (isRequestOptions(params)) {
          return this.get(certificateId, {}, params);
        }
        const { account_id, zone_id } = params;
        if (!account_id && !zone_id) {
          throw new CloudflareError("You must provide either account_id or zone_id.");
        }
        if (account_id && zone_id) {
          throw new CloudflareError("You cannot provide both account_id and zone_id.");
        }
        const { accountOrZone, accountOrZoneId } = account_id ? {
          accountOrZone: "accounts",
          accountOrZoneId: account_id
        } : {
          accountOrZone: "zones",
          accountOrZoneId: zone_id
        };
        return this._client.get(`/${accountOrZone}/${accountOrZoneId}/access/certificates/${certificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    CertificatesSinglePage = class extends SinglePage {
      static {
        __name(this, "CertificatesSinglePage");
      }
    };
    (function(Certificates4) {
      Certificates4.CertificatesSinglePage = CertificatesSinglePage;
      Certificates4.Settings = Settings10;
    })(Certificates2 || (Certificates2 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/logs/access-requests.mjs
var AccessRequests;
var init_access_requests = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/logs/access-requests.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_access_requests();
    AccessRequests = class extends APIResource {
      static {
        __name(this, "AccessRequests");
      }
      /**
       * Gets a list of Access authentication audit logs for an account.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/access/logs/access_requests`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(AccessRequests2) {
      AccessRequests2.AccessRequests = AccessRequests;
    })(AccessRequests || (AccessRequests = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/logs/logs.mjs
var Logs4;
var init_logs4 = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/logs/logs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_access_requests();
    Logs4 = class extends APIResource {
      static {
        __name(this, "Logs");
      }
      constructor() {
        super(...arguments);
        this.accessRequests = new AccessRequests(this._client);
      }
    };
    (function(Logs5) {
      Logs5.AccessRequests = AccessRequests;
    })(Logs4 || (Logs4 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/users/active-sessions.mjs
var ActiveSessions, ActiveSessionListResponsesSinglePage;
var init_active_sessions = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/users/active-sessions.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_active_sessions();
    init_pagination();
    ActiveSessions = class extends APIResource {
      static {
        __name(this, "ActiveSessions");
      }
      /**
       * Get active sessions for a single user.
       */
      list(userId, params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/access/users/${userId}/active_sessions`, ActiveSessionListResponsesSinglePage, options);
      }
      /**
       * Get an active session for a single user.
       */
      get(userId, nonce, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/access/users/${userId}/active_sessions/${nonce}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ActiveSessionListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "ActiveSessionListResponsesSinglePage");
      }
    };
    (function(ActiveSessions2) {
      ActiveSessions2.ActiveSessionListResponsesSinglePage = ActiveSessionListResponsesSinglePage;
    })(ActiveSessions || (ActiveSessions = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/users/failed-logins.mjs
var FailedLogins, FailedLoginListResponsesSinglePage;
var init_failed_logins = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/users/failed-logins.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_failed_logins();
    init_pagination();
    FailedLogins = class extends APIResource {
      static {
        __name(this, "FailedLogins");
      }
      /**
       * Get all failed login attempts for a single user.
       */
      list(userId, params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/access/users/${userId}/failed_logins`, FailedLoginListResponsesSinglePage, options);
      }
    };
    FailedLoginListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "FailedLoginListResponsesSinglePage");
      }
    };
    (function(FailedLogins2) {
      FailedLogins2.FailedLoginListResponsesSinglePage = FailedLoginListResponsesSinglePage;
    })(FailedLogins || (FailedLogins = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/users/last-seen-identity.mjs
var LastSeenIdentity;
var init_last_seen_identity = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/users/last-seen-identity.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    LastSeenIdentity = class extends APIResource {
      static {
        __name(this, "LastSeenIdentity");
      }
      /**
       * Get last seen identity for a single user.
       */
      get(userId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/access/users/${userId}/last_seen_identity`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(LastSeenIdentity2) {
    })(LastSeenIdentity || (LastSeenIdentity = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/users/users.mjs
var Users, AccessUsersSinglePage;
var init_users = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/users/users.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_users();
    init_active_sessions();
    init_failed_logins();
    init_last_seen_identity();
    init_pagination();
    Users = class extends APIResource {
      static {
        __name(this, "Users");
      }
      constructor() {
        super(...arguments);
        this.activeSessions = new ActiveSessions(this._client);
        this.lastSeenIdentity = new LastSeenIdentity(this._client);
        this.failedLogins = new FailedLogins(this._client);
      }
      /**
       * Gets a list of users for an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/access/users`, AccessUsersSinglePage, options);
      }
    };
    AccessUsersSinglePage = class extends SinglePage {
      static {
        __name(this, "AccessUsersSinglePage");
      }
    };
    (function(Users2) {
      Users2.AccessUsersSinglePage = AccessUsersSinglePage;
      Users2.ActiveSessions = ActiveSessions;
      Users2.ActiveSessionListResponsesSinglePage = ActiveSessionListResponsesSinglePage;
      Users2.LastSeenIdentity = LastSeenIdentity;
      Users2.FailedLogins = FailedLogins;
      Users2.FailedLoginListResponsesSinglePage = FailedLoginListResponsesSinglePage;
    })(Users || (Users = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/access/access.mjs
var Access;
var init_access = __esm({
  "node_modules/cloudflare/resources/zero-trust/access/access.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_bookmarks();
    init_custom_pages();
    init_groups2();
    init_keys5();
    init_policies3();
    init_service_tokens();
    init_tags2();
    init_applications();
    init_certificates2();
    init_logs4();
    init_users();
    Access = class extends APIResource {
      static {
        __name(this, "Access");
      }
      constructor() {
        super(...arguments);
        this.applications = new Applications(this._client);
        this.certificates = new Certificates2(this._client);
        this.groups = new Groups2(this._client);
        this.serviceTokens = new ServiceTokens(this._client);
        this.bookmarks = new Bookmarks(this._client);
        this.keys = new Keys5(this._client);
        this.logs = new Logs4(this._client);
        this.users = new Users(this._client);
        this.customPages = new CustomPages(this._client);
        this.tags = new Tags2(this._client);
        this.policies = new Policies3(this._client);
      }
    };
    (function(Access2) {
      Access2.Applications = Applications;
      Access2.ApplicationListResponsesSinglePage = ApplicationListResponsesSinglePage;
      Access2.Certificates = Certificates2;
      Access2.CertificatesSinglePage = CertificatesSinglePage;
      Access2.Groups = Groups2;
      Access2.ZeroTrustGroupsSinglePage = ZeroTrustGroupsSinglePage;
      Access2.ServiceTokens = ServiceTokens;
      Access2.ServiceTokensSinglePage = ServiceTokensSinglePage;
      Access2.Bookmarks = Bookmarks;
      Access2.BookmarksSinglePage = BookmarksSinglePage;
      Access2.Keys = Keys5;
      Access2.Logs = Logs4;
      Access2.Users = Users;
      Access2.AccessUsersSinglePage = AccessUsersSinglePage;
      Access2.CustomPages = CustomPages;
      Access2.CustomPageWithoutHTMLsSinglePage = CustomPageWithoutHTMLsSinglePage;
      Access2.Tags = Tags2;
      Access2.TagsSinglePage = TagsSinglePage;
      Access2.Policies = Policies3;
      Access2.PolicyListResponsesSinglePage = PolicyListResponsesSinglePage2;
    })(Access || (Access = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/devices/dex-tests.mjs
var DEXTests, SchemaHTTPSSinglePage;
var init_dex_tests = __esm({
  "node_modules/cloudflare/resources/zero-trust/devices/dex-tests.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_dex_tests();
    init_pagination();
    DEXTests = class extends APIResource {
      static {
        __name(this, "DEXTests");
      }
      /**
       * Create a DEX test.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/devices/dex_tests`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a DEX test.
       */
      update(dexTestId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/devices/dex_tests/${dexTestId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch all DEX tests.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/devices/dex_tests`, SchemaHTTPSSinglePage, options);
      }
      /**
       * Delete a Device DEX test. Returns the remaining device dex tests for the
       * account.
       */
      delete(dexTestId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/devices/dex_tests/${dexTestId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch a single DEX test.
       */
      get(dexTestId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/devices/dex_tests/${dexTestId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    SchemaHTTPSSinglePage = class extends SinglePage {
      static {
        __name(this, "SchemaHTTPSSinglePage");
      }
    };
    (function(DEXTests2) {
      DEXTests2.SchemaHTTPSSinglePage = SchemaHTTPSSinglePage;
    })(DEXTests || (DEXTests = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/devices/networks.mjs
var Networks, DeviceNetworksSinglePage;
var init_networks = __esm({
  "node_modules/cloudflare/resources/zero-trust/devices/networks.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_networks();
    init_pagination();
    Networks = class extends APIResource {
      static {
        __name(this, "Networks");
      }
      /**
       * Creates a new device managed network.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/devices/networks`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a configured device managed network.
       */
      update(networkId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/devices/networks/${networkId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a list of managed networks for an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/devices/networks`, DeviceNetworksSinglePage, options);
      }
      /**
       * Deletes a device managed network and fetches a list of the remaining device
       * managed networks for an account.
       */
      delete(networkId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/devices/networks/${networkId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches details for a single managed network.
       */
      get(networkId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/devices/networks/${networkId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    DeviceNetworksSinglePage = class extends SinglePage {
      static {
        __name(this, "DeviceNetworksSinglePage");
      }
    };
    (function(Networks4) {
      Networks4.DeviceNetworksSinglePage = DeviceNetworksSinglePage;
    })(Networks || (Networks = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/devices/override-codes.mjs
var OverrideCodes;
var init_override_codes = __esm({
  "node_modules/cloudflare/resources/zero-trust/devices/override-codes.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    OverrideCodes = class extends APIResource {
      static {
        __name(this, "OverrideCodes");
      }
      /**
       * Fetches a one-time use admin override code for a device. This relies on the
       * **Admin Override** setting being enabled in your device configuration.
       */
      list(deviceId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/devices/${deviceId}/override_codes`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(OverrideCodes2) {
    })(OverrideCodes || (OverrideCodes = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/devices/revoke.mjs
var Revoke;
var init_revoke = __esm({
  "node_modules/cloudflare/resources/zero-trust/devices/revoke.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Revoke = class extends APIResource {
      static {
        __name(this, "Revoke");
      }
      /**
       * Revokes a list of devices.
       */
      create(params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/devices/revoke`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Revoke2) {
    })(Revoke || (Revoke = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/devices/settings.mjs
var Settings11;
var init_settings11 = __esm({
  "node_modules/cloudflare/resources/zero-trust/devices/settings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Settings11 = class extends APIResource {
      static {
        __name(this, "Settings");
      }
      /**
       * Updates the current device settings for a Zero Trust account.
       */
      update(params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/devices/settings`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Describes the current device settings for a Zero Trust account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/devices/settings`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Settings13) {
    })(Settings11 || (Settings11 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/devices/unrevoke.mjs
var Unrevoke;
var init_unrevoke = __esm({
  "node_modules/cloudflare/resources/zero-trust/devices/unrevoke.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Unrevoke = class extends APIResource {
      static {
        __name(this, "Unrevoke");
      }
      /**
       * Unrevokes a list of devices.
       */
      create(params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/devices/unrevoke`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Unrevoke2) {
    })(Unrevoke || (Unrevoke = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/devices/policies/default-policy.mjs
var DefaultPolicy;
var init_default_policy = __esm({
  "node_modules/cloudflare/resources/zero-trust/devices/policies/default-policy.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    DefaultPolicy = class extends APIResource {
      static {
        __name(this, "DefaultPolicy");
      }
      /**
       * Fetches the default device settings profile for an account.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/devices/policy`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(DefaultPolicy2) {
    })(DefaultPolicy || (DefaultPolicy = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/devices/policies/excludes.mjs
var Excludes, SplitTunnelExcludesSinglePage;
var init_excludes = __esm({
  "node_modules/cloudflare/resources/zero-trust/devices/policies/excludes.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_excludes();
    init_pagination();
    Excludes = class extends APIResource {
      static {
        __name(this, "Excludes");
      }
      /**
       * Sets the list of routes excluded from the WARP client's tunnel.
       */
      update(params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/devices/policy/exclude`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the list of routes excluded from the WARP client's tunnel.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/devices/policy/exclude`, SplitTunnelExcludesSinglePage, options);
      }
      /**
       * Fetches the list of routes excluded from the WARP client's tunnel for a specific
       * device settings profile.
       */
      get(policyId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/devices/policy/${policyId}/exclude`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    SplitTunnelExcludesSinglePage = class extends SinglePage {
      static {
        __name(this, "SplitTunnelExcludesSinglePage");
      }
    };
    (function(Excludes2) {
      Excludes2.SplitTunnelExcludesSinglePage = SplitTunnelExcludesSinglePage;
    })(Excludes || (Excludes = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/devices/policies/fallback-domains.mjs
var FallbackDomains, FallbackDomainsSinglePage;
var init_fallback_domains = __esm({
  "node_modules/cloudflare/resources/zero-trust/devices/policies/fallback-domains.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_fallback_domains();
    init_pagination();
    FallbackDomains = class extends APIResource {
      static {
        __name(this, "FallbackDomains");
      }
      /**
       * Sets the list of domains to bypass Gateway DNS resolution. These domains will
       * use the specified local DNS resolver instead. This will only apply to the
       * specified device settings profile.
       */
      update(policyId, params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/devices/policy/${policyId}/fallback_domains`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a list of domains to bypass Gateway DNS resolution. These domains will
       * use the specified local DNS resolver instead.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/devices/policy/fallback_domains`, FallbackDomainsSinglePage, options);
      }
      /**
       * Fetches the list of domains to bypass Gateway DNS resolution from a specified
       * device settings profile. These domains will use the specified local DNS resolver
       * instead.
       */
      get(policyId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/devices/policy/${policyId}/fallback_domains`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    FallbackDomainsSinglePage = class extends SinglePage {
      static {
        __name(this, "FallbackDomainsSinglePage");
      }
    };
    (function(FallbackDomains2) {
      FallbackDomains2.FallbackDomainsSinglePage = FallbackDomainsSinglePage;
    })(FallbackDomains || (FallbackDomains = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/devices/policies/includes.mjs
var Includes, SplitTunnelIncludesSinglePage;
var init_includes = __esm({
  "node_modules/cloudflare/resources/zero-trust/devices/policies/includes.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_includes();
    init_pagination();
    Includes = class extends APIResource {
      static {
        __name(this, "Includes");
      }
      /**
       * Sets the list of routes included in the WARP client's tunnel.
       */
      update(params, options) {
        const { account_id, body } = params;
        return this._client.put(`/accounts/${account_id}/devices/policy/include`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the list of routes included in the WARP client's tunnel.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/devices/policy/include`, SplitTunnelIncludesSinglePage, options);
      }
      /**
       * Fetches the list of routes included in the WARP client's tunnel for a specific
       * device settings profile.
       */
      get(policyId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/devices/policy/${policyId}/include`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    SplitTunnelIncludesSinglePage = class extends SinglePage {
      static {
        __name(this, "SplitTunnelIncludesSinglePage");
      }
    };
    (function(Includes2) {
      Includes2.SplitTunnelIncludesSinglePage = SplitTunnelIncludesSinglePage;
    })(Includes || (Includes = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/devices/policies/policies.mjs
var Policies5, SettingsPoliciesSinglePage;
var init_policies5 = __esm({
  "node_modules/cloudflare/resources/zero-trust/devices/policies/policies.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_policies5();
    init_default_policy();
    init_excludes();
    init_fallback_domains();
    init_includes();
    init_pagination();
    Policies5 = class extends APIResource {
      static {
        __name(this, "Policies");
      }
      constructor() {
        super(...arguments);
        this.defaultPolicy = new DefaultPolicy(this._client);
        this.excludes = new Excludes(this._client);
        this.fallbackDomains = new FallbackDomains(this._client);
        this.includes = new Includes(this._client);
      }
      /**
       * Creates a device settings profile to be applied to certain devices matching the
       * criteria.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/devices/policy`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a list of the device settings profiles for an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/devices/policies`, SettingsPoliciesSinglePage, options);
      }
      /**
       * Deletes a device settings profile and fetches a list of the remaining profiles
       * for an account.
       */
      delete(policyId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/devices/policy/${policyId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a configured device settings profile.
       */
      edit(policyId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/devices/policy/${policyId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a device settings profile by ID.
       */
      get(policyId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/devices/policy/${policyId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    SettingsPoliciesSinglePage = class extends SinglePage {
      static {
        __name(this, "SettingsPoliciesSinglePage");
      }
    };
    (function(Policies6) {
      Policies6.SettingsPoliciesSinglePage = SettingsPoliciesSinglePage;
      Policies6.DefaultPolicy = DefaultPolicy;
      Policies6.Excludes = Excludes;
      Policies6.SplitTunnelExcludesSinglePage = SplitTunnelExcludesSinglePage;
      Policies6.FallbackDomains = FallbackDomains;
      Policies6.FallbackDomainsSinglePage = FallbackDomainsSinglePage;
      Policies6.Includes = Includes;
      Policies6.SplitTunnelIncludesSinglePage = SplitTunnelIncludesSinglePage;
    })(Policies5 || (Policies5 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/devices/posture/integrations.mjs
var Integrations, IntegrationsSinglePage;
var init_integrations = __esm({
  "node_modules/cloudflare/resources/zero-trust/devices/posture/integrations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_integrations();
    init_pagination();
    Integrations = class extends APIResource {
      static {
        __name(this, "Integrations");
      }
      /**
       * Create a new device posture integration.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/devices/posture/integration`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the list of device posture integrations for an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/devices/posture/integration`, IntegrationsSinglePage, options);
      }
      /**
       * Delete a configured device posture integration.
       */
      delete(integrationId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/devices/posture/integration/${integrationId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a configured device posture integration.
       */
      edit(integrationId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/devices/posture/integration/${integrationId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches details for a single device posture integration.
       */
      get(integrationId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/devices/posture/integration/${integrationId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    IntegrationsSinglePage = class extends SinglePage {
      static {
        __name(this, "IntegrationsSinglePage");
      }
    };
    (function(Integrations3) {
      Integrations3.IntegrationsSinglePage = IntegrationsSinglePage;
    })(Integrations || (Integrations = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/devices/posture/posture.mjs
var Posture, DevicePostureRulesSinglePage;
var init_posture = __esm({
  "node_modules/cloudflare/resources/zero-trust/devices/posture/posture.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_posture();
    init_integrations();
    init_pagination();
    Posture = class extends APIResource {
      static {
        __name(this, "Posture");
      }
      constructor() {
        super(...arguments);
        this.integrations = new Integrations(this._client);
      }
      /**
       * Creates a new device posture rule.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/devices/posture`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a device posture rule.
       */
      update(ruleId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/devices/posture/${ruleId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches device posture rules for a Zero Trust account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/devices/posture`, DevicePostureRulesSinglePage, options);
      }
      /**
       * Deletes a device posture rule.
       */
      delete(ruleId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/devices/posture/${ruleId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a single device posture rule.
       */
      get(ruleId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/devices/posture/${ruleId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    DevicePostureRulesSinglePage = class extends SinglePage {
      static {
        __name(this, "DevicePostureRulesSinglePage");
      }
    };
    (function(Posture2) {
      Posture2.DevicePostureRulesSinglePage = DevicePostureRulesSinglePage;
      Posture2.Integrations = Integrations;
      Posture2.IntegrationsSinglePage = IntegrationsSinglePage;
    })(Posture || (Posture = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/devices/devices.mjs
var Devices, DevicesSinglePage;
var init_devices = __esm({
  "node_modules/cloudflare/resources/zero-trust/devices/devices.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_devices();
    init_dex_tests();
    init_networks();
    init_override_codes();
    init_revoke();
    init_settings11();
    init_unrevoke();
    init_policies5();
    init_posture();
    init_pagination();
    Devices = class extends APIResource {
      static {
        __name(this, "Devices");
      }
      constructor() {
        super(...arguments);
        this.dexTests = new DEXTests(this._client);
        this.networks = new Networks(this._client);
        this.policies = new Policies5(this._client);
        this.posture = new Posture(this._client);
        this.revoke = new Revoke(this._client);
        this.settings = new Settings11(this._client);
        this.unrevoke = new Unrevoke(this._client);
        this.overrideCodes = new OverrideCodes(this._client);
      }
      /**
       * Fetches a list of enrolled devices.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/devices`, DevicesSinglePage, options);
      }
      /**
       * Fetches details for a single device.
       */
      get(deviceId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/devices/${deviceId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    DevicesSinglePage = class extends SinglePage {
      static {
        __name(this, "DevicesSinglePage");
      }
    };
    (function(Devices3) {
      Devices3.DevicesSinglePage = DevicesSinglePage;
      Devices3.DEXTests = DEXTests;
      Devices3.SchemaHTTPSSinglePage = SchemaHTTPSSinglePage;
      Devices3.Networks = Networks;
      Devices3.DeviceNetworksSinglePage = DeviceNetworksSinglePage;
      Devices3.Policies = Policies5;
      Devices3.SettingsPoliciesSinglePage = SettingsPoliciesSinglePage;
      Devices3.Posture = Posture;
      Devices3.DevicePostureRulesSinglePage = DevicePostureRulesSinglePage;
      Devices3.Revoke = Revoke;
      Devices3.Settings = Settings11;
      Devices3.Unrevoke = Unrevoke;
      Devices3.OverrideCodes = OverrideCodes;
    })(Devices || (Devices = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dex/colos.mjs
var Colos, ColoListResponsesSinglePage;
var init_colos = __esm({
  "node_modules/cloudflare/resources/zero-trust/dex/colos.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_colos();
    init_pagination();
    Colos = class extends APIResource {
      static {
        __name(this, "Colos");
      }
      /**
       * List Cloudflare colos that account's devices were connected to during a time
       * period, sorted by usage starting from the most used colo. Colos without traffic
       * are also returned and sorted alphabetically.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/dex/colos`, ColoListResponsesSinglePage, {
          query,
          ...options
        });
      }
    };
    ColoListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "ColoListResponsesSinglePage");
      }
    };
    (function(Colos2) {
      Colos2.ColoListResponsesSinglePage = ColoListResponsesSinglePage;
    })(Colos || (Colos = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dex/traceroute-tests.mjs
var TracerouteTests;
var init_traceroute_tests = __esm({
  "node_modules/cloudflare/resources/zero-trust/dex/traceroute-tests.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    TracerouteTests = class extends APIResource {
      static {
        __name(this, "TracerouteTests");
      }
      /**
       * Get test details and aggregate performance metrics for an traceroute test for a
       * given time period between 1 hour and 7 days.
       */
      get(testId, params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/dex/traceroute-tests/${testId}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get a breakdown of metrics by hop for individual traceroute test runs
       */
      networkPath(testId, params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/dex/traceroute-tests/${testId}/network-path`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get percentiles for a traceroute test for a given time period between 1 hour and
       * 7 days.
       */
      percentiles(testId, params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/dex/traceroute-tests/${testId}/percentiles`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(TracerouteTests2) {
    })(TracerouteTests || (TracerouteTests = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dex/fleet-status/devices.mjs
var Devices2, DeviceListResponsesV4PagePaginationArray;
var init_devices2 = __esm({
  "node_modules/cloudflare/resources/zero-trust/dex/fleet-status/devices.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_devices2();
    init_pagination();
    Devices2 = class extends APIResource {
      static {
        __name(this, "Devices");
      }
      /**
       * List details for devices using WARP
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/dex/fleet-status/devices`, DeviceListResponsesV4PagePaginationArray, { query, ...options });
      }
    };
    DeviceListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "DeviceListResponsesV4PagePaginationArray");
      }
    };
    (function(Devices3) {
      Devices3.DeviceListResponsesV4PagePaginationArray = DeviceListResponsesV4PagePaginationArray;
    })(Devices2 || (Devices2 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dex/fleet-status/fleet-status.mjs
var FleetStatus;
var init_fleet_status = __esm({
  "node_modules/cloudflare/resources/zero-trust/dex/fleet-status/fleet-status.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_devices2();
    FleetStatus = class extends APIResource {
      static {
        __name(this, "FleetStatus");
      }
      constructor() {
        super(...arguments);
        this.devices = new Devices2(this._client);
      }
      /**
       * List details for live (up to 60 minutes) devices using WARP
       */
      live(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/dex/fleet-status/live`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List details for devices using WARP, up to 7 days
       */
      overTime(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/dex/fleet-status/over-time`, {
          query,
          ...options,
          headers: { Accept: "*/*", ...options?.headers }
        });
      }
    };
    (function(FleetStatus2) {
      FleetStatus2.Devices = Devices2;
      FleetStatus2.DeviceListResponsesV4PagePaginationArray = DeviceListResponsesV4PagePaginationArray;
    })(FleetStatus || (FleetStatus = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dex/http-tests/percentiles.mjs
var Percentiles;
var init_percentiles = __esm({
  "node_modules/cloudflare/resources/zero-trust/dex/http-tests/percentiles.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Percentiles = class extends APIResource {
      static {
        __name(this, "Percentiles");
      }
      /**
       * Get percentiles for an http test for a given time period between 1 hour and 7
       * days.
       */
      get(testId, params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/dex/http-tests/${testId}/percentiles`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Percentiles2) {
    })(Percentiles || (Percentiles = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dex/http-tests/http-tests.mjs
var HTTPTests;
var init_http_tests = __esm({
  "node_modules/cloudflare/resources/zero-trust/dex/http-tests/http-tests.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_percentiles();
    HTTPTests = class extends APIResource {
      static {
        __name(this, "HTTPTests");
      }
      constructor() {
        super(...arguments);
        this.percentiles = new Percentiles(this._client);
      }
      /**
       * Get test details and aggregate performance metrics for an http test for a given
       * time period between 1 hour and 7 days.
       */
      get(testId, params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/dex/http-tests/${testId}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(HTTPTests2) {
      HTTPTests2.Percentiles = Percentiles;
    })(HTTPTests || (HTTPTests = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dex/tests/unique-devices.mjs
var UniqueDevices;
var init_unique_devices = __esm({
  "node_modules/cloudflare/resources/zero-trust/dex/tests/unique-devices.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_unique_devices();
    UniqueDevices = class extends APIResource {
      static {
        __name(this, "UniqueDevices");
      }
      /**
       * Returns unique count of devices that have run synthetic application monitoring
       * tests in the past 7 days.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/dex/tests/unique-devices`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    (function(UniqueDevices2) {
      UniqueDevices2.UniqueDevices = UniqueDevices;
    })(UniqueDevices || (UniqueDevices = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dex/tests/tests.mjs
var Tests2, TestListResponsesV4PagePagination;
var init_tests2 = __esm({
  "node_modules/cloudflare/resources/zero-trust/dex/tests/tests.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_tests2();
    init_unique_devices();
    init_pagination();
    Tests2 = class extends APIResource {
      static {
        __name(this, "Tests");
      }
      constructor() {
        super(...arguments);
        this.uniqueDevices = new UniqueDevices(this._client);
      }
      /**
       * List DEX tests
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/dex/tests`, TestListResponsesV4PagePagination, {
          query,
          ...options
        });
      }
    };
    TestListResponsesV4PagePagination = class extends V4PagePagination {
      static {
        __name(this, "TestListResponsesV4PagePagination");
      }
    };
    (function(Tests3) {
      Tests3.Tests = Tests2;
      Tests3.TestListResponsesV4PagePagination = TestListResponsesV4PagePagination;
      Tests3.UniqueDevices = UniqueDevices;
    })(Tests2 || (Tests2 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dex/traceroute-test-results/network-path.mjs
var NetworkPath;
var init_network_path = __esm({
  "node_modules/cloudflare/resources/zero-trust/dex/traceroute-test-results/network-path.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    NetworkPath = class extends APIResource {
      static {
        __name(this, "NetworkPath");
      }
      /**
       * Get a breakdown of hops and performance metrics for a specific traceroute test
       * run
       */
      get(testResultId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/dex/traceroute-test-results/${testResultId}/network-path`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(NetworkPath2) {
    })(NetworkPath || (NetworkPath = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dex/traceroute-test-results/traceroute-test-results.mjs
var TracerouteTestResults;
var init_traceroute_test_results = __esm({
  "node_modules/cloudflare/resources/zero-trust/dex/traceroute-test-results/traceroute-test-results.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_network_path();
    TracerouteTestResults = class extends APIResource {
      static {
        __name(this, "TracerouteTestResults");
      }
      constructor() {
        super(...arguments);
        this.networkPath = new NetworkPath(this._client);
      }
    };
    (function(TracerouteTestResults2) {
      TracerouteTestResults2.NetworkPath = NetworkPath;
    })(TracerouteTestResults || (TracerouteTestResults = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dex/dex.mjs
var DEX;
var init_dex = __esm({
  "node_modules/cloudflare/resources/zero-trust/dex/dex.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_colos();
    init_traceroute_tests();
    init_fleet_status();
    init_http_tests();
    init_tests2();
    init_traceroute_test_results();
    DEX = class extends APIResource {
      static {
        __name(this, "DEX");
      }
      constructor() {
        super(...arguments);
        this.colos = new Colos(this._client);
        this.fleetStatus = new FleetStatus(this._client);
        this.httpTests = new HTTPTests(this._client);
        this.tests = new Tests2(this._client);
        this.tracerouteTestResults = new TracerouteTestResults(this._client);
        this.tracerouteTests = new TracerouteTests(this._client);
      }
    };
    (function(DEX2) {
      DEX2.Colos = Colos;
      DEX2.ColoListResponsesSinglePage = ColoListResponsesSinglePage;
      DEX2.FleetStatus = FleetStatus;
      DEX2.HTTPTests = HTTPTests;
      DEX2.Tests = Tests2;
      DEX2.TestListResponsesV4PagePagination = TestListResponsesV4PagePagination;
      DEX2.TracerouteTestResults = TracerouteTestResults;
      DEX2.TracerouteTests = TracerouteTests;
    })(DEX || (DEX = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dlp/patterns.mjs
var Patterns;
var init_patterns = __esm({
  "node_modules/cloudflare/resources/zero-trust/dlp/patterns.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Patterns = class extends APIResource {
      static {
        __name(this, "Patterns");
      }
      /**
       * Validates whether this pattern is a valid regular expression. Rejects it if the
       * regular expression is too complex or can match an unbounded-length string. Your
       * regex will be rejected if it uses the Kleene Star -- be sure to bound the
       * maximum number of characters that can be matched.
       */
      validate(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/dlp/patterns/validate`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Patterns2) {
    })(Patterns || (Patterns = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dlp/payload-logs.mjs
var PayloadLogs;
var init_payload_logs = __esm({
  "node_modules/cloudflare/resources/zero-trust/dlp/payload-logs.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    PayloadLogs = class extends APIResource {
      static {
        __name(this, "PayloadLogs");
      }
      /**
       * Updates the DLP payload log settings for this account.
       */
      update(params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/dlp/payload_log`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Gets the current DLP payload log settings for this account.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/dlp/payload_log`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(PayloadLogs2) {
    })(PayloadLogs || (PayloadLogs = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dlp/datasets/upload.mjs
var Upload;
var init_upload = __esm({
  "node_modules/cloudflare/resources/zero-trust/dlp/datasets/upload.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Upload = class extends APIResource {
      static {
        __name(this, "Upload");
      }
      /**
       * Prepare to upload a new version of a dataset.
       */
      create(datasetId, params, options) {
        const { account_id } = params;
        return this._client.post(`/accounts/${account_id}/dlp/datasets/${datasetId}/upload`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Upload a new version of a dataset.
       */
      edit(datasetId, version, params, options) {
        const { account_id, body } = params;
        return this._client.post(`/accounts/${account_id}/dlp/datasets/${datasetId}/upload/${version}`, {
          body,
          ...options,
          headers: { "Content-Type": "application/octet-stream", ...options?.headers },
          __binaryRequest: true
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Upload2) {
    })(Upload || (Upload = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dlp/datasets/datasets.mjs
var Datasets3, DatasetsSinglePage;
var init_datasets3 = __esm({
  "node_modules/cloudflare/resources/zero-trust/dlp/datasets/datasets.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_datasets3();
    init_upload();
    init_pagination();
    Datasets3 = class extends APIResource {
      static {
        __name(this, "Datasets");
      }
      constructor() {
        super(...arguments);
        this.upload = new Upload(this._client);
      }
      /**
       * Create a new dataset.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/dlp/datasets`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update details about a dataset.
       */
      update(datasetId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/dlp/datasets/${datasetId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch all datasets with information about available versions.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/dlp/datasets`, DatasetsSinglePage, options);
      }
      /**
       * Delete a dataset.
       *
       * This deletes all versions of the dataset.
       */
      delete(datasetId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/dlp/datasets/${datasetId}`, {
          ...options,
          headers: { Accept: "*/*", ...options?.headers }
        });
      }
      /**
       * Fetch a specific dataset with information about available versions.
       */
      get(datasetId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/dlp/datasets/${datasetId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    DatasetsSinglePage = class extends SinglePage {
      static {
        __name(this, "DatasetsSinglePage");
      }
    };
    (function(Datasets4) {
      Datasets4.DatasetsSinglePage = DatasetsSinglePage;
      Datasets4.Upload = Upload;
    })(Datasets3 || (Datasets3 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dlp/profiles/custom.mjs
var Custom;
var init_custom = __esm({
  "node_modules/cloudflare/resources/zero-trust/dlp/profiles/custom.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Custom = class extends APIResource {
      static {
        __name(this, "Custom");
      }
      /**
       * Creates a set of DLP custom profiles.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/dlp/profiles/custom`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a DLP custom profile.
       */
      update(profileId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/dlp/profiles/custom/${profileId}`, { body, ...options });
      }
      /**
       * Deletes a DLP custom profile.
       */
      delete(profileId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/dlp/profiles/custom/${profileId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a custom DLP profile.
       */
      get(profileId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/dlp/profiles/custom/${profileId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Custom2) {
    })(Custom || (Custom = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dlp/profiles/predefined.mjs
var Predefined;
var init_predefined = __esm({
  "node_modules/cloudflare/resources/zero-trust/dlp/profiles/predefined.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Predefined = class extends APIResource {
      static {
        __name(this, "Predefined");
      }
      /**
       * Updates a DLP predefined profile. Only supports enabling/disabling entries.
       */
      update(profileId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/dlp/profiles/predefined/${profileId}`, {
          body,
          ...options
        });
      }
      /**
       * Fetches a predefined DLP profile.
       */
      get(profileId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/dlp/profiles/predefined/${profileId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Predefined2) {
    })(Predefined || (Predefined = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dlp/profiles/profiles.mjs
var Profiles2, ProfilesSinglePage;
var init_profiles2 = __esm({
  "node_modules/cloudflare/resources/zero-trust/dlp/profiles/profiles.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_profiles2();
    init_custom();
    init_predefined();
    init_pagination();
    Profiles2 = class extends APIResource {
      static {
        __name(this, "Profiles");
      }
      constructor() {
        super(...arguments);
        this.custom = new Custom(this._client);
        this.predefined = new Predefined(this._client);
      }
      /**
       * Lists all DLP profiles in an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/dlp/profiles`, ProfilesSinglePage, options);
      }
      /**
       * Fetches a DLP profile by ID. Supports both predefined and custom profiles
       */
      get(profileId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/dlp/profiles/${profileId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ProfilesSinglePage = class extends SinglePage {
      static {
        __name(this, "ProfilesSinglePage");
      }
    };
    (function(Profiles3) {
      Profiles3.ProfilesSinglePage = ProfilesSinglePage;
      Profiles3.Custom = Custom;
      Profiles3.Predefined = Predefined;
    })(Profiles2 || (Profiles2 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/dlp/dlp.mjs
var DLP;
var init_dlp = __esm({
  "node_modules/cloudflare/resources/zero-trust/dlp/dlp.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_patterns();
    init_payload_logs();
    init_datasets3();
    init_profiles2();
    DLP = class extends APIResource {
      static {
        __name(this, "DLP");
      }
      constructor() {
        super(...arguments);
        this.datasets = new Datasets3(this._client);
        this.patterns = new Patterns(this._client);
        this.payloadLogs = new PayloadLogs(this._client);
        this.profiles = new Profiles2(this._client);
      }
    };
    (function(DLP2) {
      DLP2.Datasets = Datasets3;
      DLP2.DatasetsSinglePage = DatasetsSinglePage;
      DLP2.Patterns = Patterns;
      DLP2.PayloadLogs = PayloadLogs;
      DLP2.Profiles = Profiles2;
      DLP2.ProfilesSinglePage = ProfilesSinglePage;
    })(DLP || (DLP = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/gateway/app-types.mjs
var AppTypes, AppTypesSinglePage;
var init_app_types = __esm({
  "node_modules/cloudflare/resources/zero-trust/gateway/app-types.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_app_types();
    init_pagination();
    AppTypes = class extends APIResource {
      static {
        __name(this, "AppTypes");
      }
      /**
       * Fetches all application and application type mappings.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/gateway/app_types`, AppTypesSinglePage, options);
      }
    };
    AppTypesSinglePage = class extends SinglePage {
      static {
        __name(this, "AppTypesSinglePage");
      }
    };
    (function(AppTypes2) {
      AppTypes2.AppTypesSinglePage = AppTypesSinglePage;
    })(AppTypes || (AppTypes = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/gateway/audit-ssh-settings.mjs
var AuditSSHSettings;
var init_audit_ssh_settings = __esm({
  "node_modules/cloudflare/resources/zero-trust/gateway/audit-ssh-settings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    AuditSSHSettings = class extends APIResource {
      static {
        __name(this, "AuditSSHSettings");
      }
      /**
       * Updates Zero Trust Audit SSH settings.
       */
      update(params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/gateway/audit_ssh_settings`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get all Zero Trust Audit SSH settings for an account.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/gateway/audit_ssh_settings`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(AuditSSHSettings2) {
    })(AuditSSHSettings || (AuditSSHSettings = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/gateway/categories.mjs
var Categories, CategoriesSinglePage;
var init_categories = __esm({
  "node_modules/cloudflare/resources/zero-trust/gateway/categories.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_categories();
    init_pagination();
    Categories = class extends APIResource {
      static {
        __name(this, "Categories");
      }
      /**
       * Fetches a list of all categories.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/gateway/categories`, CategoriesSinglePage, options);
      }
    };
    CategoriesSinglePage = class extends SinglePage {
      static {
        __name(this, "CategoriesSinglePage");
      }
    };
    (function(Categories2) {
      Categories2.CategoriesSinglePage = CategoriesSinglePage;
    })(Categories || (Categories = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/gateway/certificates.mjs
var Certificates3, CertificateListResponsesSinglePage;
var init_certificates3 = __esm({
  "node_modules/cloudflare/resources/zero-trust/gateway/certificates.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_certificates3();
    init_pagination();
    Certificates3 = class extends APIResource {
      static {
        __name(this, "Certificates");
      }
      /**
       * Creates a new Zero Trust certificate.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/gateway/certificates`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches all Zero Trust certificates for an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/gateway/certificates`, CertificateListResponsesSinglePage, options);
      }
      /**
       * Deletes a gateway-managed Zero Trust certificate.
       */
      delete(certificateId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/gateway/certificates/${certificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a single Zero Trust certificate.
       */
      get(certificateId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/gateway/certificates/${certificateId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    CertificateListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "CertificateListResponsesSinglePage");
      }
    };
    (function(Certificates4) {
      Certificates4.CertificateListResponsesSinglePage = CertificateListResponsesSinglePage;
    })(Certificates3 || (Certificates3 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/gateway/configurations.mjs
var Configurations2;
var init_configurations2 = __esm({
  "node_modules/cloudflare/resources/zero-trust/gateway/configurations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Configurations2 = class extends APIResource {
      static {
        __name(this, "Configurations");
      }
      /**
       * Updates the current Zero Trust account configuration.
       */
      update(params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/gateway/configuration`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Patches the current Zero Trust account configuration. This endpoint can update a
       * single subcollection of settings such as `antivirus`, `tls_decrypt`,
       * `activity_log`, `block_page`, `browser_isolation`, `fips`, `body_scanning`, or
       * `certificate`, without updating the entire configuration object. Returns an
       * error if any collection of settings is not properly configured.
       */
      edit(params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/gateway/configuration`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the current Zero Trust account configuration.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/gateway/configuration`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Configurations4) {
    })(Configurations2 || (Configurations2 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/gateway/locations.mjs
var Locations6, LocationsSinglePage;
var init_locations6 = __esm({
  "node_modules/cloudflare/resources/zero-trust/gateway/locations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_locations6();
    init_pagination();
    Locations6 = class extends APIResource {
      static {
        __name(this, "Locations");
      }
      /**
       * Creates a new Zero Trust Gateway location.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/gateway/locations`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a configured Zero Trust Gateway location.
       */
      update(locationId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/gateway/locations/${locationId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches Zero Trust Gateway locations for an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/gateway/locations`, LocationsSinglePage, options);
      }
      /**
       * Deletes a configured Zero Trust Gateway location.
       */
      delete(locationId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/gateway/locations/${locationId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a single Zero Trust Gateway location.
       */
      get(locationId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/gateway/locations/${locationId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    LocationsSinglePage = class extends SinglePage {
      static {
        __name(this, "LocationsSinglePage");
      }
    };
    (function(Locations7) {
      Locations7.LocationsSinglePage = LocationsSinglePage;
    })(Locations6 || (Locations6 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/gateway/logging.mjs
var Logging;
var init_logging = __esm({
  "node_modules/cloudflare/resources/zero-trust/gateway/logging.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Logging = class extends APIResource {
      static {
        __name(this, "Logging");
      }
      /**
       * Updates logging settings for the current Zero Trust account.
       */
      update(params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/gateway/logging`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the current logging settings for Zero Trust account.
       */
      get(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/gateway/logging`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Logging2) {
    })(Logging || (Logging = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/gateway/proxy-endpoints.mjs
var ProxyEndpoints;
var init_proxy_endpoints = __esm({
  "node_modules/cloudflare/resources/zero-trust/gateway/proxy-endpoints.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    ProxyEndpoints = class extends APIResource {
      static {
        __name(this, "ProxyEndpoints");
      }
      /**
       * Creates a new Zero Trust Gateway proxy endpoint.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/gateway/proxy_endpoints`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches all Zero Trust Gateway proxy endpoints for an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/gateway/proxy_endpoints`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Deletes a configured Zero Trust Gateway proxy endpoint.
       */
      delete(proxyEndpointId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/gateway/proxy_endpoints/${proxyEndpointId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a configured Zero Trust Gateway proxy endpoint.
       */
      edit(proxyEndpointId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/gateway/proxy_endpoints/${proxyEndpointId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a single Zero Trust Gateway proxy endpoint.
       */
      get(proxyEndpointId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/gateway/proxy_endpoints/${proxyEndpointId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(ProxyEndpoints2) {
    })(ProxyEndpoints || (ProxyEndpoints = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/gateway/rules.mjs
var Rules11, GatewayRulesSinglePage;
var init_rules11 = __esm({
  "node_modules/cloudflare/resources/zero-trust/gateway/rules.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_rules11();
    init_pagination();
    Rules11 = class extends APIResource {
      static {
        __name(this, "Rules");
      }
      /**
       * Creates a new Zero Trust Gateway rule.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/gateway/rules`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a configured Zero Trust Gateway rule.
       */
      update(ruleId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/gateway/rules/${ruleId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches the Zero Trust Gateway rules for an account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/gateway/rules`, GatewayRulesSinglePage, options);
      }
      /**
       * Deletes a Zero Trust Gateway rule.
       */
      delete(ruleId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/gateway/rules/${ruleId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a single Zero Trust Gateway rule.
       */
      get(ruleId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/gateway/rules/${ruleId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    GatewayRulesSinglePage = class extends SinglePage {
      static {
        __name(this, "GatewayRulesSinglePage");
      }
    };
    (function(Rules12) {
      Rules12.GatewayRulesSinglePage = GatewayRulesSinglePage;
    })(Rules11 || (Rules11 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/gateway/lists/items.mjs
var Items2, ItemListResponsesSinglePage;
var init_items2 = __esm({
  "node_modules/cloudflare/resources/zero-trust/gateway/lists/items.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_items2();
    init_pagination();
    Items2 = class extends APIResource {
      static {
        __name(this, "Items");
      }
      /**
       * Fetches all items in a single Zero Trust list.
       */
      list(listId, params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/gateway/lists/${listId}/items`, ItemListResponsesSinglePage, options);
      }
    };
    ItemListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "ItemListResponsesSinglePage");
      }
    };
    (function(Items3) {
      Items3.ItemListResponsesSinglePage = ItemListResponsesSinglePage;
    })(Items2 || (Items2 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/gateway/lists/lists.mjs
var Lists2, GatewayListsSinglePage;
var init_lists2 = __esm({
  "node_modules/cloudflare/resources/zero-trust/gateway/lists/lists.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_lists2();
    init_items2();
    init_pagination();
    Lists2 = class extends APIResource {
      static {
        __name(this, "Lists");
      }
      constructor() {
        super(...arguments);
        this.items = new Items2(this._client);
      }
      /**
       * Creates a new Zero Trust list.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/gateway/lists`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates a configured Zero Trust list.
       */
      update(listId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/gateway/lists/${listId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches all Zero Trust lists for an account.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/gateway/lists`, GatewayListsSinglePage, {
          query,
          ...options
        });
      }
      /**
       * Deletes a Zero Trust list.
       */
      delete(listId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/gateway/lists/${listId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Appends or removes an item from a configured Zero Trust list.
       */
      edit(listId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/gateway/lists/${listId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a single Zero Trust list.
       */
      get(listId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/gateway/lists/${listId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    GatewayListsSinglePage = class extends SinglePage {
      static {
        __name(this, "GatewayListsSinglePage");
      }
    };
    (function(Lists3) {
      Lists3.GatewayListsSinglePage = GatewayListsSinglePage;
      Lists3.Items = Items2;
      Lists3.ItemListResponsesSinglePage = ItemListResponsesSinglePage;
    })(Lists2 || (Lists2 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/gateway/gateway.mjs
var Gateway;
var init_gateway = __esm({
  "node_modules/cloudflare/resources/zero-trust/gateway/gateway.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_app_types();
    init_audit_ssh_settings();
    init_categories();
    init_certificates3();
    init_configurations2();
    init_locations6();
    init_logging();
    init_proxy_endpoints();
    init_rules11();
    init_lists2();
    Gateway = class extends APIResource {
      static {
        __name(this, "Gateway");
      }
      constructor() {
        super(...arguments);
        this.auditSSHSettings = new AuditSSHSettings(this._client);
        this.categories = new Categories(this._client);
        this.appTypes = new AppTypes(this._client);
        this.configurations = new Configurations2(this._client);
        this.lists = new Lists2(this._client);
        this.locations = new Locations6(this._client);
        this.logging = new Logging(this._client);
        this.proxyEndpoints = new ProxyEndpoints(this._client);
        this.rules = new Rules11(this._client);
        this.certificates = new Certificates3(this._client);
      }
      /**
       * Creates a Zero Trust account with an existing Cloudflare account.
       */
      create(params, options) {
        const { account_id } = params;
        return this._client.post(`/accounts/${account_id}/gateway`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Gets information about the current Zero Trust account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/gateway`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(Gateway2) {
      Gateway2.AuditSSHSettings = AuditSSHSettings;
      Gateway2.Categories = Categories;
      Gateway2.CategoriesSinglePage = CategoriesSinglePage;
      Gateway2.AppTypes = AppTypes;
      Gateway2.AppTypesSinglePage = AppTypesSinglePage;
      Gateway2.Configurations = Configurations2;
      Gateway2.Lists = Lists2;
      Gateway2.GatewayListsSinglePage = GatewayListsSinglePage;
      Gateway2.Locations = Locations6;
      Gateway2.LocationsSinglePage = LocationsSinglePage;
      Gateway2.Logging = Logging;
      Gateway2.ProxyEndpoints = ProxyEndpoints;
      Gateway2.Rules = Rules11;
      Gateway2.GatewayRulesSinglePage = GatewayRulesSinglePage;
      Gateway2.Certificates = Certificates3;
      Gateway2.CertificateListResponsesSinglePage = CertificateListResponsesSinglePage;
    })(Gateway || (Gateway = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/networks/virtual-networks.mjs
var VirtualNetworks, VirtualNetworksSinglePage;
var init_virtual_networks = __esm({
  "node_modules/cloudflare/resources/zero-trust/networks/virtual-networks.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_virtual_networks();
    init_pagination();
    VirtualNetworks = class extends APIResource {
      static {
        __name(this, "VirtualNetworks");
      }
      /**
       * Adds a new virtual network to an account.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/teamnet/virtual_networks`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists and filters virtual networks in an account.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/teamnet/virtual_networks`, VirtualNetworksSinglePage, { query, ...options });
      }
      /**
       * Deletes an existing virtual network.
       */
      delete(virtualNetworkId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/teamnet/virtual_networks/${virtualNetworkId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an existing virtual network.
       */
      edit(virtualNetworkId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/teamnet/virtual_networks/${virtualNetworkId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    VirtualNetworksSinglePage = class extends SinglePage {
      static {
        __name(this, "VirtualNetworksSinglePage");
      }
    };
    (function(VirtualNetworks2) {
      VirtualNetworks2.VirtualNetworksSinglePage = VirtualNetworksSinglePage;
    })(VirtualNetworks || (VirtualNetworks = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/networks/routes/ips.mjs
var IPs5;
var init_ips5 = __esm({
  "node_modules/cloudflare/resources/zero-trust/networks/routes/ips.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    IPs5 = class extends APIResource {
      static {
        __name(this, "IPs");
      }
      /**
       * Fetches routes that contain the given IP address.
       */
      get(ip, params, options) {
        const { account_id, ...query } = params;
        return this._client.get(`/accounts/${account_id}/teamnet/routes/ip/${ip}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(IPs6) {
    })(IPs5 || (IPs5 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/networks/routes/networks.mjs
var Networks2;
var init_networks2 = __esm({
  "node_modules/cloudflare/resources/zero-trust/networks/routes/networks.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Networks2 = class extends APIResource {
      static {
        __name(this, "Networks");
      }
      /**
       * Routes a private network through a Cloudflare Tunnel. The CIDR in
       * `ip_network_encoded` must be written in URL-encoded format.
       */
      create(ipNetworkEncoded, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/teamnet/routes/network/${ipNetworkEncoded}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Deletes a private network route from an account. The CIDR in
       * `ip_network_encoded` must be written in URL-encoded format. If no
       * virtual_network_id is provided it will delete the route from the default vnet.
       * If no tun_type is provided it will fetch the type from the tunnel_id or if that
       * is missing it will assume Cloudflare Tunnel as default. If tunnel_id is provided
       * it will delete the route from that tunnel, otherwise it will delete the route
       * based on the vnet and tun_type.
       */
      delete(ipNetworkEncoded, params, options) {
        const { account_id, tun_type, tunnel_id, virtual_network_id } = params;
        return this._client.delete(`/accounts/${account_id}/teamnet/routes/network/${ipNetworkEncoded}`, {
          query: { tun_type, tunnel_id, virtual_network_id },
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an existing private network route in an account. The CIDR in
       * `ip_network_encoded` must be written in URL-encoded format.
       */
      edit(ipNetworkEncoded, params, options) {
        const { account_id } = params;
        return this._client.patch(`/accounts/${account_id}/teamnet/routes/network/${ipNetworkEncoded}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Networks4) {
    })(Networks2 || (Networks2 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/networks/routes/routes.mjs
var Routes3, TeamnetsV4PagePaginationArray;
var init_routes3 = __esm({
  "node_modules/cloudflare/resources/zero-trust/networks/routes/routes.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_routes3();
    init_ips5();
    init_networks2();
    init_pagination();
    Routes3 = class extends APIResource {
      static {
        __name(this, "Routes");
      }
      constructor() {
        super(...arguments);
        this.ips = new IPs5(this._client);
        this.networks = new Networks2(this._client);
      }
      /**
       * Routes a private network through a Cloudflare Tunnel.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/teamnet/routes`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists and filters private network routes in an account.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/teamnet/routes`, TeamnetsV4PagePaginationArray, {
          query,
          ...options
        });
      }
      /**
       * Deletes a private network route from an account.
       */
      delete(routeId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/teamnet/routes/${routeId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an existing private network route in an account. The fields that are
       * meant to be updated should be provided in the body of the request.
       */
      edit(routeId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/teamnet/routes/${routeId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    TeamnetsV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "TeamnetsV4PagePaginationArray");
      }
    };
    (function(Routes4) {
      Routes4.TeamnetsV4PagePaginationArray = TeamnetsV4PagePaginationArray;
      Routes4.IPs = IPs5;
      Routes4.Networks = Networks2;
    })(Routes3 || (Routes3 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/networks/networks.mjs
var Networks3;
var init_networks3 = __esm({
  "node_modules/cloudflare/resources/zero-trust/networks/networks.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_virtual_networks();
    init_routes3();
    Networks3 = class extends APIResource {
      static {
        __name(this, "Networks");
      }
      constructor() {
        super(...arguments);
        this.routes = new Routes3(this._client);
        this.virtualNetworks = new VirtualNetworks(this._client);
      }
    };
    (function(Networks4) {
      Networks4.Routes = Routes3;
      Networks4.TeamnetsV4PagePaginationArray = TeamnetsV4PagePaginationArray;
      Networks4.VirtualNetworks = VirtualNetworks;
      Networks4.VirtualNetworksSinglePage = VirtualNetworksSinglePage;
    })(Networks3 || (Networks3 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/risk-scoring/behaviours.mjs
var Behaviours;
var init_behaviours = __esm({
  "node_modules/cloudflare/resources/zero-trust/risk-scoring/behaviours.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Behaviours = class extends APIResource {
      static {
        __name(this, "Behaviours");
      }
      /**
       * Update configuration for risk behaviors
       */
      update(accountIdentifier, body, options) {
        return this._client.put(`/accounts/${accountIdentifier}/zt_risk_scoring/behaviors`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get all behaviors and associated configuration
       */
      get(accountIdentifier, options) {
        return this._client.get(`/accounts/${accountIdentifier}/zt_risk_scoring/behaviors`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Behaviours2) {
    })(Behaviours || (Behaviours = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/risk-scoring/summary.mjs
var Summary7;
var init_summary7 = __esm({
  "node_modules/cloudflare/resources/zero-trust/risk-scoring/summary.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    Summary7 = class extends APIResource {
      static {
        __name(this, "Summary");
      }
      get(accountIdentifier, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(accountIdentifier, {}, query);
        }
        return this._client.get(`/accounts/${accountIdentifier}/zt_risk_scoring/summary`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Summary8) {
    })(Summary7 || (Summary7 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/risk-scoring/integrations/references.mjs
var References3;
var init_references3 = __esm({
  "node_modules/cloudflare/resources/zero-trust/risk-scoring/integrations/references.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    References3 = class extends APIResource {
      static {
        __name(this, "References");
      }
      /**
       * Get risk score integration by reference id.
       */
      get(referenceId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/zt_risk_scoring/integrations/reference_id/${referenceId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(References4) {
    })(References3 || (References3 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/risk-scoring/integrations/integrations.mjs
var Integrations2, IntegrationListResponsesSinglePage;
var init_integrations2 = __esm({
  "node_modules/cloudflare/resources/zero-trust/risk-scoring/integrations/integrations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_integrations2();
    init_references3();
    init_pagination();
    Integrations2 = class extends APIResource {
      static {
        __name(this, "Integrations");
      }
      constructor() {
        super(...arguments);
        this.references = new References3(this._client);
      }
      /**
       * Create new risk score integration.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/zt_risk_scoring/integrations`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Update a risk score integration.
       *
       * Overwrite the reference_id, tenant_url, and active values with the ones provided
       */
      update(integrationId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/zt_risk_scoring/integrations/${integrationId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * List all risk score integrations for the account.
       */
      list(params, options) {
        const { account_id } = params;
        return this._client.getAPIList(`/accounts/${account_id}/zt_risk_scoring/integrations`, IntegrationListResponsesSinglePage, options);
      }
      /**
       * Delete a risk score integration.
       */
      delete(integrationId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/zt_risk_scoring/integrations/${integrationId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get risk score integration by id.
       */
      get(integrationId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/zt_risk_scoring/integrations/${integrationId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    IntegrationListResponsesSinglePage = class extends SinglePage {
      static {
        __name(this, "IntegrationListResponsesSinglePage");
      }
    };
    (function(Integrations3) {
      Integrations3.IntegrationListResponsesSinglePage = IntegrationListResponsesSinglePage;
      Integrations3.References = References3;
    })(Integrations2 || (Integrations2 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/risk-scoring/risk-scoring.mjs
var RiskScoring;
var init_risk_scoring = __esm({
  "node_modules/cloudflare/resources/zero-trust/risk-scoring/risk-scoring.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_behaviours();
    init_summary7();
    init_integrations2();
    RiskScoring = class extends APIResource {
      static {
        __name(this, "RiskScoring");
      }
      constructor() {
        super(...arguments);
        this.behaviours = new Behaviours(this._client);
        this.summary = new Summary7(this._client);
        this.integrations = new Integrations2(this._client);
      }
      get(accountIdentifier, userId, query = {}, options) {
        if (isRequestOptions(query)) {
          return this.get(accountIdentifier, userId, {}, query);
        }
        return this._client.get(`/accounts/${accountIdentifier}/zt_risk_scoring/${userId}`, {
          query,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Clear the risk score for a particular user
       */
      reset(accountIdentifier, userId, options) {
        return this._client.post(`/accounts/${accountIdentifier}/zt_risk_scoring/${userId}/reset`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    (function(RiskScoring2) {
      RiskScoring2.Behaviours = Behaviours;
      RiskScoring2.Summary = Summary7;
      RiskScoring2.Integrations = Integrations2;
      RiskScoring2.IntegrationListResponsesSinglePage = IntegrationListResponsesSinglePage;
    })(RiskScoring || (RiskScoring = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/tunnels/configurations.mjs
var Configurations3;
var init_configurations3 = __esm({
  "node_modules/cloudflare/resources/zero-trust/tunnels/configurations.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Configurations3 = class extends APIResource {
      static {
        __name(this, "Configurations");
      }
      /**
       * Adds or updates the configuration for a remotely-managed tunnel.
       */
      update(tunnelId, params, options) {
        const { account_id, ...body } = params;
        return this._client.put(`/accounts/${account_id}/cfd_tunnel/${tunnelId}/configurations`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Gets the configuration for a remotely-managed tunnel
       */
      get(tunnelId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/cfd_tunnel/${tunnelId}/configurations`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Configurations4) {
    })(Configurations3 || (Configurations3 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/tunnels/connections.mjs
var Connections2;
var init_connections2 = __esm({
  "node_modules/cloudflare/resources/zero-trust/tunnels/connections.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Connections2 = class extends APIResource {
      static {
        __name(this, "Connections");
      }
      /**
       * Removes connections that are in a disconnected or pending reconnect state. We
       * recommend running this command after shutting down a tunnel.
       */
      delete(tunnelId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/tunnels/${tunnelId}/connections`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches connection details for a Cloudflare Tunnel.
       */
      get(tunnelId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/cfd_tunnel/${tunnelId}/connections`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Connections3) {
    })(Connections2 || (Connections2 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/tunnels/connectors.mjs
var Connectors2;
var init_connectors2 = __esm({
  "node_modules/cloudflare/resources/zero-trust/tunnels/connectors.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Connectors2 = class extends APIResource {
      static {
        __name(this, "Connectors");
      }
      /**
       * Fetches connector and connection details for a Cloudflare Tunnel.
       */
      get(tunnelId, connectorId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/cfd_tunnel/${tunnelId}/connectors/${connectorId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Connectors3) {
    })(Connectors2 || (Connectors2 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/tunnels/management.mjs
var Management;
var init_management = __esm({
  "node_modules/cloudflare/resources/zero-trust/tunnels/management.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Management = class extends APIResource {
      static {
        __name(this, "Management");
      }
      /**
       * Gets a management token used to access the management resources (i.e. Streaming
       * Logs) of a tunnel.
       */
      create(tunnelId, params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/cfd_tunnel/${tunnelId}/management`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Management2) {
    })(Management || (Management = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/tunnels/token.mjs
var Token2;
var init_token2 = __esm({
  "node_modules/cloudflare/resources/zero-trust/tunnels/token.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Token2 = class extends APIResource {
      static {
        __name(this, "Token");
      }
      /**
       * Gets the token used to associate cloudflared with a specific tunnel.
       */
      get(tunnelId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/cfd_tunnel/${tunnelId}/token`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Token3) {
    })(Token2 || (Token2 = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/tunnels/tunnels.mjs
var Tunnels, TunnelListResponsesV4PagePaginationArray;
var init_tunnels = __esm({
  "node_modules/cloudflare/resources/zero-trust/tunnels/tunnels.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_tunnels();
    init_configurations3();
    init_connections2();
    init_connectors2();
    init_management();
    init_token2();
    init_pagination();
    Tunnels = class extends APIResource {
      static {
        __name(this, "Tunnels");
      }
      constructor() {
        super(...arguments);
        this.configurations = new Configurations3(this._client);
        this.connections = new Connections2(this._client);
        this.token = new Token2(this._client);
        this.connectors = new Connectors2(this._client);
        this.management = new Management(this._client);
      }
      /**
       * Creates a new Argo Tunnel in an account.
       */
      create(params, options) {
        const { account_id, ...body } = params;
        return this._client.post(`/accounts/${account_id}/tunnels`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists and filters all types of Tunnels in an account.
       */
      list(params, options) {
        const { account_id, ...query } = params;
        return this._client.getAPIList(`/accounts/${account_id}/tunnels`, TunnelListResponsesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Deletes an Argo Tunnel from an account.
       */
      delete(tunnelId, params, options) {
        const { account_id } = params;
        return this._client.delete(`/accounts/${account_id}/tunnels/${tunnelId}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Updates an existing Cloudflare Tunnel.
       */
      edit(tunnelId, params, options) {
        const { account_id, ...body } = params;
        return this._client.patch(`/accounts/${account_id}/cfd_tunnel/${tunnelId}`, {
          body,
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetches a single Argo Tunnel.
       */
      get(tunnelId, params, options) {
        const { account_id } = params;
        return this._client.get(`/accounts/${account_id}/tunnels/${tunnelId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    TunnelListResponsesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "TunnelListResponsesV4PagePaginationArray");
      }
    };
    (function(Tunnels2) {
      Tunnels2.TunnelListResponsesV4PagePaginationArray = TunnelListResponsesV4PagePaginationArray;
      Tunnels2.Configurations = Configurations3;
      Tunnels2.Connections = Connections2;
      Tunnels2.Token = Token2;
      Tunnels2.Connectors = Connectors2;
      Tunnels2.Management = Management;
    })(Tunnels || (Tunnels = {}));
  }
});

// node_modules/cloudflare/resources/zero-trust/zero-trust.mjs
var ZeroTrust;
var init_zero_trust = __esm({
  "node_modules/cloudflare/resources/zero-trust/zero-trust.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_connectivity_settings();
    init_identity_providers();
    init_organizations2();
    init_seats();
    init_access();
    init_devices();
    init_dex();
    init_dlp();
    init_gateway();
    init_networks3();
    init_risk_scoring();
    init_tunnels();
    ZeroTrust = class extends APIResource {
      static {
        __name(this, "ZeroTrust");
      }
      constructor() {
        super(...arguments);
        this.devices = new Devices(this._client);
        this.identityProviders = new IdentityProviders(this._client);
        this.organizations = new Organizations2(this._client);
        this.seats = new Seats(this._client);
        this.access = new Access(this._client);
        this.dex = new DEX(this._client);
        this.tunnels = new Tunnels(this._client);
        this.connectivitySettings = new ConnectivitySettings(this._client);
        this.dlp = new DLP(this._client);
        this.gateway = new Gateway(this._client);
        this.networks = new Networks3(this._client);
        this.riskScoring = new RiskScoring(this._client);
      }
    };
    (function(ZeroTrust2) {
      ZeroTrust2.Devices = Devices;
      ZeroTrust2.DevicesSinglePage = DevicesSinglePage;
      ZeroTrust2.IdentityProviders = IdentityProviders;
      ZeroTrust2.IdentityProviderListResponsesSinglePage = IdentityProviderListResponsesSinglePage;
      ZeroTrust2.Organizations = Organizations2;
      ZeroTrust2.Seats = Seats;
      ZeroTrust2.Access = Access;
      ZeroTrust2.DEX = DEX;
      ZeroTrust2.Tunnels = Tunnels;
      ZeroTrust2.TunnelListResponsesV4PagePaginationArray = TunnelListResponsesV4PagePaginationArray;
      ZeroTrust2.ConnectivitySettings = ConnectivitySettings;
      ZeroTrust2.DLP = DLP;
      ZeroTrust2.Gateway = Gateway;
      ZeroTrust2.Networks = Networks3;
      ZeroTrust2.RiskScoring = RiskScoring;
    })(ZeroTrust || (ZeroTrust = {}));
  }
});

// node_modules/cloudflare/resources/zones/activation-check.mjs
var ActivationCheck;
var init_activation_check = __esm({
  "node_modules/cloudflare/resources/zones/activation-check.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    ActivationCheck = class extends APIResource {
      static {
        __name(this, "ActivationCheck");
      }
      /**
       * Triggeres a new activation check for a PENDING Zone. This can be triggered every
       * 5 min for paygo/ent customers, every hour for FREE Zones.
       */
      trigger(params, options) {
        const { zone_id } = params;
        return this._client.put(`/zones/${zone_id}/activation_check`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(ActivationCheck2) {
    })(ActivationCheck || (ActivationCheck = {}));
  }
});

// node_modules/cloudflare/resources/zones/custom-nameservers.mjs
var CustomNameservers2;
var init_custom_nameservers2 = __esm({
  "node_modules/cloudflare/resources/zones/custom-nameservers.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    CustomNameservers2 = class extends APIResource {
      static {
        __name(this, "CustomNameservers");
      }
      /**
       * Set metadata for account-level custom nameservers on a zone.
       *
       * If you would like new zones in the account to use account custom nameservers by
       * default, use PUT /accounts/:identifier to set the account setting
       * use_account_custom_ns_by_default to true.
       */
      update(params, options) {
        const { zone_id, ...body } = params;
        return this._client.put(`/zones/${zone_id}/custom_ns`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Get metadata for account-level custom nameservers on a zone.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/custom_ns`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(CustomNameservers3) {
    })(CustomNameservers2 || (CustomNameservers2 = {}));
  }
});

// node_modules/cloudflare/resources/zones/holds.mjs
var Holds;
var init_holds = __esm({
  "node_modules/cloudflare/resources/zones/holds.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Holds = class extends APIResource {
      static {
        __name(this, "Holds");
      }
      /**
       * Enforce a zone hold on the zone, blocking the creation and activation of zones
       * with this zone's hostname.
       */
      create(params, options) {
        const { zone_id, include_subdomains } = params;
        return this._client.post(`/zones/${zone_id}/hold`, {
          query: { include_subdomains },
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Stop enforcement of a zone hold on the zone, permanently or temporarily,
       * allowing the creation and activation of zones with this zone's hostname.
       */
      delete(params, options) {
        const { zone_id, hold_after } = params;
        return this._client.delete(`/zones/${zone_id}/hold`, {
          query: { hold_after },
          ...options
        })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Retrieve whether the zone is subject to a zone hold, and metadata about the
       * hold.
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/hold`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Holds2) {
    })(Holds || (Holds = {}));
  }
});

// node_modules/cloudflare/resources/zones/settings.mjs
var Settings12;
var init_settings12 = __esm({
  "node_modules/cloudflare/resources/zones/settings.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    Settings12 = class extends APIResource {
      static {
        __name(this, "Settings");
      }
      /**
       * Updates a single zone setting by the identifier
       */
      edit(settingId, params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}/settings/${settingId}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Fetch a single zone setting by name
       */
      get(settingId, params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}/settings/${settingId}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Settings13) {
    })(Settings12 || (Settings12 = {}));
  }
});

// node_modules/cloudflare/resources/zones/subscriptions.mjs
var Subscriptions3;
var init_subscriptions3 = __esm({
  "node_modules/cloudflare/resources/zones/subscriptions.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_subscriptions();
    Subscriptions3 = class extends APIResource {
      static {
        __name(this, "Subscriptions");
      }
      /**
       * Create a zone subscription, either plan or add-ons.
       */
      create(identifier, body, options) {
        return this._client.post(`/zones/${identifier}/subscription`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Lists all of an account's subscriptions.
       */
      list(accountIdentifier, options) {
        return this._client.getAPIList(`/accounts/${accountIdentifier}/subscriptions`, SubscriptionsSinglePage, options);
      }
      /**
       * Lists zone subscription details.
       */
      get(identifier, options) {
        return this._client.get(`/zones/${identifier}/subscription`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    /* @__PURE__ */ (function(Subscriptions4) {
    })(Subscriptions3 || (Subscriptions3 = {}));
  }
});

// node_modules/cloudflare/resources/zones/zones.mjs
var Zones2, ZonesV4PagePaginationArray;
var init_zones2 = __esm({
  "node_modules/cloudflare/resources/zones/zones.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_resource();
    init_core();
    init_activation_check();
    init_custom_nameservers2();
    init_holds();
    init_settings12();
    init_subscriptions3();
    init_pagination();
    Zones2 = class extends APIResource {
      static {
        __name(this, "Zones");
      }
      constructor() {
        super(...arguments);
        this.activationCheck = new ActivationCheck(this._client);
        this.settings = new Settings12(this._client);
        this.customNameservers = new CustomNameservers2(this._client);
        this.holds = new Holds(this._client);
        this.subscriptions = new Subscriptions3(this._client);
      }
      /**
       * Create Zone
       */
      create(body, options) {
        return this._client.post("/zones", { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      list(query = {}, options) {
        if (isRequestOptions(query)) {
          return this.list({}, query);
        }
        return this._client.getAPIList("/zones", ZonesV4PagePaginationArray, { query, ...options });
      }
      /**
       * Deletes an existing zone.
       */
      delete(params, options) {
        const { zone_id } = params;
        return this._client.delete(`/zones/${zone_id}`, options)._thenUnwrap((obj) => obj.result);
      }
      /**
       * Edits a zone. Only one zone property can be changed at a time.
       */
      edit(params, options) {
        const { zone_id, ...body } = params;
        return this._client.patch(`/zones/${zone_id}`, { body, ...options })._thenUnwrap((obj) => obj.result);
      }
      /**
       * Zone Details
       */
      get(params, options) {
        const { zone_id } = params;
        return this._client.get(`/zones/${zone_id}`, options)._thenUnwrap((obj) => obj.result);
      }
    };
    ZonesV4PagePaginationArray = class extends V4PagePaginationArray {
      static {
        __name(this, "ZonesV4PagePaginationArray");
      }
    };
    (function(Zones3) {
      Zones3.ActivationCheck = ActivationCheck;
      Zones3.Settings = Settings12;
      Zones3.CustomNameservers = CustomNameservers2;
      Zones3.Holds = Holds;
      Zones3.Subscriptions = Subscriptions3;
    })(Zones2 || (Zones2 = {}));
  }
});

// node_modules/cloudflare/resources/index.mjs
var init_resources = __esm({
  "node_modules/cloudflare/resources/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_shared();
    init_acm();
    init_ai_gateway();
    init_api_gateway();
    init_accounts();
    init_addressing();
    init_alerting();
    init_argo();
    init_audit_logs();
    init_billing();
    init_bot_management();
    init_brand_protection();
    init_cache();
    init_calls();
    init_certificate_authorities();
    init_challenges();
    init_client_certificates();
    init_cloud_connector();
    init_cloudforce_one();
    init_custom_certificates();
    init_custom_hostnames();
    init_custom_nameservers();
    init_d1();
    init_dcv_delegation();
    init_dns();
    init_dnssec();
    init_diagnostics();
    init_durable_objects();
    init_email_routing();
    init_event_notifications();
    init_filters();
    init_firewall2();
    init_healthchecks();
    init_hostnames();
    init_hyperdrive();
    init_iam();
    init_ips2();
    init_images();
    init_intel();
    init_kv();
    init_keyless_certificates();
    init_load_balancers();
    init_logpush();
    init_logs2();
    init_mtls_certificates();
    init_magic_network_monitoring();
    init_magic_transit();
    init_managed_headers();
    init_memberships();
    init_origin_ca_certificates();
    init_origin_post_quantum_encryption();
    init_origin_tls_client_auth();
    init_pcaps();
    init_page_shield();
    init_pagerules();
    init_pages();
    init_plans();
    init_queues2();
    init_r22();
    init_rum();
    init_radar();
    init_rate_limits();
    init_rate_plans();
    init_registrar();
    init_request_tracers();
    init_rules7();
    init_rulesets();
    init_ssl();
    init_secondary_dns();
    init_snippets();
    init_spectrum();
    init_speed2();
    init_storage();
    init_stream();
    init_subscriptions2();
    init_url_normalization();
    init_url_scanner();
    init_user();
    init_vectorize();
    init_warp_connector();
    init_waiting_rooms();
    init_web3();
    init_workers();
    init_workers_for_platforms();
    init_zero_trust();
    init_zones2();
  }
});

// node_modules/cloudflare/index.mjs
var qs, _a, Cloudflare, CloudflareError2, APIError2, APIConnectionError2, APIConnectionTimeoutError2, APIUserAbortError2, NotFoundError2, ConflictError2, RateLimitError2, BadRequestError2, AuthenticationError2, InternalServerError2, PermissionDeniedError2, UnprocessableEntityError2, cloudflare_default;
var init_cloudflare = __esm({
  "node_modules/cloudflare/index.mjs"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_error();
    init_uploads();
    qs = __toESM(require_lib(), 1);
    init_core();
    init_pagination();
    init_resources();
    Cloudflare = class extends APIClient {
      static {
        __name(this, "Cloudflare");
      }
      /**
       * API Client for interfacing with the Cloudflare API.
       *
       * @param {string | null | undefined} [opts.apiToken=process.env['CLOUDFLARE_API_TOKEN'] ?? null]
       * @param {string | null | undefined} [opts.apiKey=process.env['CLOUDFLARE_API_KEY'] ?? null]
       * @param {string | null | undefined} [opts.apiEmail=process.env['CLOUDFLARE_EMAIL'] ?? null]
       * @param {string | null | undefined} [opts.userServiceKey=process.env['CLOUDFLARE_API_USER_SERVICE_KEY'] ?? null]
       * @param {string} [opts.baseURL=process.env['CLOUDFLARE_BASE_URL'] ?? https://api.cloudflare.com/client/v4] - Override the default base URL for the API.
       * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
       * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
       * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
       * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
       * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
       * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
       */
      constructor({ baseURL = readEnv("CLOUDFLARE_BASE_URL"), apiToken = readEnv("CLOUDFLARE_API_TOKEN") ?? null, apiKey = readEnv("CLOUDFLARE_API_KEY") ?? null, apiEmail = readEnv("CLOUDFLARE_EMAIL") ?? null, userServiceKey = readEnv("CLOUDFLARE_API_USER_SERVICE_KEY") ?? null, ...opts } = {}) {
        const options = {
          apiToken,
          apiKey,
          apiEmail,
          userServiceKey,
          ...opts,
          baseURL: baseURL || `https://api.cloudflare.com/client/v4`
        };
        super({
          baseURL: options.baseURL,
          timeout: options.timeout ?? 6e4,
          httpAgent: options.httpAgent,
          maxRetries: options.maxRetries,
          fetch: options.fetch
        });
        this.accounts = new Accounts(this);
        this.originCACertificates = new OriginCACertificates(this);
        this.ips = new IPs2(this);
        this.memberships = new Memberships(this);
        this.user = new User(this);
        this.zones = new Zones2(this);
        this.loadBalancers = new LoadBalancers(this);
        this.cache = new Cache(this);
        this.ssl = new SSL(this);
        this.subscriptions = new Subscriptions2(this);
        this.acm = new ACM(this);
        this.argo = new Argo(this);
        this.plans = new Plans(this);
        this.ratePlans = new RatePlans(this);
        this.certificateAuthorities = new CertificateAuthorities(this);
        this.clientCertificates = new ClientCertificates(this);
        this.customCertificates = new CustomCertificates(this);
        this.customHostnames = new CustomHostnames(this);
        this.customNameservers = new CustomNameservers(this);
        this.dns = new DNS(this);
        this.dnssec = new DNSSECResource(this);
        this.emailRouting = new EmailRouting(this);
        this.filters = new Filters(this);
        this.firewall = new Firewall(this);
        this.healthchecks = new Healthchecks(this);
        this.keylessCertificates = new KeylessCertificates(this);
        this.logpush = new Logpush(this);
        this.logs = new Logs2(this);
        this.originTLSClientAuth = new OriginTLSClientAuth(this);
        this.pagerules = new Pagerules(this);
        this.rateLimits = new RateLimits(this);
        this.secondaryDNS = new SecondaryDNS(this);
        this.waitingRooms = new WaitingRooms(this);
        this.web3 = new Web3(this);
        this.workers = new Workers(this);
        this.kv = new KV(this);
        this.durableObjects = new DurableObjects(this);
        this.queues = new Queues2(this);
        this.apiGateway = new APIGateway(this);
        this.managedHeaders = new ManagedHeaders(this);
        this.pageShield = new PageShield(this);
        this.rulesets = new Rulesets(this);
        this.urlNormalization = new URLNormalization(this);
        this.spectrum = new Spectrum(this);
        this.addressing = new Addressing(this);
        this.auditLogs = new AuditLogs(this);
        this.billing = new Billing(this);
        this.brandProtection = new BrandProtection(this);
        this.diagnostics = new Diagnostics(this);
        this.images = new Images(this);
        this.intel = new Intel(this);
        this.magicTransit = new MagicTransit(this);
        this.magicNetworkMonitoring = new MagicNetworkMonitoring(this);
        this.mtlsCertificates = new MTLSCertificates(this);
        this.pages = new Pages(this);
        this.pcaps = new PCAPs(this);
        this.registrar = new Registrar(this);
        this.requestTracers = new RequestTracers(this);
        this.rules = new Rules7(this);
        this.storage = new Storage(this);
        this.stream = new Stream(this);
        this.alerting = new Alerting(this);
        this.d1 = new D1Resource(this);
        this.r2 = new R22(this);
        this.warpConnector = new WARPConnector(this);
        this.workersForPlatforms = new WorkersForPlatforms(this);
        this.zeroTrust = new ZeroTrust(this);
        this.challenges = new Challenges(this);
        this.hyperdrive = new HyperdriveResource(this);
        this.rum = new RUM(this);
        this.vectorize = new Vectorize(this);
        this.urlScanner = new URLScanner(this);
        this.radar = new Radar(this);
        this.botManagement = new BotManagement(this);
        this.originPostQuantumEncryption = new OriginPostQuantumEncryption(this);
        this.speed = new Speed2(this);
        this.dcvDelegation = new DCVDelegation(this);
        this.hostnames = new Hostnames(this);
        this.snippets = new Snippets(this);
        this.calls = new Calls(this);
        this.cloudforceOne = new CloudforceOne(this);
        this.eventNotifications = new EventNotifications(this);
        this.aiGateway = new AIGateway(this);
        this.iam = new IAM(this);
        this.cloudConnector = new CloudConnector(this);
        this._options = options;
        this.apiToken = apiToken;
        this.apiKey = apiKey;
        this.apiEmail = apiEmail;
        this.userServiceKey = userServiceKey;
      }
      defaultQuery() {
        return this._options.defaultQuery;
      }
      defaultHeaders(opts) {
        return {
          ...super.defaultHeaders(opts),
          "X-Auth-Key": this.apiKey,
          "X-Auth-Email": this.apiEmail,
          ...this._options.defaultHeaders
        };
      }
      validateHeaders(headers, customHeaders) {
        if (this.apiEmail && headers["x-auth-email"]) {
          return;
        }
        if (customHeaders["x-auth-email"] === null) {
          return;
        }
        if (this.apiKey && headers["x-auth-key"]) {
          return;
        }
        if (customHeaders["x-auth-key"] === null) {
          return;
        }
        if (this.apiToken && headers["authorization"]) {
          return;
        }
        if (customHeaders["authorization"] === null) {
          return;
        }
        if (this.userServiceKey && headers["x-auth-user-service-key"]) {
          return;
        }
        if (customHeaders["x-auth-user-service-key"] === null) {
          return;
        }
        throw new Error('Could not resolve authentication method. Expected one of apiEmail, apiKey, apiToken or userServiceKey to be set. Or for one of the "X-Auth-Email", "X-Auth-Key", "Authorization" or "X-Auth-User-Service-Key" headers to be explicitly omitted');
      }
      authHeaders(opts) {
        const apiEmailAuth = this.apiEmailAuth(opts);
        const apiKeyAuth = this.apiKeyAuth(opts);
        const apiTokenAuth = this.apiTokenAuth(opts);
        const userServiceKeyAuth = this.userServiceKeyAuth(opts);
        if (apiEmailAuth != null && !isEmptyObj(apiEmailAuth) && apiKeyAuth != null && !isEmptyObj(apiKeyAuth)) {
          return { ...apiEmailAuth, ...apiKeyAuth };
        }
        if (apiTokenAuth != null && !isEmptyObj(apiTokenAuth)) {
          return apiTokenAuth;
        }
        if (userServiceKeyAuth != null && !isEmptyObj(userServiceKeyAuth)) {
          return userServiceKeyAuth;
        }
        return {};
      }
      apiEmailAuth(opts) {
        if (this.apiEmail == null) {
          return {};
        }
        return { "X-Auth-Email": this.apiEmail };
      }
      apiKeyAuth(opts) {
        if (this.apiKey == null) {
          return {};
        }
        return { "X-Auth-Key": this.apiKey };
      }
      apiTokenAuth(opts) {
        if (this.apiToken == null) {
          return {};
        }
        return { Authorization: `Bearer ${this.apiToken}` };
      }
      userServiceKeyAuth(opts) {
        if (this.userServiceKey == null) {
          return {};
        }
        return { "X-Auth-User-Service-Key": this.userServiceKey };
      }
      stringifyQuery(query) {
        return qs.stringify(query, { allowDots: true, arrayFormat: "repeat" });
      }
    };
    _a = Cloudflare;
    Cloudflare.Cloudflare = _a;
    Cloudflare.CloudflareError = CloudflareError;
    Cloudflare.APIError = APIError;
    Cloudflare.APIConnectionError = APIConnectionError;
    Cloudflare.APIConnectionTimeoutError = APIConnectionTimeoutError;
    Cloudflare.APIUserAbortError = APIUserAbortError;
    Cloudflare.NotFoundError = NotFoundError;
    Cloudflare.ConflictError = ConflictError;
    Cloudflare.RateLimitError = RateLimitError;
    Cloudflare.BadRequestError = BadRequestError;
    Cloudflare.AuthenticationError = AuthenticationError;
    Cloudflare.InternalServerError = InternalServerError;
    Cloudflare.PermissionDeniedError = PermissionDeniedError;
    Cloudflare.UnprocessableEntityError = UnprocessableEntityError;
    Cloudflare.toFile = toFile;
    Cloudflare.fileFromPath = fileFromPath;
    ({ CloudflareError: CloudflareError2, APIError: APIError2, APIConnectionError: APIConnectionError2, APIConnectionTimeoutError: APIConnectionTimeoutError2, APIUserAbortError: APIUserAbortError2, NotFoundError: NotFoundError2, ConflictError: ConflictError2, RateLimitError: RateLimitError2, BadRequestError: BadRequestError2, AuthenticationError: AuthenticationError2, InternalServerError: InternalServerError2, PermissionDeniedError: PermissionDeniedError2, UnprocessableEntityError: UnprocessableEntityError2 } = error_exports);
    (function(Cloudflare2) {
      Cloudflare2.V4PagePagination = V4PagePagination;
      Cloudflare2.V4PagePaginationArray = V4PagePaginationArray;
      Cloudflare2.CursorPagination = CursorPagination;
      Cloudflare2.CursorLimitPagination = CursorLimitPagination;
      Cloudflare2.SinglePage = SinglePage;
      Cloudflare2.Accounts = Accounts;
      Cloudflare2.OriginCACertificates = OriginCACertificates;
      Cloudflare2.IPs = IPs2;
      Cloudflare2.Memberships = Memberships;
      Cloudflare2.User = User;
      Cloudflare2.Zones = Zones2;
      Cloudflare2.LoadBalancers = LoadBalancers;
      Cloudflare2.Cache = Cache;
      Cloudflare2.SSL = SSL;
      Cloudflare2.Subscriptions = Subscriptions2;
      Cloudflare2.ACM = ACM;
      Cloudflare2.Argo = Argo;
      Cloudflare2.Plans = Plans;
      Cloudflare2.RatePlans = RatePlans;
      Cloudflare2.CertificateAuthorities = CertificateAuthorities;
      Cloudflare2.ClientCertificates = ClientCertificates;
      Cloudflare2.CustomCertificates = CustomCertificates;
      Cloudflare2.CustomHostnames = CustomHostnames;
      Cloudflare2.CustomNameservers = CustomNameservers;
      Cloudflare2.DNS = DNS;
      Cloudflare2.DNSSECResource = DNSSECResource;
      Cloudflare2.EmailRouting = EmailRouting;
      Cloudflare2.Filters = Filters;
      Cloudflare2.Firewall = Firewall;
      Cloudflare2.Healthchecks = Healthchecks;
      Cloudflare2.KeylessCertificates = KeylessCertificates;
      Cloudflare2.Logpush = Logpush;
      Cloudflare2.Logs = Logs2;
      Cloudflare2.OriginTLSClientAuth = OriginTLSClientAuth;
      Cloudflare2.Pagerules = Pagerules;
      Cloudflare2.RateLimits = RateLimits;
      Cloudflare2.SecondaryDNS = SecondaryDNS;
      Cloudflare2.WaitingRooms = WaitingRooms;
      Cloudflare2.Web3 = Web3;
      Cloudflare2.Workers = Workers;
      Cloudflare2.KV = KV;
      Cloudflare2.DurableObjects = DurableObjects;
      Cloudflare2.Queues = Queues2;
      Cloudflare2.APIGateway = APIGateway;
      Cloudflare2.ManagedHeaders = ManagedHeaders;
      Cloudflare2.PageShield = PageShield;
      Cloudflare2.Rulesets = Rulesets;
      Cloudflare2.URLNormalization = URLNormalization;
      Cloudflare2.Spectrum = Spectrum;
      Cloudflare2.Addressing = Addressing;
      Cloudflare2.AuditLogs = AuditLogs;
      Cloudflare2.Billing = Billing;
      Cloudflare2.BrandProtection = BrandProtection;
      Cloudflare2.Diagnostics = Diagnostics;
      Cloudflare2.Images = Images;
      Cloudflare2.Intel = Intel;
      Cloudflare2.MagicTransit = MagicTransit;
      Cloudflare2.MagicNetworkMonitoring = MagicNetworkMonitoring;
      Cloudflare2.MTLSCertificates = MTLSCertificates;
      Cloudflare2.Pages = Pages;
      Cloudflare2.PCAPs = PCAPs;
      Cloudflare2.Registrar = Registrar;
      Cloudflare2.RequestTracers = RequestTracers;
      Cloudflare2.Rules = Rules7;
      Cloudflare2.Storage = Storage;
      Cloudflare2.Stream = Stream;
      Cloudflare2.Alerting = Alerting;
      Cloudflare2.D1Resource = D1Resource;
      Cloudflare2.R2 = R22;
      Cloudflare2.WARPConnector = WARPConnector;
      Cloudflare2.WorkersForPlatforms = WorkersForPlatforms;
      Cloudflare2.ZeroTrust = ZeroTrust;
      Cloudflare2.Challenges = Challenges;
      Cloudflare2.HyperdriveResource = HyperdriveResource;
      Cloudflare2.RUM = RUM;
      Cloudflare2.Vectorize = Vectorize;
      Cloudflare2.URLScanner = URLScanner;
      Cloudflare2.Radar = Radar;
      Cloudflare2.BotManagement = BotManagement;
      Cloudflare2.OriginPostQuantumEncryption = OriginPostQuantumEncryption;
      Cloudflare2.Speed = Speed2;
      Cloudflare2.DCVDelegation = DCVDelegation;
      Cloudflare2.Hostnames = Hostnames;
      Cloudflare2.Snippets = Snippets;
      Cloudflare2.Calls = Calls;
      Cloudflare2.CloudforceOne = CloudforceOne;
      Cloudflare2.EventNotifications = EventNotifications;
      Cloudflare2.AIGateway = AIGateway;
      Cloudflare2.IAM = IAM;
      Cloudflare2.CloudConnector = CloudConnector;
    })(Cloudflare || (Cloudflare = {}));
    cloudflare_default = Cloudflare;
  }
});

// src/types.ts
function generateUUID() {
  return crypto.randomUUID();
}
function calculateExpiresAt(ttlDays) {
  if (!ttlDays) return void 0;
  const expiresAt = /* @__PURE__ */ new Date();
  expiresAt.setDate(expiresAt.getDate() + ttlDays);
  return expiresAt.toISOString();
}
function getCloudflareToken(env, preferUserToken = false) {
  if (preferUserToken && env.CLOUDFLARE_USER_TOKEN) {
    return env.CLOUDFLARE_USER_TOKEN;
  }
  if (env.CLOUDFLARE_ACCOUNT_TOKEN) {
    return env.CLOUDFLARE_ACCOUNT_TOKEN;
  }
  if (env.CLOUDFLARE_ACCOUNT_TOKEN) {
    return env.CLOUDFLARE_ACCOUNT_TOKEN;
  }
  throw new Error("No Cloudflare API token configured. Please set CLOUDFLARE_ACCOUNT_TOKEN or CLOUDFLARE_USER_TOKEN.");
}
var init_types = __esm({
  "src/types.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    __name(generateUUID, "generateUUID");
    __name(calculateExpiresAt, "calculateExpiresAt");
    __name(getCloudflareToken, "getCloudflareToken");
  }
});

// src/lib/db.ts
var db_exports = {};
__export(db_exports, {
  getAllApiMappings: () => getAllApiMappings,
  getApiMapping: () => getApiMapping
});
async function getApiMapping(env, product) {
  try {
    const query = `
      SELECT id, permission, base_path, verbs, description 
      FROM api_permissions_map 
      WHERE permission LIKE ? 
      LIMIT 1
    `;
    const result = await env.DB.prepare(query).bind(`${product}%`).first();
    return result || null;
  } catch (error) {
    console.error("Error fetching API mapping:", error);
    return null;
  }
}
async function getAllApiMappings(env, product) {
  try {
    let query = "SELECT id, permission, base_path, verbs, description FROM api_permissions_map";
    const params = [];
    if (product) {
      query += " WHERE permission LIKE ?";
      params.push(`${product}%`);
    }
    query += " ORDER BY permission";
    const result = await env.DB.prepare(query).bind(...params).all();
    return result.results || [];
  } catch (error) {
    console.error("Error fetching API mappings:", error);
    return [];
  }
}
var init_db = __esm({
  "src/lib/db.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    __name(getApiMapping, "getApiMapping");
    __name(getAllApiMappings, "getAllApiMappings");
  }
});

// src/lib/apiGateway.ts
function inferMethod(action, providedMethod) {
  if (providedMethod) {
    return providedMethod;
  }
  if (action) {
    if (defaultMethods[action]) {
      return defaultMethods[action];
    }
    const lowerAction = action.toLowerCase();
    if (lowerAction.startsWith("list")) return "GET";
    if (lowerAction.startsWith("create") || lowerAction.startsWith("deploy") || lowerAction.startsWith("run")) return "POST";
    if (lowerAction.startsWith("update")) return "PUT";
    if (lowerAction.startsWith("modify")) return "PATCH";
    if (lowerAction.startsWith("delete") || lowerAction.startsWith("remove")) return "DELETE";
  }
  return "GET";
}
async function callCloudflareAPI(env, request) {
  let { product, action, method, params = {}, body = {} } = request;
  product = product.toLowerCase();
  method = inferMethod(action, method);
  const mapping = await getApiMapping(env, product);
  if (!mapping) {
    throw new Error(`No API mapping found for product: ${product}`);
  }
  const { base_path } = mapping;
  let path = base_path;
  const queryParams = {};
  if (path.includes("{account_id}")) {
    path = path.replace("{account_id}", env.CLOUDFLARE_ACCOUNT_ID);
  }
  if (path.includes("{zone_id}")) {
    if (!params.zone_id) {
      throw new Error("zone_id parameter is required for this endpoint");
    }
    path = path.replace("{zone_id}", params.zone_id);
  }
  for (const [key, value] of Object.entries(params)) {
    const placeholder = `{${key}}`;
    if (path.includes(placeholder)) {
      path = path.replace(placeholder, encodeURIComponent(String(value)));
    } else {
      queryParams[key] = value;
    }
  }
  const baseUrl = "https://api.cloudflare.com/client/v4";
  const url = new URL(`${baseUrl}${path}`);
  if (method === "GET" && Object.keys(queryParams).length > 0) {
    for (const [key, value] of Object.entries(queryParams)) {
      if (value !== void 0 && value !== null) {
        url.searchParams.append(key, String(value));
      }
    }
  }
  const headers = {
    "Authorization": `Bearer ${env.CLOUDFLARE_ACCOUNT_TOKEN}`,
    "Content-Type": "application/json"
  };
  const fetchOptions = {
    method,
    headers
  };
  if (!["GET", "DELETE"].includes(method)) {
    if (Object.keys(body).length > 0) {
      fetchOptions.body = JSON.stringify(body);
    }
  }
  const response = await fetch(url.toString(), fetchOptions);
  let data;
  const contentType = response.headers.get("content-type") || "";
  if (contentType.includes("application/json")) {
    data = await response.json();
  } else {
    data = await response.text();
  }
  return {
    status: response.status,
    data,
    headers: Object.fromEntries(response.headers.entries())
  };
}
var defaultMethods;
var init_apiGateway = __esm({
  "src/lib/apiGateway.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_db();
    defaultMethods = {
      list: "GET",
      list_scripts: "GET",
      list_buckets: "GET",
      list_databases: "GET",
      list_namespaces: "GET",
      list_indexes: "GET",
      list_models: "GET",
      create: "POST",
      create_bucket: "POST",
      create_database: "POST",
      create_namespace: "POST",
      create_index: "POST",
      deploy: "POST",
      run: "POST",
      execute: "POST",
      update: "PUT",
      modify: "PATCH",
      delete: "DELETE",
      remove: "DELETE"
    };
    __name(inferMethod, "inferMethod");
    __name(callCloudflareAPI, "callCloudflareAPI");
  }
});

// src/services/coachTelemetry.ts
var coachTelemetry_exports = {};
__export(coachTelemetry_exports, {
  CoachTelemetryService: () => CoachTelemetryService,
  autoTuneThreshold: () => autoTuneThreshold
});
async function autoTuneThreshold(env) {
  const telemetry = new CoachTelemetryService(env);
  const stats = await telemetry.getRollingStats(7);
  const clarRate = stats.total > 0 ? stats.clarifications / stats.total : 0;
  const avgConf = stats.avg_confidence || 0.7;
  let newThreshold = avgConf - clarRate * 0.1;
  newThreshold = Math.min(Math.max(newThreshold, 0.55), 0.9);
  await env.KV.put("clarify_threshold", newThreshold.toFixed(2));
  console.log(`[Coach AutoTune] Set clarification threshold \u2192 ${newThreshold.toFixed(2)} (clarRate: ${(clarRate * 100).toFixed(1)}%, avgConf: ${(avgConf * 100).toFixed(1)}%)`);
  return { clarRate, avgConf, newThreshold };
}
var CoachTelemetryService;
var init_coachTelemetry = __esm({
  "src/services/coachTelemetry.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    CoachTelemetryService = class {
      constructor(env) {
        this.env = env;
      }
      static {
        __name(this, "CoachTelemetryService");
      }
      async log(record) {
        try {
          const confidenceInt = record.confidence !== null && record.confidence !== void 0 ? Math.round(record.confidence * 100) : null;
          await this.env.DB.prepare(
            `INSERT INTO coach_telemetry (
          timestamp, prompt, inferred_product, inferred_action, inferred_method,
          confidence, next_step, coach_message, result_status, execution_latency_ms, raw_response
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
          ).bind(
            (/* @__PURE__ */ new Date()).toISOString(),
            record.prompt ?? "",
            record.product ?? null,
            record.action ?? null,
            record.method ?? null,
            confidenceInt,
            record.next_step ?? null,
            record.coach_message ?? null,
            record.result_status ?? "unknown",
            record.execution_latency_ms ?? null,
            JSON.stringify(record.raw_response ?? {})
          ).run();
        } catch (err) {
          console.error("Telemetry insert failed:", err);
        }
      }
      async getRecent(limit = 50) {
        try {
          const result = await this.env.DB.prepare(
            `SELECT * FROM coach_telemetry ORDER BY id DESC LIMIT ?`
          ).bind(limit).all();
          return result.results || [];
        } catch (err) {
          console.error("Failed to fetch recent telemetry:", err);
          return [];
        }
      }
      async getRollingStats(days = 7) {
        try {
          const result = await this.env.DB.prepare(`
        SELECT
          COUNT(*) AS total,
          SUM(CASE WHEN result_status = 'clarified' THEN 1 ELSE 0 END) AS clarifications,
          SUM(CASE WHEN result_status = 'executed' THEN 1 ELSE 0 END) AS executed,
          AVG(confidence) AS avg_confidence
        FROM coach_telemetry
        WHERE timestamp > datetime('now', ?)
      `).bind(`-${days} days`).first();
          return {
            total: result?.total || 0,
            clarifications: result?.clarifications || 0,
            executed: result?.executed || 0,
            avg_confidence: result?.avg_confidence ? result.avg_confidence / 100 : 0
            // Convert back to 0-1
          };
        } catch (err) {
          console.error("Failed to get rolling stats:", err);
          return { total: 0, clarifications: 0, executed: 0, avg_confidence: 0 };
        }
      }
    };
    __name(autoTuneThreshold, "autoTuneThreshold");
  }
});

// src/routes/api/workers.ts
var workers, upsertSecret, createTail, workers_default;
var init_workers2 = __esm({
  "src/routes/api/workers.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    workers = new Hono2();
    upsertSecret = /* @__PURE__ */ __name(async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const scriptName = c.req.param("scriptName");
        const secretNameFromPath = c.req.param("secretName");
        const body = await c.req.json();
        const payload = { ...body };
        if (!payload.name && secretNameFromPath) {
          payload.name = secretNameFromPath;
        }
        if (!payload.name) {
          return c.json(
            { success: false, error: "Secret name is required" },
            400
          );
        }
        if (payload.text === void 0 && payload.value !== void 0) {
          payload.text = payload.value;
          delete payload.value;
        }
        if (!payload.type) {
          payload.type = "secret_text";
        }
        const response = await apiClient.put(
          `/accounts/${accountId}/workers/scripts/${scriptName}/secrets`,
          payload
        );
        return c.json(response);
      } catch (error) {
        return c.json(
          { success: false, error: error.message },
          error.status || 500
        );
      }
    }, "upsertSecret");
    createTail = /* @__PURE__ */ __name(async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const scriptName = c.req.param("scriptName");
        const body = await c.req.json();
        const response = await apiClient.post(
          `/accounts/${accountId}/workers/scripts/${scriptName}/tails`,
          body
        );
        return c.json(response);
      } catch (error) {
        return c.json(
          { success: false, error: error.message },
          error.status || 500
        );
      }
    }, "createTail");
    workers.get("/scripts", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const response = await apiClient.get(
          `/accounts/${accountId}/workers/scripts`
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    workers.get("/scripts/:scriptName", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const scriptName = c.req.param("scriptName");
        const response = await apiClient.get(
          `/accounts/${accountId}/workers/scripts/${scriptName}`
        );
        return c.json(response);
      } catch (error) {
        const status = error.status === 404 ? 404 : error.status || 500;
        return c.json({ success: false, error: error.message }, status);
      }
    });
    workers.delete("/scripts/:scriptName", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const scriptName = c.req.param("scriptName");
        await apiClient.delete(
          `/accounts/${accountId}/workers/scripts/${scriptName}`
        );
        return c.json({ success: true, result: { id: scriptName } });
      } catch (error) {
        const status = error.status === 404 ? 404 : error.status || 500;
        return c.json({ success: false, error: error.message }, status);
      }
    });
    workers.get("/deployments", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const response = await apiClient.get(
          `/accounts/${accountId}/workers/deployments`
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    workers.get("/settings", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const response = await apiClient.get(
          `/accounts/${accountId}/workers/account-settings`
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    workers.get("/scripts/:scriptName/secrets", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const scriptName = c.req.param("scriptName");
        const response = await apiClient.get(
          `/accounts/${accountId}/workers/scripts/${scriptName}/secrets`
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    workers.put("/scripts/:scriptName/secrets", upsertSecret);
    workers.put("/scripts/:scriptName/secrets/:secretName", upsertSecret);
    workers.get("/scripts/:scriptName/secrets/:secretName", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const scriptName = c.req.param("scriptName");
        const secretName = c.req.param("secretName");
        const response = await apiClient.get(
          `/accounts/${accountId}/workers/scripts/${scriptName}/secrets/${secretName}`
        );
        return c.json(response);
      } catch (error) {
        const status = error.status === 404 ? 404 : error.status || 500;
        return c.json({ success: false, error: error.message }, status);
      }
    });
    workers.delete("/scripts/:scriptName/secrets/:secretName", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const scriptName = c.req.param("scriptName");
        const secretName = c.req.param("secretName");
        await apiClient.delete(
          `/accounts/${accountId}/workers/scripts/${scriptName}/secrets/${secretName}`
        );
        return c.json({ success: true, result: { name: secretName } });
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    workers.get("/scripts/:scriptName/tails", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const scriptName = c.req.param("scriptName");
        const response = await apiClient.get(
          `/accounts/${accountId}/workers/scripts/${scriptName}/tails`
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    workers.post("/scripts/:scriptName/tails", createTail);
    workers.put("/scripts/:scriptName/tails", createTail);
    workers.delete("/scripts/:scriptName/tails/:tailId", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const scriptName = c.req.param("scriptName");
        const tailId = c.req.param("tailId");
        await apiClient.delete(
          `/accounts/${accountId}/workers/scripts/${scriptName}/tails/${tailId}`
        );
        return c.json({ success: true, result: { id: tailId } });
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    workers_default = workers;
  }
});

// src/routes/api/storage.ts
var storage, storage_default;
var init_storage2 = __esm({
  "src/routes/api/storage.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    storage = new Hono2();
    storage.get("/d1/databases", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const response = await apiClient.get(
          `/accounts/${accountId}/d1/database`
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    storage.post("/d1/databases", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const response = await apiClient.post(
          `/accounts/${accountId}/d1/database`,
          body
        );
        return c.json(response, 201);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    storage.get("/kv/namespaces", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const response = await apiClient.get(
          `/accounts/${accountId}/storage/kv/namespaces`
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    storage.post("/kv/namespaces", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const response = await apiClient.post(
          `/accounts/${accountId}/storage/kv/namespaces`,
          body
        );
        return c.json(response, 201);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    storage.delete("/kv/namespaces/:namespaceId", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const namespaceId = c.req.param("namespaceId");
        await apiClient.delete(
          `/accounts/${accountId}/storage/kv/namespaces/${namespaceId}`
        );
        return c.json({ success: true, result: { id: namespaceId } });
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    storage.get("/r2/buckets", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const response = await apiClient.get(`/accounts/${accountId}/r2/buckets`);
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    storage.post("/r2/buckets", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const response = await apiClient.post(
          `/accounts/${accountId}/r2/buckets`,
          body
        );
        return c.json(response, 201);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    storage.delete("/r2/buckets/:bucketName", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const bucketName = c.req.param("bucketName");
        await apiClient.delete(
          `/accounts/${accountId}/r2/buckets/${bucketName}`
        );
        return c.json({ success: true, result: { name: bucketName } });
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    storage_default = storage;
  }
});

// src/routes/api/apiClient.ts
var ApiClientError, CloudflareApiClient;
var init_apiClient = __esm({
  "src/routes/api/apiClient.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    ApiClientError = class extends Error {
      constructor(message, status, details) {
        super(message);
        this.status = status;
        this.details = details;
        this.name = "ApiClientError";
      }
      static {
        __name(this, "ApiClientError");
      }
    };
    CloudflareApiClient = class {
      static {
        __name(this, "CloudflareApiClient");
      }
      baseUrl;
      authConfig;
      loggingService;
      constructor(authConfig, baseUrl = "https://api.cloudflare.com/client/v4", loggingService) {
        if (!authConfig || !("apiToken" in authConfig) && !("apiKey" in authConfig && "email" in authConfig)) {
          throw new Error(
            "Invalid authentication config. Must provide either { apiToken } or { apiKey, email }."
          );
        }
        this.authConfig = authConfig;
        this.baseUrl = baseUrl;
        this.loggingService = loggingService;
      }
      getAuthHeaders() {
        const headers = new Headers();
        if ("apiToken" in this.authConfig) {
          headers.set("Authorization", `Bearer ${this.authConfig.apiToken}`);
        } else {
          headers.set("X-Auth-Key", this.authConfig.apiKey);
          headers.set("X-Auth-Email", this.authConfig.email);
        }
        return headers;
      }
      async handleResponse(response) {
        if (!response.ok) {
          let errorBody;
          let errorMessage = `API request failed with status ${response.status}`;
          try {
            errorBody = await response.json();
            if (errorBody.errors && Array.isArray(errorBody.errors) && errorBody.errors.length > 0) {
              const firstError = errorBody.errors[0];
              errorMessage = `${firstError.message} (Code: ${firstError.code})`;
            }
          } catch (e) {
            errorMessage = response.statusText;
          }
          throw new ApiClientError(errorMessage, response.status, errorBody);
        }
        if (response.status === 204 || response.headers.get("content-length") === "0") {
          return { success: true };
        }
        const contentType = response.headers.get("content-type");
        if (contentType && contentType.includes("application/json")) {
          return response.json();
        }
        return response.text();
      }
      async rawRequest(endpoint, options = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        const headers = this.getAuthHeaders();
        headers.set("Accept", "application/json");
        const hasContentType = options.headers instanceof Headers ? options.headers.has("content-type") : Array.isArray(options.headers) ? options.headers.some(([key]) => key.toLowerCase() === "content-type") : typeof options.headers === "object" && options.headers !== null ? Object.keys(options.headers).some((key) => key.toLowerCase() === "content-type") : false;
        if (options.body && !hasContentType) {
          headers.set("Content-Type", "application/json");
        }
        if (options.headers) {
          const userHeaders = new Headers(options.headers);
          userHeaders.forEach((value, key) => headers.set(key, value));
        }
        return fetch(url, { ...options, headers });
      }
      async get(endpoint, params, options = {}) {
        let url = endpoint;
        if (params) {
          const searchParams = new URLSearchParams();
          for (const [key, value] of Object.entries(params)) {
            searchParams.append(key, String(value));
          }
          const queryString = searchParams.toString();
          if (queryString) {
            url += `?${queryString}`;
          }
        }
        const startTime = Date.now();
        let actionId;
        try {
          if (this.loggingService) {
            actionId = await this.loggingService.logCloudflareApiCall("GET", `${this.baseUrl}${url}`, params);
          }
          const response = await this.rawRequest(url, { ...options, method: "GET" });
          const result = await this.handleResponse(response);
          if (this.loggingService && actionId) {
            await this.loggingService.logCloudflareApiResponse(actionId, result);
          }
          return result;
        } catch (error) {
          if (this.loggingService && actionId) {
            await this.loggingService.logCloudflareApiResponse(actionId, null, error.message);
          }
          throw error;
        }
      }
      async post(endpoint, body) {
        let actionId;
        try {
          if (this.loggingService) {
            actionId = await this.loggingService.logCloudflareApiCall("POST", `${this.baseUrl}${endpoint}`, body);
          }
          const response = await this.rawRequest(endpoint, {
            method: "POST",
            body: JSON.stringify(body)
          });
          const result = await this.handleResponse(response);
          if (this.loggingService && actionId) {
            await this.loggingService.logCloudflareApiResponse(actionId, result);
          }
          return result;
        } catch (error) {
          if (this.loggingService && actionId) {
            await this.loggingService.logCloudflareApiResponse(actionId, null, error.message);
          }
          throw error;
        }
      }
      async put(endpoint, body) {
        let actionId;
        try {
          if (this.loggingService) {
            actionId = await this.loggingService.logCloudflareApiCall("PUT", `${this.baseUrl}${endpoint}`, body);
          }
          const response = await this.rawRequest(endpoint, {
            method: "PUT",
            body: JSON.stringify(body)
          });
          const result = await this.handleResponse(response);
          if (this.loggingService && actionId) {
            await this.loggingService.logCloudflareApiResponse(actionId, result);
          }
          return result;
        } catch (error) {
          if (this.loggingService && actionId) {
            await this.loggingService.logCloudflareApiResponse(actionId, null, error.message);
          }
          throw error;
        }
      }
      async patch(endpoint, body) {
        let actionId;
        try {
          if (this.loggingService) {
            actionId = await this.loggingService.logCloudflareApiCall("PATCH", `${this.baseUrl}${endpoint}`, body);
          }
          const response = await this.rawRequest(endpoint, {
            method: "PATCH",
            body: JSON.stringify(body)
          });
          const result = await this.handleResponse(response);
          if (this.loggingService && actionId) {
            await this.loggingService.logCloudflareApiResponse(actionId, result);
          }
          return result;
        } catch (error) {
          if (this.loggingService && actionId) {
            await this.loggingService.logCloudflareApiResponse(actionId, null, error.message);
          }
          throw error;
        }
      }
      async delete(endpoint, body) {
        let actionId;
        try {
          if (this.loggingService) {
            actionId = await this.loggingService.logCloudflareApiCall("DELETE", `${this.baseUrl}${endpoint}`, body);
          }
          const options = { method: "DELETE" };
          if (body) {
            options.body = JSON.stringify(body);
          }
          const response = await this.rawRequest(endpoint, options);
          const result = await this.handleResponse(response);
          if (this.loggingService && actionId) {
            await this.loggingService.logCloudflareApiResponse(actionId, result);
          }
          return result;
        } catch (error) {
          if (this.loggingService && actionId) {
            await this.loggingService.logCloudflareApiResponse(actionId, null, error.message);
          }
          throw error;
        }
      }
    };
  }
});

// src/routes/api/tokens.ts
var tokens, tokens_default;
var init_tokens2 = __esm({
  "src/routes/api/tokens.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    init_apiClient();
    tokens = new Hono2();
    tokens.get("/", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const response = await apiClient.get("/user/tokens");
        return c.json(response);
      } catch (error) {
        return c.json(
          { success: false, error: error.message },
          error.status || 500
        );
      }
    });
    tokens.get("/verify", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const response = await apiClient.get("/user/tokens/verify");
        return c.json(response);
      } catch (error) {
        const status = error.status === 401 ? 401 : error.status || 500;
        return c.json({ success: false, error: error.message }, status);
      }
    });
    tokens.post("/test", async (c) => {
      try {
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const tokenToTest = body.token;
        const results = {
          tested_at: (/* @__PURE__ */ new Date()).toISOString(),
          user_token_test: null,
          account_token_test: null,
          token_provided: !!tokenToTest
        };
        let apiClient;
        if (tokenToTest) {
          apiClient = new CloudflareApiClient({ apiToken: tokenToTest });
        } else {
          apiClient = c.get("apiClient");
        }
        try {
          const userVerifyStart = Date.now();
          const userResponse = await apiClient.get("/user/tokens/verify");
          const userVerifyTime = Date.now() - userVerifyStart;
          results.user_token_test = {
            success: true,
            status: 200,
            response_time_ms: userVerifyTime,
            result: userResponse.result || userResponse,
            verified: true,
            message: "User token verified successfully"
          };
        } catch (error) {
          results.user_token_test = {
            success: false,
            status: error.status || 500,
            response_time_ms: 0,
            error: error.message,
            verified: false,
            message: `User token verification failed: ${error.message}`
          };
        }
        try {
          const accountVerifyStart = Date.now();
          const accountResponse = await apiClient.get(`/accounts/${accountId}/tokens/verify`);
          const accountVerifyTime = Date.now() - accountVerifyStart;
          results.account_token_test = {
            success: true,
            status: 200,
            response_time_ms: accountVerifyTime,
            result: accountResponse.result || accountResponse,
            verified: true,
            message: "Account token verified successfully"
          };
        } catch (error) {
          results.account_token_test = {
            success: false,
            status: error.status || 500,
            response_time_ms: 0,
            error: error.message,
            verified: false,
            message: `Account token verification failed: ${error.message}`
          };
        }
        if (results.user_token_test?.verified && results.user_token_test?.result?.id) {
          try {
            const tokenId = results.user_token_test.result.id;
            const tokenDetailsStart = Date.now();
            const tokenDetails = await apiClient.get(`/user/tokens/${tokenId}`);
            const tokenDetailsTime = Date.now() - tokenDetailsStart;
            results.token_details = {
              success: true,
              status: 200,
              response_time_ms: tokenDetailsTime,
              result: tokenDetails.result || tokenDetails
            };
          } catch (error) {
            results.token_details = {
              success: false,
              status: error.status || 500,
              error: error.message
            };
          }
        }
        const userVerified = results.user_token_test?.verified === true;
        const accountVerified = results.account_token_test?.verified === true;
        results.overall_success = userVerified && accountVerified;
        results.overall_status = results.overall_success ? "pass" : "partial";
        return c.json({
          success: true,
          result: results
        });
      } catch (error) {
        return c.json(
          {
            success: false,
            error: error.message,
            details: error
          },
          500
        );
      }
    });
    tokens.get("/:tokenId", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const tokenId = c.req.param("tokenId");
        const response = await apiClient.get(`/user/tokens/${tokenId}`);
        return c.json(response);
      } catch (error) {
        const status = error.status === 404 ? 404 : error.status || 500;
        return c.json({ success: false, error: error.message }, status);
      }
    });
    tokens.post("/", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const body = await c.req.json();
        const response = await apiClient.post("/user/tokens", body);
        return c.json(response, 201);
      } catch (error) {
        return c.json(
          { success: false, error: error.message },
          error.status || 500
        );
      }
    });
    tokens.delete("/:tokenId", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const tokenId = c.req.param("tokenId");
        await apiClient.delete(`/user/tokens/${tokenId}`);
        return c.json({ success: true, result: { id: tokenId } });
      } catch (error) {
        const status = error.status === 404 ? 404 : error.status || 500;
        return c.json({ success: false, error: error.message }, status);
      }
    });
    tokens_default = tokens;
  }
});

// src/routes/api/pages.ts
var pages, pages_default;
var init_pages3 = __esm({
  "src/routes/api/pages.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    pages = new Hono2();
    pages.get("/projects", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const response = await apiClient.get(
          `/accounts/${accountId}/pages/projects`
        );
        return c.json(response);
      } catch (error) {
        return c.json(
          { success: false, error: error.message },
          error.status || 500
        );
      }
    });
    pages.get("/projects/:projectName", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const projectName = c.req.param("projectName");
        const response = await apiClient.get(
          `/accounts/${accountId}/pages/projects/${projectName}`
        );
        return c.json(response);
      } catch (error) {
        const status = error.status === 404 ? 404 : error.status || 500;
        return c.json({ success: false, error: error.message }, status);
      }
    });
    pages.post("/projects", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const response = await apiClient.post(
          `/accounts/${accountId}/pages/projects`,
          body
        );
        return c.json(response, 201);
      } catch (error) {
        return c.json(
          { success: false, error: error.message },
          error.status || 500
        );
      }
    });
    pages.delete("/projects/:projectName", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const projectName = c.req.param("projectName");
        await apiClient.delete(
          `/accounts/${accountId}/pages/projects/${projectName}`
        );
        return c.json({ success: true, result: { id: projectName } });
      } catch (error) {
        const status = error.status === 404 ? 404 : error.status || 500;
        return c.json({ success: false, error: error.message }, status);
      }
    });
    pages.get("/projects/:projectName/deployments", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const projectName = c.req.param("projectName");
        const response = await apiClient.get(
          `/accounts/${accountId}/pages/projects/${projectName}/deployments`
        );
        return c.json(response);
      } catch (error) {
        return c.json(
          { success: false, error: error.message },
          error.status || 500
        );
      }
    });
    pages_default = pages;
  }
});

// src/routes/api/cicd.ts
var cicd, cicd_default;
var init_cicd = __esm({
  "src/routes/api/cicd.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    cicd = new Hono2();
    cicd.put("/repos/connections", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const response = await apiClient.put(
          `/accounts/${accountId}/builds/repos/connections`,
          body
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.delete("/repos/connections/:repoConnectionUuid", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const repoConnectionUuid = c.req.param("repoConnectionUuid");
        await apiClient.delete(
          `/accounts/${accountId}/builds/repos/connections/${repoConnectionUuid}`
        );
        return c.json({ success: true });
      } catch (error) {
        const status = error.status === 404 ? 404 : error.status || 500;
        return c.json({ success: false, error: error.message }, status);
      }
    });
    cicd.get("/repos/:providerType/:providerAccountId/:repoId/config_autofill", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const providerType = c.req.param("providerType");
        const providerAccountId = c.req.param("providerAccountId");
        const repoId = c.req.param("repoId");
        const response = await apiClient.get(
          `/accounts/${accountId}/builds/repos/${providerType}/${providerAccountId}/${repoId}/config_autofill`
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.get("/tokens", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const response = await apiClient.get(
          `/accounts/${accountId}/builds/tokens`
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.post("/tokens", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const response = await apiClient.post(
          `/accounts/${accountId}/builds/tokens`,
          body
        );
        return c.json(response, 201);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.delete("/tokens/:buildTokenUuid", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const buildTokenUuid = c.req.param("buildTokenUuid");
        await apiClient.delete(
          `/accounts/${accountId}/builds/tokens/${buildTokenUuid}`
        );
        return c.json({ success: true });
      } catch (error) {
        const status = error.status === 404 ? 404 : error.status || 500;
        return c.json({ success: false, error: error.message }, status);
      }
    });
    cicd.get("/workers/:externalScriptId/triggers", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const externalScriptId = c.req.param("externalScriptId");
        const response = await apiClient.get(
          `/accounts/${accountId}/builds/workers/${externalScriptId}/triggers`
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.post("/triggers", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const response = await apiClient.post(
          `/accounts/${accountId}/builds/triggers`,
          body
        );
        return c.json(response, 201);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.patch("/triggers/:triggerUuid", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const triggerUuid = c.req.param("triggerUuid");
        const body = await c.req.json();
        const response = await apiClient.patch(
          `/accounts/${accountId}/builds/triggers/${triggerUuid}`,
          body
        );
        return c.json(response);
      } catch (error) {
        const status = error.status === 404 ? 404 : error.status || 500;
        return c.json({ success: false, error: error.message }, status);
      }
    });
    cicd.delete("/triggers/:triggerUuid", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const triggerUuid = c.req.param("triggerUuid");
        await apiClient.delete(
          `/accounts/${accountId}/builds/triggers/${triggerUuid}`
        );
        return c.json({ success: true });
      } catch (error) {
        const status = error.status === 404 ? 404 : error.status || 500;
        return c.json({ success: false, error: error.message }, status);
      }
    });
    cicd.post("/triggers/:triggerUuid/builds", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const triggerUuid = c.req.param("triggerUuid");
        const body = await c.req.json();
        const response = await apiClient.post(
          `/accounts/${accountId}/builds/triggers/${triggerUuid}/builds`,
          body
        );
        return c.json(response, 201);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.post("/triggers/:triggerUuid/purge_build_cache", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const triggerUuid = c.req.param("triggerUuid");
        const response = await apiClient.post(
          `/accounts/${accountId}/builds/triggers/${triggerUuid}/purge_build_cache`,
          {}
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.get("/builds/latest", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const externalScriptIds = c.req.query("external_script_ids");
        const params = externalScriptIds ? { external_script_ids: externalScriptIds } : void 0;
        const response = await apiClient.get(
          `/accounts/${accountId}/builds/builds/latest`,
          params
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.get("/builds", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const versionIds = c.req.query("version_ids");
        const params = versionIds ? { version_ids: versionIds } : void 0;
        const response = await apiClient.get(
          `/accounts/${accountId}/builds/builds`,
          params
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.get("/account/limits", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const response = await apiClient.get(
          `/accounts/${accountId}/builds/account/limits`
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.get("/workers/:externalScriptId/builds", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const externalScriptId = c.req.param("externalScriptId");
        const response = await apiClient.get(
          `/accounts/${accountId}/builds/workers/${externalScriptId}/builds`
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.get("/builds/:buildUuid", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const buildUuid = c.req.param("buildUuid");
        const response = await apiClient.get(
          `/accounts/${accountId}/builds/builds/${buildUuid}`
        );
        return c.json(response);
      } catch (error) {
        const status = error.status === 404 ? 404 : error.status || 500;
        return c.json({ success: false, error: error.message }, status);
      }
    });
    cicd.put("/builds/:buildUuid/cancel", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const buildUuid = c.req.param("buildUuid");
        const response = await apiClient.put(
          `/accounts/${accountId}/builds/builds/${buildUuid}/cancel`,
          {}
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.get("/builds/:buildUuid/logs", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const buildUuid = c.req.param("buildUuid");
        const cursor = c.req.query("cursor");
        const params = cursor ? { cursor } : void 0;
        const response = await apiClient.get(
          `/accounts/${accountId}/builds/builds/${buildUuid}/logs`,
          params
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.get("/triggers/:triggerUuid/environment_variables", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const triggerUuid = c.req.param("triggerUuid");
        const response = await apiClient.get(
          `/accounts/${accountId}/builds/triggers/${triggerUuid}/environment_variables`
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.patch("/triggers/:triggerUuid/environment_variables", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const triggerUuid = c.req.param("triggerUuid");
        const body = await c.req.json();
        const response = await apiClient.patch(
          `/accounts/${accountId}/builds/triggers/${triggerUuid}/environment_variables`,
          body
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    cicd.delete("/triggers/:triggerUuid/environment_variables/:key", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const triggerUuid = c.req.param("triggerUuid");
        const key = c.req.param("key");
        await apiClient.delete(
          `/accounts/${accountId}/builds/triggers/${triggerUuid}/environment_variables/${key}`
        );
        return c.json({ success: true });
      } catch (error) {
        const status = error.status === 404 ? 404 : error.status || 500;
        return c.json({ success: false, error: error.message }, status);
      }
    });
    cicd_default = cicd;
  }
});

// src/routes/api/vectorize.ts
var vectorize, vectorize_default;
var init_vectorize2 = __esm({
  "src/routes/api/vectorize.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    vectorize = new Hono2();
    vectorize.get("/indexes", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const response = await apiClient.get(
          `/accounts/${accountId}/vectorize/indexes`
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    vectorize.get("/indexes/:indexName", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const indexName = c.req.param("indexName");
        const response = await apiClient.get(
          `/accounts/${accountId}/vectorize/indexes/${indexName}`
        );
        return c.json(response);
      } catch (error) {
        const status = error.status === 404 ? 404 : error.status || 500;
        return c.json({ success: false, error: error.message }, status);
      }
    });
    vectorize_default = vectorize;
  }
});

// src/routes/api/ai.ts
var ai, ai_default;
var init_ai2 = __esm({
  "src/routes/api/ai.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    ai = new Hono2();
    ai.get("/models", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const response = await apiClient.get(
          `/accounts/${accountId}/ai/models`
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    ai.post("/run", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const modelName = body.model || "@cf/meta/llama-2-7b-chat-int8";
        const prompt = body.prompt || body.text || ["Hello"];
        const payload = {
          ...body,
          text: Array.isArray(prompt) ? prompt : [prompt]
        };
        const response = await apiClient.post(
          `/accounts/${accountId}/ai/run/${modelName}`,
          payload
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    ai.post("/run/:modelName", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const modelName = c.req.param("modelName");
        const body = await c.req.json();
        const response = await apiClient.post(
          `/accounts/${accountId}/ai/run/${modelName}`,
          body
        );
        return c.json(response);
      } catch (error) {
        return c.json({ success: false, error: error.message }, error.status || 500);
      }
    });
    ai_default = ai;
  }
});

// src/routes/api/projects.ts
var projectsRouter, projects_default;
var init_projects2 = __esm({
  "src/routes/api/projects.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    projectsRouter = new Hono2();
    projectsRouter.post("/", async (c) => {
      return c.json({
        success: false,
        error: "Projects functionality has been removed",
        message: "The projects table was dropped in migration 0012"
      }, 410);
    });
    projectsRouter.get("/", async (c) => {
      return c.json({
        success: false,
        error: "Projects functionality has been removed",
        message: "The projects table was dropped in migration 0012"
      }, 410);
    });
    projectsRouter.get("/:projectId", async (c) => {
      return c.json({
        success: false,
        error: "Projects functionality has been removed",
        message: "The projects table was dropped in migration 0012"
      }, 410);
    });
    projectsRouter.put("/:projectId", async (c) => {
      return c.json({
        success: false,
        error: "Projects functionality has been removed",
        message: "The projects table was dropped in migration 0012"
      }, 410);
    });
    projectsRouter.delete("/:projectId", async (c) => {
      return c.json({
        success: false,
        error: "Projects functionality has been removed",
        message: "The projects table was dropped in migration 0012"
      }, 410);
    });
    projects_default = projectsRouter;
  }
});

// src/routes/api/chat.ts
var chatRouter, chat_default;
var init_chat = __esm({
  "src/routes/api/chat.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    chatRouter = new Hono2();
    chatRouter.post("/rooms", async (c) => {
      return c.json({
        success: false,
        error: "Chat functionality has been removed",
        message: "The chat system tables were dropped in migration 0012"
      }, 410);
    });
    chatRouter.get("/rooms", async (c) => {
      return c.json({
        success: false,
        error: "Chat functionality has been removed",
        message: "The chat system tables were dropped in migration 0012"
      }, 410);
    });
    chatRouter.post("/threads", async (c) => {
      return c.json({
        success: false,
        error: "Chat functionality has been removed",
        message: "The chat system tables were dropped in migration 0012"
      }, 410);
    });
    chatRouter.get("/threads/:roomId", async (c) => {
      return c.json({
        success: false,
        error: "Chat functionality has been removed",
        message: "The chat system tables were dropped in migration 0012"
      }, 410);
    });
    chatRouter.post("/messages", async (c) => {
      return c.json({
        success: false,
        error: "Chat functionality has been removed",
        message: "The chat system tables were dropped in migration 0012"
      }, 410);
    });
    chatRouter.get("/messages/:threadId", async (c) => {
      return c.json({
        success: false,
        error: "Chat functionality has been removed",
        message: "The chat system tables were dropped in migration 0012"
      }, 410);
    });
    chat_default = chatRouter;
  }
});

// src/routes/api/index.ts
function needsCoaching(body) {
  return !body?.product || !body?.method;
}
async function askCoach(env, prompt, context) {
  if (!env.CONTEXT_COACH) {
    return null;
  }
  try {
    const doId = env.CONTEXT_COACH.idFromName("context-coach");
    const stub = env.CONTEXT_COACH.get(doId);
    const resp = await stub.fetch(new Request("http://do/coach", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ prompt, context })
    }));
    if (!resp.ok) {
      console.error("Coach service error:", resp.status, await resp.text());
      return null;
    }
    return await resp.json();
  } catch (error) {
    console.error("Failed to call coach:", error);
    return null;
  }
}
function mergeSuggestion(body, suggestion, threshold) {
  if (!suggestion) {
    return body;
  }
  if (suggestion.confidence < threshold) {
    suggestion.next_step = "clarify";
  }
  const inferredMethod = suggestion.method ?? body.method ?? ((suggestion.action || "").match(/list|get|show/i) ? "GET" : (suggestion.action || "").match(/create|deploy|add|upload/i) ? "POST" : (suggestion.action || "").match(/delete|remove/i) ? "DELETE" : (suggestion.action || "").match(/update/i) ? "PUT" : (suggestion.action || "").match(/modify/i) ? "PATCH" : "GET");
  return {
    ...body,
    product: (suggestion.product ?? body.product)?.toLowerCase(),
    action: suggestion.action ?? body.action ?? null,
    method: inferredMethod
  };
}
var api, api_default;
var init_api = __esm({
  "src/routes/api/index.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    init_apiGateway();
    init_coachTelemetry();
    init_workers2();
    init_storage2();
    init_tokens2();
    init_pages3();
    init_cicd();
    init_vectorize2();
    init_ai2();
    init_projects2();
    init_chat();
    api = new Hono2();
    api.route("/workers", workers_default);
    api.route("/storage", storage_default);
    api.route("/tokens", tokens_default);
    api.route("/pages", pages_default);
    api.route("/cicd", cicd_default);
    api.route("/vectorize", vectorize_default);
    api.route("/ai", ai_default);
    api.route("/projects", projects_default);
    api.route("/chat", chat_default);
    api.route("/raw/workers", workers_default);
    api.route("/raw/storage", storage_default);
    api.route("/raw/tokens", tokens_default);
    api.route("/raw/pages", pages_default);
    api.route("/raw/cicd", cicd_default);
    api.route("/raw/vectorize", vectorize_default);
    api.route("/raw/ai", ai_default);
    api.route("/raw/projects", projects_default);
    api.route("/raw/chat", chat_default);
    api.get("/meta/help", async (c) => {
      try {
        const { getAllApiMappings: getAllApiMappings2 } = await Promise.resolve().then(() => (init_db(), db_exports));
        const mappings = await getAllApiMappings2(c.env);
        const products = {};
        for (const mapping of mappings) {
          const product = mapping.permission.split(":")[0] || mapping.permission;
          if (!products[product]) {
            products[product] = {
              permission: mapping.permission,
              base_path: mapping.base_path,
              verbs: mapping.verbs || "GET,POST,PUT,PATCH,DELETE",
              actions: []
            };
          }
          const action = mapping.permission.split(":")[1];
          if (action && !products[product].actions.includes(action)) {
            products[product].actions.push(action);
          }
        }
        return c.json({
          success: true,
          result: {
            products: Object.keys(products),
            mappings: products,
            usage: {
              description: "Use /api/call with product and optional action/method to make API calls",
              examples: [
                { product: "workers", action: "list_scripts" },
                { product: "r2", action: "list_buckets" },
                { product: "d1", action: "list_databases" }
              ]
            }
          }
        });
      } catch (error) {
        console.error("Meta API help error:", error);
        return c.json({
          success: false,
          error: error.message || "Failed to retrieve API mappings"
        }, 500);
      }
    });
    __name(needsCoaching, "needsCoaching");
    __name(askCoach, "askCoach");
    __name(mergeSuggestion, "mergeSuggestion");
    api.post("/call", async (c) => {
      const startTime = Date.now();
      const telemetry = new CoachTelemetryService(c.env);
      let coachSuggestion = null;
      try {
        const originalBody = await c.req.json();
        let body = originalBody;
        if (needsCoaching(originalBody)) {
          const thresholdStr = await c.env.KV.get("clarify_threshold");
          const threshold = thresholdStr ? parseFloat(thresholdStr) : 0.75;
          const prompt = typeof originalBody === "string" ? originalBody : JSON.stringify(originalBody);
          const context = { hint: "Map to Cloudflare product+action+method" };
          coachSuggestion = await askCoach(c.env, prompt, context);
          if (coachSuggestion) {
            if (coachSuggestion.confidence < threshold) {
              coachSuggestion.next_step = "clarify";
            }
            await telemetry.log({
              prompt,
              product: coachSuggestion.product,
              action: coachSuggestion.action,
              method: coachSuggestion.method,
              confidence: coachSuggestion.confidence,
              next_step: coachSuggestion.next_step,
              coach_message: coachSuggestion.coach_message,
              raw_response: coachSuggestion
            });
            if (coachSuggestion.next_step === "clarify") {
              await telemetry.log({
                prompt,
                product: coachSuggestion.product,
                action: coachSuggestion.action,
                method: coachSuggestion.method,
                confidence: coachSuggestion.confidence,
                next_step: coachSuggestion.next_step,
                coach_message: coachSuggestion.coach_message,
                result_status: "clarified",
                raw_response: coachSuggestion
              });
              return c.json({
                success: false,
                needs_clarification: true,
                message: coachSuggestion.coach_message
              }, 400);
            }
            body = mergeSuggestion(originalBody, coachSuggestion, threshold);
          }
        }
        if (!body.product) {
          return c.json({
            error: "product is required",
            hint: "Available products: workers, r2, d1, kv, vectorize, ai, pages, tokens. Use /api/meta/help to see all available options."
          }, 400);
        }
        if (body.method) {
          const validMethods = ["GET", "POST", "PUT", "PATCH", "DELETE"];
          if (!validMethods.includes(body.method)) {
            return c.json({
              error: `Invalid method. Must be one of: ${validMethods.join(", ")}`,
              hint: "If method is omitted, it will be inferred from action (list \u2192 GET, create \u2192 POST, etc.)"
            }, 400);
          }
        }
        const result = await callCloudflareAPI(c.env, body);
        const executionLatency = Date.now() - startTime;
        if (coachSuggestion) {
          await telemetry.log({
            prompt: typeof originalBody === "string" ? originalBody : JSON.stringify(originalBody),
            product: body.product,
            action: body.action,
            method: body.method,
            confidence: coachSuggestion.confidence,
            next_step: "execute",
            coach_message: coachSuggestion.coach_message,
            result_status: result.status >= 200 && result.status < 300 ? "executed" : "failed",
            execution_latency_ms: executionLatency,
            raw_response: coachSuggestion
          });
        }
        const statusCode = result.status >= 200 && result.status < 600 ? result.status : 200;
        return c.json(result.data, statusCode);
      } catch (error) {
        console.error("Meta API Gateway error:", error);
        if (coachSuggestion) {
          await telemetry.log({
            prompt: "unknown",
            product: coachSuggestion.product,
            action: coachSuggestion.action,
            method: coachSuggestion.method,
            confidence: coachSuggestion.confidence,
            next_step: coachSuggestion.next_step,
            coach_message: coachSuggestion.coach_message,
            result_status: "failed",
            raw_response: coachSuggestion
          });
        }
        return c.json({
          error: error.message || "Internal server error",
          details: error.stack
        }, 500);
      }
    });
    api.post("/coach", async (c) => {
      try {
        const payload = await c.req.json();
        if (!c.env.CONTEXT_COACH) {
          return c.json({ error: "Coach service not available" }, 503);
        }
        const doId = c.env.CONTEXT_COACH.idFromName("context-coach");
        const stub = c.env.CONTEXT_COACH.get(doId);
        const resp = await stub.fetch(new Request("http://do/coach", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        }));
        const data = await resp.json();
        return c.json(data, resp.status);
      } catch (error) {
        return c.json({ error: error.message }, 500);
      }
    });
    api.get("/telemetry/stats", async (c) => {
      try {
        const telemetry = new CoachTelemetryService(c.env);
        const days = parseInt(c.req.query("days") || "7");
        const stats = await telemetry.getRollingStats(days);
        const recent = await telemetry.getRecent(50);
        return c.json({
          success: true,
          result: {
            stats,
            recent: recent.slice(0, 10),
            // Return last 10 for preview
            total_recent: recent.length
          }
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    api.post("/telemetry/tune", async (c) => {
      try {
        const { autoTuneThreshold: autoTuneThreshold2 } = await Promise.resolve().then(() => (init_coachTelemetry(), coachTelemetry_exports));
        const result = await autoTuneThreshold2(c.env);
        return c.json({
          success: true,
          result
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    api_default = api;
  }
});

// src/routes/flows/token.ts
var tokenFlows, token_default;
var init_token3 = __esm({
  "src/routes/flows/token.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    init_types();
    tokenFlows = new Hono2();
    tokenFlows.post("/create", async (c) => {
      try {
        const cf = c.get("cf");
        const db = c.env.DB;
        const accountId = c.get("accountId");
        const secretStoreId = c.env.MANAGED_SECRETS_STORE;
        const body = await c.req.json();
        const countResult = await db.prepare("SELECT COUNT(*) as count FROM managed_tokens WHERE status = 'active'").first();
        const activeCount = countResult?.count || 0;
        if (activeCount >= 50) {
          const now = (/* @__PURE__ */ new Date()).toISOString();
          await db.prepare("UPDATE managed_tokens SET status = 'expired' WHERE expires_at < ? AND status = 'active'").bind(now).run();
          const newCountResult = await db.prepare("SELECT COUNT(*) as count FROM managed_tokens WHERE status = 'active'").first();
          if ((newCountResult?.count || 0) >= 50) {
            return c.json(
              {
                success: false,
                error: "Token limit (50) reached. Please revoke unused tokens or wait for TTL expiration.",
                active_count: newCountResult?.count
              },
              400
            );
          }
        }
        let tokenResponse;
        try {
          tokenResponse = await cf.user.tokens.create({
            name: body.name,
            policies: body.policies,
            not_before: body.not_before,
            expires_on: body.expires_on || calculateExpiresAt(body.ttl_days),
            condition: body.condition
          });
        } catch (error) {
          console.error("Failed to create token via Cloudflare API:", error);
          return c.json(
            {
              success: false,
              error: "Failed to create token",
              details: error.message
            },
            500
          );
        }
        const tokens2 = await cf.user.tokens.list();
        const token = tokens2.result.find((t) => t.value === tokenResponse.value);
        if (!token || typeof token !== "object" || !("id" in token)) {
          return c.json({ success: false, error: "Failed to find created token" }, 500);
        }
        const tokenId = token.id;
        const secretKey = `MANAGED_TOKEN_${tokenId}`;
        try {
          await cf.workers.scripts.secrets.update(
            secretStoreId,
            secretKey,
            { text: tokenResponse.value },
            { account_id: accountId }
          );
        } catch (error) {
          console.error("Failed to save token to Secret Store, rolling back:", error);
          try {
            await cf.user.tokens.delete(tokenId);
          } catch (rollbackError) {
            console.error("Rollback failed:", rollbackError);
          }
          return c.json(
            {
              success: false,
              error: "Failed to save token to Secret Store. Operation rolled back.",
              details: error.message
            },
            500
          );
        }
        const tokenRecord = {
          id: generateUUID(),
          token_name: body.name,
          token_id: tokenId,
          purpose: body.purpose,
          created_at: (/* @__PURE__ */ new Date()).toISOString(),
          created_by: c.req.header("x-user-id") || "system",
          expires_at: body.expires_on || calculateExpiresAt(body.ttl_days),
          ttl_days: body.ttl_days,
          permissions: JSON.stringify(body.permissions),
          related_resources: body.related_resources ? JSON.stringify(body.related_resources) : void 0,
          secret_key: secretKey,
          status: "active",
          use_count: 0,
          metadata: JSON.stringify({
            policies: body.policies,
            condition: body.condition
          })
        };
        try {
          await db.prepare(
            `INSERT INTO managed_tokens (
            id, token_name, token_id, purpose, created_at, created_by,
            expires_at, ttl_days, permissions, related_resources,
            secret_key, status, use_count, metadata
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
          ).bind(
            tokenRecord.id,
            tokenRecord.token_name,
            tokenRecord.token_id,
            tokenRecord.purpose,
            tokenRecord.created_at,
            tokenRecord.created_by,
            tokenRecord.expires_at,
            tokenRecord.ttl_days,
            tokenRecord.permissions,
            tokenRecord.related_resources,
            tokenRecord.secret_key,
            tokenRecord.status,
            tokenRecord.use_count,
            tokenRecord.metadata
          ).run();
        } catch (error) {
          console.error("Failed to save token metadata to D1, rolling back:", error);
          try {
            await cf.user.tokens.delete(tokenId);
            await cf.workers.scripts.secrets.delete(secretStoreId, secretKey, { account_id: accountId });
          } catch (rollbackError) {
            console.error("Rollback failed:", rollbackError);
          }
          return c.json(
            {
              success: false,
              error: "Failed to save token metadata to D1. Operation rolled back.",
              details: error.message
            },
            500
          );
        }
        return c.json(
          {
            success: true,
            result: {
              id: tokenRecord.id,
              token_id: tokenRecord.token_id,
              token_name: tokenRecord.token_name,
              purpose: tokenRecord.purpose,
              expires_at: tokenRecord.expires_at,
              secret_key: secretKey,
              // Internal reference only
              message: "Token created and stored securely. Value is in MANAGED_SECRETS."
            }
          },
          201
        );
      } catch (error) {
        console.error("Error in token creation flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    tokenFlows.get("/:tokenId/value", async (c) => {
      try {
        const cf = c.get("cf");
        const db = c.env.DB;
        const accountId = c.get("accountId");
        const secretStoreId = c.env.MANAGED_SECRETS_STORE;
        const tokenId = c.req.param("tokenId");
        const record = await db.prepare("SELECT * FROM managed_tokens WHERE id = ? OR token_id = ?").bind(tokenId, tokenId).first();
        if (!record) {
          return c.json({ success: false, error: "Token not found" }, 404);
        }
        if (record.status !== "active") {
          return c.json({ success: false, error: `Token is ${record.status}` }, 400);
        }
        const secretResponse = { value: "[REDACTED]", text: "[REDACTED]" };
        await db.prepare("UPDATE managed_tokens SET last_used_at = ?, use_count = use_count + 1 WHERE id = ?").bind((/* @__PURE__ */ new Date()).toISOString(), record.id).run();
        return c.json({
          success: true,
          result: {
            value: secretResponse.value || secretResponse.text,
            metadata: record
          }
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    tokenFlows.get("/", async (c) => {
      try {
        const db = c.env.DB;
        const status = c.req.query("status") || "active";
        const query = status === "all" ? "SELECT * FROM managed_tokens ORDER BY created_at DESC" : "SELECT * FROM managed_tokens WHERE status = ? ORDER BY created_at DESC";
        const result = await (status === "all" ? db.prepare(query).all() : db.prepare(query).bind(status).all());
        return c.json({
          success: true,
          result: result.results,
          count: result.results?.length || 0
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    tokenFlows.delete("/:tokenId", async (c) => {
      try {
        const cf = c.get("cf");
        const db = c.env.DB;
        const accountId = c.get("accountId");
        const secretStoreId = c.env.MANAGED_SECRETS_STORE;
        const tokenId = c.req.param("tokenId");
        const record = await db.prepare("SELECT * FROM managed_tokens WHERE id = ? OR token_id = ?").bind(tokenId, tokenId).first();
        if (!record) {
          return c.json({ success: false, error: "Token not found" }, 404);
        }
        await cf.user.tokens.delete(record.token_id);
        await cf.workers.scripts.secrets.delete(secretStoreId, record.secret_key, { account_id: accountId });
        await db.prepare("UPDATE managed_tokens SET status = 'revoked' WHERE id = ?").bind(record.id).run();
        return c.json({
          success: true,
          result: { id: record.id, token_id: record.token_id }
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    tokenFlows.post("/cleanup", async (c) => {
      try {
        const cf = c.get("cf");
        const db = c.env.DB;
        const accountId = c.get("accountId");
        const secretStoreId = c.env.MANAGED_SECRETS_STORE;
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const expiredTokens = await db.prepare("SELECT * FROM managed_tokens WHERE expires_at < ? AND status = 'active'").bind(now).all();
        let cleaned = 0;
        for (const token of expiredTokens.results || []) {
          try {
            await cf.user.tokens.delete(token.token_id);
            await cf.workers.scripts.secrets.delete(secretStoreId, token.secret_key, { account_id: accountId });
            await db.prepare("UPDATE managed_tokens SET status = 'expired' WHERE id = ?").bind(token.id).run();
            cleaned++;
          } catch (error) {
            console.error(`Failed to cleanup token ${token.id}:`, error);
          }
        }
        return c.json({
          success: true,
          result: {
            cleaned_count: cleaned,
            total_expired: expiredTokens.results?.length || 0
          }
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    tokenFlows.get("/:tokenId/audit", async (c) => {
      try {
        const db = c.env.DB;
        const tokenId = c.req.param("tokenId");
        const record = await db.prepare("SELECT * FROM managed_tokens WHERE id = ? OR token_id = ?").bind(tokenId, tokenId).first();
        if (!record) {
          return c.json({ success: false, error: "Token not found" }, 404);
        }
        return c.json({
          success: true,
          result: {
            ...record,
            secret_key: "[REDACTED]",
            // Never expose secret key
            permissions: JSON.parse(record.permissions),
            related_resources: record.related_resources ? JSON.parse(record.related_resources) : null,
            metadata: record.metadata ? JSON.parse(record.metadata) : null
          }
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    token_default = tokenFlows;
  }
});

// src/routes/flows/project.ts
var projectFlows, project_default;
var init_project = __esm({
  "src/routes/flows/project.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    projectFlows = new Hono2();
    projectFlows.post("/create", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const {
          projectName,
          bindings = [],
          // ['kv', 'd1', 'r2', 'analytics_engine', 'queue']
          githubRepo,
          githubOwner,
          productionBranch = "main",
          buildCommand = "",
          deployCommand = "npx wrangler deploy"
        } = body;
        const createdResources = [];
        const wranglerBindings = [];
        for (const bindingType of bindings) {
          try {
            switch (bindingType) {
              case "kv": {
                const namespace = await cf.kv.namespaces.create({
                  account_id: accountId,
                  title: `${projectName}-kv`
                });
                createdResources.push({ type: "kv", id: namespace.id, name: `${projectName}-kv` });
                wranglerBindings.push(`[[kv_namespaces]]
binding = "${projectName.toUpperCase()}_KV"
id = "${namespace.id}"`);
                break;
              }
              case "d1": {
                const database = await cf.d1.database.create({
                  account_id: accountId,
                  name: `${projectName}-db`
                });
                createdResources.push({ type: "d1", id: database.uuid, name: `${projectName}-db` });
                wranglerBindings.push(`[[d1_databases]]
binding = "${projectName.toUpperCase()}_DB"
database_name = "${projectName}-db"
database_id = "${database.uuid}"`);
                break;
              }
              case "r2": {
                const bucket = await cf.r2.buckets.create({
                  account_id: accountId,
                  name: `${projectName.toLowerCase()}-storage`
                });
                createdResources.push({ type: "r2", id: bucket.name, name: `${projectName}-storage` });
                wranglerBindings.push(`[[r2_buckets]]
binding = "${projectName.toUpperCase()}_STORAGE"
bucket_name = "${bucket.name}"`);
                break;
              }
              case "analytics_engine": {
                createdResources.push({ type: "analytics_engine", name: `${projectName}-analytics` });
                wranglerBindings.push(`[[analytics_engine_datasets]]
binding = "${projectName.toUpperCase()}_ANALYTICS"`);
                break;
              }
              case "queue": {
                createdResources.push({ type: "queue", name: `${projectName}-queue` });
                wranglerBindings.push(`[[queues.producers]]
binding = "${projectName.toUpperCase()}_QUEUE"
queue = "${projectName.toLowerCase()}-queue"`);
                break;
              }
            }
          } catch (error) {
            console.error(`Error creating ${bindingType} binding:`, error);
          }
        }
        let cicdInfo = null;
        if (githubRepo && githubOwner) {
        }
        const wranglerToml = `name = "${projectName.toLowerCase()}"
main = "src/index.ts"
compatibility_date = "2024-06-01"

${wranglerBindings.join("\n\n")}
`;
        return c.json(
          {
            success: true,
            result: {
              projectName,
              createdResources,
              cicd: cicdInfo,
              wranglerToml,
              message: `Project ${projectName} created with ${createdResources.length} bindings`
            }
          },
          201
        );
      } catch (error) {
        console.error("Error in project creation flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    projectFlows.post("/deploy-with-cicd", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const {
          workerName,
          githubOwner,
          githubRepo,
          productionBranch = "main",
          buildCommand = "",
          rootDir = "/"
        } = body;
        const repoConnection = { id: "mock-repo-connection-id" };
        const trigger = { id: "mock-trigger-id" };
        return c.json(
          {
            success: true,
            result: {
              workerName,
              repoConnectionUuid: repoConnection.uuid || repoConnection.id,
              triggerId: trigger.id,
              message: `CI/CD configured for ${workerName}. Pushes to ${productionBranch} will trigger deployments.`
            }
          },
          201
        );
      } catch (error) {
        console.error("Error in deploy-with-cicd flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    projectFlows.get("/:projectName/status", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const projectName = c.req.param("projectName");
        const status = {
          projectName,
          worker: null,
          page: null,
          deployments: [],
          bindings: {
            kv: [],
            d1: [],
            r2: []
          }
        };
        try {
          status.worker = await cf.workers.scripts.get(projectName, { account_id: accountId });
        } catch (error) {
        }
        try {
          status.page = await cf.pages.projects.get(projectName, { account_id: accountId });
        } catch (error) {
        }
        try {
          status.deployments = await cf.workers.scripts.deployments.list({
            account_id: accountId,
            script_name: projectName
          });
        } catch (error) {
        }
        try {
          const kvNamespaces = await cf.kv.namespaces.list({ account_id: accountId });
          status.bindings.kv = kvNamespaces.result.filter(
            (ns) => ns.title.toLowerCase().includes(projectName.toLowerCase())
          );
        } catch (error) {
        }
        try {
          const d1Databases = await cf.d1.database.list({ account_id: accountId });
          status.bindings.d1 = d1Databases.result.filter(
            (db) => db.name.toLowerCase().includes(projectName.toLowerCase())
          );
        } catch (error) {
        }
        try {
          const r2Buckets = await cf.r2.buckets.list({ account_id: accountId });
          status.bindings.r2 = (r2Buckets.buckets || []).filter(
            (bucket) => bucket.name.toLowerCase().includes(projectName.toLowerCase())
          );
        } catch (error) {
        }
        return c.json({
          success: true,
          result: status
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    projectFlows.post("/create-with-github", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const {
          projectName,
          bindings = [],
          githubOwner,
          githubRepo,
          githubDescription = "",
          githubPrivate = true,
          initializeWithReadme = true,
          coreGithubApiUrl,
          // URL to core-github-api service
          productionBranch = "main",
          buildCommand = "",
          deployCommand = "npx wrangler deploy"
        } = body;
        const result = {
          projectName,
          steps_completed: [],
          errors: [],
          created_resources: []
        };
        if (coreGithubApiUrl) {
          try {
            const githubApiResponse = await fetch(`${coreGithubApiUrl}/repos/create`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: c.req.header("Authorization") || ""
              },
              body: JSON.stringify({
                owner: githubOwner,
                name: githubRepo,
                description: githubDescription,
                private: githubPrivate,
                auto_init: initializeWithReadme
              })
            });
            if (!githubApiResponse.ok) {
              const errorData = await githubApiResponse.json();
              throw new Error(errorData.error || "Failed to create GitHub repository");
            }
            const githubResult = await githubApiResponse.json();
            result.github_repo = githubResult.result;
            result.steps_completed.push("github_repo_created");
          } catch (error) {
            result.errors.push({
              step: "github_repo_creation",
              error: error.message
            });
            return c.json(
              {
                success: false,
                error: "Failed to create GitHub repository",
                details: error.message,
                partial_result: result
              },
              500
            );
          }
        }
        const wranglerBindings = [];
        for (const bindingType of bindings) {
          try {
            switch (bindingType) {
              case "kv": {
                const namespace = await cf.kv.namespaces.create({
                  account_id: accountId,
                  title: `${projectName}-kv`
                });
                result.created_resources.push({ type: "kv", id: namespace.id, name: `${projectName}-kv` });
                wranglerBindings.push(`[[kv_namespaces]]
binding = "${projectName.toUpperCase()}_KV"
id = "${namespace.id}"`);
                break;
              }
              case "d1": {
                const database = await cf.d1.database.create({
                  account_id: accountId,
                  name: `${projectName}-db`
                });
                result.created_resources.push({ type: "d1", id: database.uuid, name: `${projectName}-db` });
                wranglerBindings.push(`[[d1_databases]]
binding = "${projectName.toUpperCase()}_DB"
database_name = "${projectName}-db"
database_id = "${database.uuid}"`);
                break;
              }
              case "r2": {
                const bucket = await cf.r2.buckets.create({
                  account_id: accountId,
                  name: `${projectName.toLowerCase()}-storage`
                });
                result.created_resources.push({ type: "r2", id: bucket.name, name: `${projectName}-storage` });
                wranglerBindings.push(`[[r2_buckets]]
binding = "${projectName.toUpperCase()}_STORAGE"
bucket_name = "${bucket.name}"`);
                break;
              }
              case "analytics_engine": {
                result.created_resources.push({ type: "analytics_engine", name: `${projectName}-analytics` });
                wranglerBindings.push(`[[analytics_engine_datasets]]
binding = "${projectName.toUpperCase()}_ANALYTICS"`);
                break;
              }
              case "queue": {
                result.created_resources.push({ type: "queue", name: `${projectName}-queue` });
                wranglerBindings.push(`[[queues.producers]]
binding = "${projectName.toUpperCase()}_QUEUE"
queue = "${projectName.toLowerCase()}-queue"`);
                break;
              }
            }
          } catch (error) {
            console.error(`Error creating ${bindingType} binding:`, error);
            result.errors.push({
              step: `create_${bindingType}_binding`,
              error: error.message
            });
          }
        }
        result.steps_completed.push("bindings_created");
        if (githubRepo && githubOwner) {
        }
        const wranglerToml = `name = "${projectName.toLowerCase()}"
main = "src/index.ts"
compatibility_date = "2024-06-01"

${wranglerBindings.join("\n\n")}
`;
        result.wranglerToml = wranglerToml;
        result.steps_completed.push("wrangler_toml_generated");
        return c.json(
          {
            success: result.errors.length === 0,
            result,
            message: result.errors.length === 0 ? `Project ${projectName} created with GitHub repo and ${result.created_resources.length} bindings` : "Project partially created with errors"
          },
          result.errors.length === 0 ? 201 : 207
        );
      } catch (error) {
        console.error("Error in create-with-github flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    project_default = projectFlows;
  }
});

// src/routes/flows/health.ts
var healthFlows, health_default;
var init_health2 = __esm({
  "src/routes/flows/health.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    healthFlows = new Hono2();
    healthFlows.post("/check-recent-workers", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const {
          days = 7,
          // Default to last 7 days
          include_observability = true,
          filter_pattern = ""
          // Optional: filter workers by name pattern
        } = body;
        const results = [];
        const cutoffDate = /* @__PURE__ */ new Date();
        cutoffDate.setDate(cutoffDate.getDate() - days);
        const workerPage = await cf.workers.scripts.list({ account_id: accountId });
        const workersList = Array.isArray(workerPage.result) ? workerPage.result : Array.isArray(workerPage.items) ? workerPage.items : [];
        for (const worker of workersList) {
          const scriptName = worker.id;
          if (!scriptName) continue;
          if (filter_pattern && !scriptName.includes(filter_pattern)) {
            continue;
          }
          const healthStatus = {
            script_name: scriptName,
            deployment_status: "unknown",
            build_errors: [],
            runtime_errors: [],
            recent_deployments: []
          };
          try {
            const deploymentPage = await cf.workers.scripts.deployments.list({
              account_id: accountId,
              script_name: scriptName
            });
            const deployments = Array.isArray(deploymentPage.result) ? deploymentPage.result : Array.isArray(deploymentPage.items) ? deploymentPage.items : Array.isArray(deploymentPage.deployments) ? deploymentPage.deployments : [];
            healthStatus.recent_deployments = deployments.slice(0, 5);
            if (deployments.length > 0) {
              const latestDeployment = deployments[0];
              healthStatus.last_deployed_at = latestDeployment.created_on;
              const deploymentDate = new Date(latestDeployment.created_on);
              if (deploymentDate < cutoffDate) {
                continue;
              }
            }
            if (include_observability && healthStatus.build_errors.length === 0) {
              try {
                if (c.env.OBSERVABILITY_AE) {
                  const ae = c.env.OBSERVABILITY_AE;
                  const endTime = /* @__PURE__ */ new Date();
                  const startTime = new Date(endTime.getTime() - days * 24 * 60 * 60 * 1e3);
                  const errorMetrics = {
                    total_requests: 0,
                    error_rate: 0,
                    exceptions: []
                  };
                  healthStatus.observability_summary = errorMetrics;
                  if (errorMetrics.error_rate > 0.05) {
                    healthStatus.deployment_status = "runtime_errors";
                  }
                }
              } catch (obsError) {
                console.error(`Failed to check observability for ${scriptName}:`, obsError);
              }
            }
            if (healthStatus.deployment_status === "unknown" && healthStatus.build_errors.length === 0 && healthStatus.runtime_errors.length === 0) {
              healthStatus.deployment_status = "healthy";
            }
            results.push(healthStatus);
          } catch (workerError) {
            console.error(`Error checking health for ${scriptName}:`, workerError);
            healthStatus.deployment_status = "unknown";
            healthStatus.runtime_errors.push({
              message: "Failed to retrieve worker health data",
              error: workerError.message
            });
            results.push(healthStatus);
          }
        }
        const summary = {
          total_checked: results.length,
          healthy: results.filter((r) => r.deployment_status === "healthy").length,
          build_errors: results.filter((r) => r.deployment_status === "build_errors").length,
          runtime_errors: results.filter((r) => r.deployment_status === "runtime_errors").length,
          unknown: results.filter((r) => r.deployment_status === "unknown").length
        };
        return c.json({
          success: true,
          result: {
            summary,
            workers: results,
            checked_period: {
              days,
              from: cutoffDate.toISOString(),
              to: (/* @__PURE__ */ new Date()).toISOString()
            }
          }
        });
      } catch (error) {
        console.error("Error in health check flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    healthFlows.get("/worker/:scriptName", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const scriptName = c.req.param("scriptName");
        const healthStatus = {
          script_name: scriptName,
          deployment_status: "unknown",
          build_errors: [],
          runtime_errors: [],
          recent_deployments: []
        };
        try {
          await cf.workers.scripts.get(scriptName, { account_id: accountId });
        } catch (error) {
          return c.json({ success: false, error: "Worker not found" }, 404);
        }
        try {
          const deployments = await cf.workers.scripts.deployments.list({
            account_id: accountId,
            script_name: scriptName
          });
          healthStatus.recent_deployments = deployments.slice(0, 10);
          if (deployments.length > 0) {
            healthStatus.last_deployed_at = deployments[0].created_on;
          }
        } catch (error) {
          console.error("Failed to get deployments:", error);
        }
        if (healthStatus.deployment_status === "unknown" && healthStatus.build_errors.length === 0) {
          healthStatus.deployment_status = "healthy";
        }
        return c.json({
          success: true,
          result: healthStatus
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    healthFlows.get("/ecosystem/:prefix", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const prefix = c.req.param("prefix");
        const workerPage = await cf.workers.scripts.list({ account_id: accountId });
        const workersList = Array.isArray(workerPage.result) ? workerPage.result : Array.isArray(workerPage.items) ? workerPage.items : [];
        const matchingWorkers = workersList.filter(
          (w) => w.id && w.id.toLowerCase().startsWith(prefix.toLowerCase())
        );
        const results = [];
        for (const worker of matchingWorkers) {
          const scriptName = worker.id;
          if (!scriptName) continue;
          const healthStatus = {
            script_name: scriptName,
            deployment_status: "unknown",
            build_errors: [],
            runtime_errors: [],
            recent_deployments: []
          };
          try {
            const deploymentPage = await cf.workers.scripts.deployments.list({
              account_id: accountId,
              script_name: scriptName
            });
            const deployments = Array.isArray(deploymentPage.result) ? deploymentPage.result : Array.isArray(deploymentPage.items) ? deploymentPage.items : Array.isArray(deploymentPage.deployments) ? deploymentPage.deployments : [];
            healthStatus.recent_deployments = deployments.slice(0, 3);
            if (deployments.length > 0) {
              healthStatus.last_deployed_at = deployments[0].created_on;
            }
            if (healthStatus.deployment_status === "unknown" && healthStatus.build_errors.length === 0) {
              healthStatus.deployment_status = "healthy";
            }
          } catch (error) {
            console.error(`Error checking ${scriptName}:`, error);
            healthStatus.deployment_status = "unknown";
          }
          results.push(healthStatus);
        }
        const summary = {
          ecosystem: prefix,
          total_workers: results.length,
          healthy: results.filter((r) => r.deployment_status === "healthy").length,
          build_errors: results.filter((r) => r.deployment_status === "build_errors").length,
          runtime_errors: results.filter((r) => r.deployment_status === "runtime_errors").length,
          unknown: results.filter((r) => r.deployment_status === "unknown").length
        };
        return c.json({
          success: true,
          result: {
            summary,
            workers: results
          }
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    health_default = healthFlows;
  }
});

// src/routes/flows/cicd.ts
var cicdFlows, cicd_default2;
var init_cicd2 = __esm({
  "src/routes/flows/cicd.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    cicdFlows = new Hono2();
    cicdFlows.post("/setup", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const {
          worker_name,
          github_owner,
          github_repo,
          production_branch = "main",
          staging_branch = "develop",
          build_command = "npm run build",
          deploy_command = "npm run deploy",
          // Default to npm run deploy from package.json
          root_dir = "/",
          env_vars = {},
          auto_deploy = true,
          build_rules
          // Optional build rules configuration
        } = body;
        const result = {
          worker_name,
          steps_completed: [],
          errors: []
        };
        try {
          await cf.workers.scripts.get(worker_name, { account_id: accountId });
          result.steps_completed.push("worker_verified");
        } catch (error) {
          return c.json(
            {
              success: false,
              error: `Worker '${worker_name}' not found. Please create the worker first.`
            },
            404
          );
        }
        let repoConnection;
        try {
          const apiClient = c.get("apiClient");
          const repoConnectionResponse = await apiClient.put(
            `/accounts/${accountId}/builds/repos/connections`,
            {
              provider_type: "github",
              provider_account_id: "cloudflare",
              // Cloudflare account identifier (per API spec)
              provider_account_name: "Cloudflare",
              // Cloudflare account name (per API spec)
              repo_id: github_repo,
              // GitHub repository name (e.g., "workers-sdk")
              repo_name: github_repo
              // GitHub repository name (e.g., "workers-sdk")
            }
          );
          repoConnection = repoConnectionResponse.result;
          result.repo_connection = {
            id: repoConnection.uuid || repoConnection.id,
            repo: `${github_owner}/${github_repo}`
          };
          result.steps_completed.push("repo_connection_created");
        } catch (error) {
          result.errors.push({
            step: "repo_connection",
            error: error.message
          });
          return c.json(
            {
              success: false,
              error: "Failed to create repository connection",
              details: error.message,
              partial_result: result
            },
            500
          );
        }
        let productionTrigger;
        try {
          const apiClient = c.get("apiClient");
          let buildTokenUuid = body.build_token_uuid;
          if (!buildTokenUuid) {
            try {
              const tokensResponse = await apiClient.get(
                `/accounts/${accountId}/builds/tokens`
              );
              if (tokensResponse.result && tokensResponse.result.length > 0) {
                buildTokenUuid = tokensResponse.result[0].build_token_uuid;
              } else {
                const newTokenResponse = await apiClient.post(
                  `/accounts/${accountId}/builds/tokens`,
                  {
                    build_token_name: `${worker_name}-build-token`,
                    build_token_secret: body.build_token_secret || void 0
                  }
                );
                buildTokenUuid = newTokenResponse.result.build_token_uuid;
              }
            } catch (tokenError) {
              console.warn("Could not get/create build token:", tokenError.message);
            }
          }
          const triggerPayload = {
            repo_connection_uuid: repoConnection.uuid || repoConnection.id,
            external_script_id: worker_name,
            trigger_name: `${worker_name}-production`,
            branch_includes: [production_branch],
            branch_excludes: [],
            build_command: build_command || "npm run build",
            deploy_command: deploy_command || "npm run deploy",
            // Default to npm run deploy from package.json
            root_directory: root_dir || "/",
            path_includes: ["*"],
            path_excludes: [],
            build_caching_enabled: build_rules?.build_caching_enabled ?? false
            // Optional build rule
          };
          if (buildTokenUuid) {
            triggerPayload.build_token_uuid = buildTokenUuid;
          }
          const triggerResponse = await apiClient.post(
            `/accounts/${accountId}/builds/triggers`,
            triggerPayload
          );
          productionTrigger = triggerResponse.result;
          if (Object.keys(env_vars).length > 0) {
            try {
              const envVarsPayload = {};
              for (const [key, value] of Object.entries({
                ...env_vars,
                ENVIRONMENT: "production"
              })) {
                envVarsPayload[key] = {
                  value: String(value),
                  is_secret: false
                  // Could be enhanced to detect secrets
                };
              }
              await apiClient.patch(
                `/accounts/${accountId}/builds/triggers/${productionTrigger.trigger_uuid}/environment_variables`,
                envVarsPayload
              );
            } catch (envError) {
              console.warn("Could not set environment variables:", envError.message);
            }
          }
          result.production_trigger = {
            id: productionTrigger.trigger_uuid,
            branch: production_branch
          };
          result.steps_completed.push("production_trigger_created");
        } catch (error) {
          result.errors.push({
            step: "production_trigger",
            error: error.message
          });
        }
        if (staging_branch && staging_branch !== production_branch) {
          try {
            const apiClient = c.get("apiClient");
            let buildTokenUuid = body.build_token_uuid;
            if (!buildTokenUuid && productionTrigger) {
              buildTokenUuid = productionTrigger.build_token_uuid;
            }
            if (!buildTokenUuid) {
              try {
                const tokensResponse = await apiClient.get(
                  `/accounts/${accountId}/builds/tokens`
                );
                if (tokensResponse.result && tokensResponse.result.length > 0) {
                  buildTokenUuid = tokensResponse.result[0].build_token_uuid;
                }
              } catch (tokenError) {
                console.warn("Could not get build token for staging:", tokenError.message);
              }
            }
            const stagingTriggerPayload = {
              repo_connection_uuid: repoConnection.uuid || repoConnection.id,
              external_script_id: `${worker_name}-staging`,
              trigger_name: `${worker_name}-staging`,
              branch_includes: [staging_branch],
              branch_excludes: [],
              build_command: build_command || "npm run build",
              deploy_command: `${deploy_command || "npm run deploy"} --env staging`,
              root_directory: root_dir || "/",
              path_includes: ["*"],
              path_excludes: [],
              build_caching_enabled: build_rules?.build_caching_enabled ?? false
            };
            if (buildTokenUuid) {
              stagingTriggerPayload.build_token_uuid = buildTokenUuid;
            }
            const stagingTriggerResponse = await apiClient.post(
              `/accounts/${accountId}/builds/triggers`,
              stagingTriggerPayload
            );
            const stagingTrigger = stagingTriggerResponse.result;
            if (Object.keys(env_vars).length > 0) {
              try {
                const envVarsPayload = {};
                for (const [key, value] of Object.entries({
                  ...env_vars,
                  ENVIRONMENT: "staging"
                })) {
                  envVarsPayload[key] = {
                    value: String(value),
                    is_secret: false
                  };
                }
                await apiClient.patch(
                  `/accounts/${accountId}/builds/triggers/${stagingTrigger.trigger_uuid}/environment_variables`,
                  envVarsPayload
                );
              } catch (envError) {
                console.warn("Could not set staging environment variables:", envError.message);
              }
            }
            result.staging_trigger = {
              id: stagingTrigger.trigger_uuid,
              branch: staging_branch
            };
            result.steps_completed.push("staging_trigger_created");
          } catch (error) {
            result.errors.push({
              step: "staging_trigger",
              error: error.message
            });
          }
        }
        if (auto_deploy && productionTrigger) {
          try {
            const apiClient = c.get("apiClient");
            const deploymentResponse = await apiClient.post(
              `/accounts/${accountId}/builds/triggers/${productionTrigger.trigger_uuid}/builds`,
              {
                branch: production_branch
              }
            );
            result.initial_deployment = {
              run_id: deploymentResponse.result?.id || deploymentResponse.result?.build_uuid,
              status: deploymentResponse.result?.status || "triggered"
            };
            result.steps_completed.push("initial_deployment_triggered");
          } catch (error) {
            result.errors.push({
              step: "initial_deployment",
              error: error.message
            });
          }
        }
        return c.json(
          {
            success: result.errors.length === 0,
            result,
            message: result.errors.length === 0 ? `CI/CD configured successfully for ${worker_name}` : "CI/CD partially configured with errors"
          },
          result.errors.length === 0 ? 201 : 207
        );
      } catch (error) {
        console.error("Error in CI/CD setup flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    cicdFlows.post("/create-with-repo", async (c) => {
      const result = {
        steps_completed: [],
        errors: []
      };
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const {
          worker_name,
          github_owner,
          repo_name,
          repo_description = "",
          repo_private = true,
          initialize_with_readme = true,
          core_github_api_url,
          // URL to core-github-api service
          production_branch = "main",
          build_command = "npm run build",
          deploy_command = "npm run deploy"
          // Default to npm run deploy from package.json
        } = body;
        result.worker_name = worker_name;
        if (core_github_api_url) {
          try {
            const githubApiResponse = await fetch(`${core_github_api_url}/repos/create`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: c.req.header("Authorization") || ""
              },
              body: JSON.stringify({
                owner: github_owner,
                name: repo_name,
                description: repo_description,
                private: repo_private,
                auto_init: initialize_with_readme
              })
            });
            if (!githubApiResponse.ok) {
              const errorData = await githubApiResponse.json();
              throw new Error(errorData.error || "Failed to create GitHub repository");
            }
            const githubResult = await githubApiResponse.json();
            result.github_repo = githubResult.result;
            result.steps_completed.push("github_repo_created");
          } catch (error) {
            result.errors.push({
              step: "github_repo_creation",
              error: error.message
            });
            return c.json(
              {
                success: false,
                error: "Failed to create GitHub repository",
                details: error.message,
                partial_result: result
              },
              500
            );
          }
        } else {
          return c.json(
            {
              success: false,
              error: "core_github_api_url is required for repo creation"
            },
            400
          );
        }
        try {
          const cicdSetup = await fetch(`${c.req.url.replace("/create-with-repo", "/setup")}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: c.req.header("Authorization") || ""
            },
            body: JSON.stringify({
              worker_name,
              github_owner,
              github_repo: repo_name,
              production_branch,
              build_command,
              deploy_command,
              auto_deploy: false
              // Don't auto-deploy yet
            })
          });
          const cicdResult = await cicdSetup.json();
          if (cicdResult.success) {
            result.cicd_setup = cicdResult.result;
            result.steps_completed.push("cicd_configured");
          } else {
            result.errors.push({
              step: "cicd_setup",
              error: cicdResult.error
            });
          }
        } catch (error) {
          result.errors.push({
            step: "cicd_setup",
            error: error.message
          });
        }
        return c.json(
          {
            success: result.errors.length === 0,
            result,
            message: result.errors.length === 0 ? `GitHub repo created and CI/CD configured for ${worker_name}` : "Partially completed with errors"
          },
          result.errors.length === 0 ? 201 : 207
        );
      } catch (error) {
        console.error("Error in create-with-repo flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    cicdFlows.put("/update/:workerId", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const workerId = c.req.param("workerId");
        const body = await c.req.json();
        const {
          trigger_id,
          build_command,
          deploy_command,
          branch_includes,
          branch_excludes,
          env_vars,
          root_dir
        } = body;
        if (!trigger_id) {
          return c.json({ success: false, error: "trigger_id is required" }, 400);
        }
        const updateData = {};
        if (build_command) updateData.build_command = build_command;
        if (deploy_command) updateData.deploy_command = deploy_command;
        if (branch_includes) updateData.branch_includes = branch_includes;
        if (branch_excludes) updateData.branch_excludes = branch_excludes;
        if (env_vars) updateData.env_vars = env_vars;
        if (root_dir) updateData.root_dir = root_dir;
        const trigger = { id: trigger_id, ...updateData };
        return c.json({
          success: true,
          result: trigger,
          message: "CI/CD configuration updated"
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    cicdFlows.delete("/remove/:workerId", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const workerId = c.req.param("workerId");
        const result = {
          deleted: [],
          errors: []
        };
        const triggers = [];
        const workerTriggers = triggers.filter(
          (t) => t.external_script_id === workerId || t.external_script_id === `${workerId}-staging`
        );
        for (const trigger of workerTriggers) {
          try {
            result.deleted.push({ type: "trigger", id: trigger.id });
          } catch (error) {
            result.errors.push({
              type: "trigger",
              id: trigger.id,
              error: error.message
            });
          }
        }
        const repoConnectionIds = [
          ...new Set(workerTriggers.map((t) => t.repo_connection_uuid).filter(Boolean))
        ];
        for (const connectionId of repoConnectionIds) {
          try {
            result.deleted.push({ type: "repo_connection", id: connectionId });
          } catch (error) {
            result.errors.push({
              type: "repo_connection",
              id: connectionId,
              error: error.message
            });
          }
        }
        return c.json({
          success: result.errors.length === 0,
          result,
          message: result.errors.length === 0 ? "CI/CD setup removed successfully" : "CI/CD partially removed with errors"
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    cicdFlows.get("/status/:workerId", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const workerId = c.req.param("workerId");
        const status = {
          worker_id: workerId,
          triggers: [],
          recent_builds: [],
          has_cicd: false
        };
        const triggers = [];
        const workerTriggers = triggers.filter(
          (t) => t.external_script_id === workerId || t.external_script_id === `${workerId}-staging`
        );
        status.has_cicd = workerTriggers.length > 0;
        status.triggers = workerTriggers;
        for (const trigger of workerTriggers) {
          try {
            const runs = [];
            status.recent_builds.push({
              trigger_id: trigger.id,
              trigger_name: trigger.trigger_name,
              runs: runs.slice(0, 5)
              // Last 5 builds
            });
          } catch (error) {
            console.error(`Failed to get builds for trigger ${trigger.id}`, error);
          }
        }
        return c.json({
          success: true,
          result: status
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    cicd_default2 = cicdFlows;
  }
});

// src/utils/deploy.ts
async function calculateFileHash(content) {
  const hashBuffer = await crypto.subtle.digest("SHA-256", content);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex.substring(0, 32);
}
function buildWorkerBindings(bindings, hasAssets = false, assetBinding = "ASSETS") {
  const workerBindings = [];
  if (hasAssets) {
    workerBindings.push({
      name: assetBinding,
      type: "assets"
    });
  }
  if (bindings.durable_objects) {
    for (const binding of bindings.durable_objects) {
      workerBindings.push({
        name: binding.name,
        type: "durable_object_namespace",
        class_name: binding.class_name
      });
    }
  }
  if (bindings.kv) {
    for (const kv of bindings.kv) {
      workerBindings.push({
        name: kv.binding,
        type: "kv_namespace",
        namespace_id: kv.id
      });
    }
  }
  if (bindings.d1) {
    for (const d1 of bindings.d1) {
      workerBindings.push({
        name: d1.binding,
        type: "d1",
        database_id: d1.database_id
      });
    }
  }
  if (bindings.r2) {
    for (const r2 of bindings.r2) {
      workerBindings.push({
        name: r2.binding,
        type: "r2_bucket",
        bucket_name: r2.bucket_name
      });
    }
  }
  if (bindings.vectorize) {
    for (const vec of bindings.vectorize) {
      workerBindings.push({
        name: vec.binding,
        type: "vectorize",
        index_name: vec.index_name
      });
    }
  }
  if (bindings.analytics_engine) {
    for (const ae of bindings.analytics_engine) {
      workerBindings.push({
        name: ae.binding,
        type: "analytics_engine"
      });
    }
  }
  if (bindings.queues) {
    for (const queue of bindings.queues) {
      workerBindings.push({
        name: queue.binding,
        type: "queue",
        queue_name: queue.queue_name
      });
    }
  }
  if (bindings.services) {
    for (const service of bindings.services) {
      workerBindings.push({
        name: service.binding,
        type: "service",
        service: service.service
      });
    }
  }
  return workerBindings;
}
function mergeMigrations(migrations) {
  if (!migrations || migrations.length === 0) {
    return null;
  }
  const mergedMigration = {
    tag: migrations[migrations.length - 1].tag,
    new_classes: [],
    new_sqlite_classes: []
  };
  for (const migration of migrations) {
    if (migration.new_classes) {
      mergedMigration.new_classes.push(...migration.new_classes);
    }
    if (migration.new_sqlite_classes) {
      mergedMigration.new_sqlite_classes.push(...migration.new_sqlite_classes);
    }
  }
  if (mergedMigration.new_classes.length === 0) delete mergedMigration.new_classes;
  if (mergedMigration.new_sqlite_classes.length === 0) delete mergedMigration.new_sqlite_classes;
  if (!mergedMigration.new_classes && !mergedMigration.new_sqlite_classes) {
    return null;
  }
  return mergedMigration;
}
async function deployWorkerScript(cf, accountId, scriptName, workerContent, metadata, dispatchNamespace) {
  const url = dispatchNamespace ? `https://api.cloudflare.com/client/v4/accounts/${accountId}/workers/dispatch/namespaces/${dispatchNamespace}/scripts/${scriptName}` : `https://api.cloudflare.com/client/v4/accounts/${accountId}/workers/scripts/${scriptName}`;
  const formData = new FormData();
  formData.append("metadata", JSON.stringify(metadata));
  const workerBlob = new Blob([workerContent], {
    type: "application/javascript+module"
  });
  formData.append("index.js", workerBlob, "index.js");
  const token = cf.apiToken;
  const response = await fetch(url, {
    method: "PUT",
    headers: {
      Authorization: `Bearer ${token}`
    },
    body: formData
  });
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Failed to deploy worker: ${response.status} - ${error}`);
  }
  return await response.json();
}
async function createAssetUploadSession(cf, accountId, scriptName, manifest, dispatchNamespace) {
  const url = dispatchNamespace ? `https://api.cloudflare.com/client/v4/accounts/${accountId}/workers/dispatch/namespaces/${dispatchNamespace}/scripts/${scriptName}/assets-upload-session` : `https://api.cloudflare.com/client/v4/accounts/${accountId}/workers/scripts/${scriptName}/assets-upload-session`;
  const token = cf.apiToken;
  const response = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ manifest })
  });
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Failed to create asset upload session: ${response.status} - ${error}`);
  }
  const data = await response.json();
  return data.result;
}
async function uploadAssetBatch(cf, accountId, uploadToken, fileHashes, fileContents) {
  const url = `https://api.cloudflare.com/client/v4/accounts/${accountId}/workers/assets/upload?base64=true`;
  const formData = new FormData();
  for (const hash of fileHashes) {
    const content = fileContents.get(hash);
    if (!content) {
      throw new Error(`Content not found for hash: ${hash}`);
    }
    const base64Content = btoa(String.fromCharCode(...new Uint8Array(content)));
    const blob = new Blob([base64Content], { type: "application/octet-stream" });
    formData.append(hash, blob, hash);
  }
  const response = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${uploadToken}`
    },
    body: formData
  });
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Failed to upload assets: ${response.status} - ${error}`);
  }
  if (response.status === 201) {
    const data = await response.json();
    return data.result?.jwt || null;
  }
  return null;
}
async function createAssetManifest(files) {
  const manifest = {};
  for (const [path, content] of files.entries()) {
    const hash = await calculateFileHash(content);
    manifest[path] = {
      hash,
      size: content.byteLength
    };
  }
  return manifest;
}
var init_deploy = __esm({
  "src/utils/deploy.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    __name(calculateFileHash, "calculateFileHash");
    __name(buildWorkerBindings, "buildWorkerBindings");
    __name(mergeMigrations, "mergeMigrations");
    __name(deployWorkerScript, "deployWorkerScript");
    __name(createAssetUploadSession, "createAssetUploadSession");
    __name(uploadAssetBatch, "uploadAssetBatch");
    __name(createAssetManifest, "createAssetManifest");
  }
});

// src/routes/flows/deploy.ts
var deployFlows, deploy_default;
var init_deploy2 = __esm({
  "src/routes/flows/deploy.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    init_deploy();
    deployFlows = new Hono2();
    deployFlows.post("/from-content", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const {
          script_name,
          content,
          compatibility_date = "2024-06-01",
          compatibility_flags = [],
          bindings = {},
          vars = {},
          dispatch_namespace
        } = body;
        if (!script_name || !content) {
          return c.json(
            { success: false, error: "script_name and content are required" },
            400
          );
        }
        const result = {
          script_name,
          steps_completed: [],
          errors: []
        };
        const workerBindings = buildWorkerBindings(bindings);
        const metadata = {
          main_module: "index.js",
          compatibility_date,
          compatibility_flags,
          bindings: workerBindings
        };
        if (Object.keys(vars).length > 0) {
          metadata.vars = vars;
        }
        try {
          await deployWorkerScript(
            cf,
            accountId,
            script_name,
            content,
            metadata,
            dispatch_namespace
          );
          result.steps_completed.push("worker_deployed");
        } catch (error) {
          result.errors.push({
            step: "deploy_worker",
            error: error.message
          });
          return c.json(
            {
              success: false,
              error: "Failed to deploy worker",
              details: error.message,
              partial_result: result
            },
            500
          );
        }
        try {
          const worker = await cf.workers.scripts.get(script_name, {
            account_id: accountId
          });
          result.worker = worker;
          result.steps_completed.push("deployment_verified");
        } catch (error) {
          console.error("Failed to verify deployment:", error);
        }
        return c.json(
          {
            success: true,
            result,
            message: `Worker '${script_name}' deployed successfully`
          },
          201
        );
      } catch (error) {
        console.error("Error in deploy-from-content flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    deployFlows.post("/from-canvas", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const {
          script_name,
          content,
          assets = {},
          compatibility_date = "2024-06-01",
          compatibility_flags = [],
          bindings = {},
          vars = {},
          asset_config = {},
          dispatch_namespace
        } = body;
        if (!script_name || !content) {
          return c.json(
            { success: false, error: "script_name and content are required" },
            400
          );
        }
        const result = {
          script_name,
          steps_completed: [],
          errors: [],
          assets_uploaded: 0
        };
        const hasAssets = Object.keys(assets).length > 0;
        let assetJwt;
        if (hasAssets) {
          try {
            const assetFiles = /* @__PURE__ */ new Map();
            for (const [path, content2] of Object.entries(assets)) {
              if (typeof content2 === "string") {
                const encoder = new TextEncoder();
                assetFiles.set(path, encoder.encode(content2).buffer);
              }
            }
            const manifest = await createAssetManifest(assetFiles);
            result.steps_completed.push("asset_manifest_created");
            const uploadSession = await createAssetUploadSession(
              cf,
              accountId,
              script_name,
              manifest,
              dispatch_namespace
            );
            result.steps_completed.push("asset_upload_session_created");
            if (uploadSession.buckets && uploadSession.buckets.length > 0) {
              const hashToContent = /* @__PURE__ */ new Map();
              for (const [path, info] of Object.entries(manifest)) {
                const content2 = assetFiles.get(path);
                if (content2) {
                  hashToContent.set(info.hash, content2);
                }
              }
              let completionToken = uploadSession.jwt;
              for (const bucket of uploadSession.buckets) {
                const token = await uploadAssetBatch(
                  cf,
                  accountId,
                  uploadSession.jwt,
                  bucket,
                  hashToContent
                );
                if (token) {
                  completionToken = token;
                }
                result.assets_uploaded += bucket.length;
              }
              assetJwt = completionToken;
              result.steps_completed.push("assets_uploaded");
            } else {
              assetJwt = uploadSession.jwt;
            }
          } catch (error) {
            result.errors.push({
              step: "asset_upload",
              error: error.message
            });
            return c.json(
              {
                success: false,
                error: "Failed to upload assets",
                details: error.message,
                partial_result: result
              },
              500
            );
          }
        }
        const workerBindings = buildWorkerBindings(bindings, hasAssets, asset_config.binding);
        const metadata = {
          main_module: "index.js",
          compatibility_date,
          compatibility_flags,
          bindings: workerBindings
        };
        if (assetJwt) {
          metadata.assets = {
            jwt: assetJwt,
            config: {
              not_found_handling: asset_config.not_found_handling,
              run_worker_first: asset_config.run_worker_first,
              binding: asset_config.binding
            }
          };
        }
        if (Object.keys(vars).length > 0) {
          metadata.vars = vars;
        }
        try {
          await deployWorkerScript(
            cf,
            accountId,
            script_name,
            content,
            metadata,
            dispatch_namespace
          );
          result.steps_completed.push("worker_deployed");
        } catch (error) {
          result.errors.push({
            step: "deploy_worker",
            error: error.message
          });
          return c.json(
            {
              success: false,
              error: "Failed to deploy worker",
              details: error.message,
              partial_result: result
            },
            500
          );
        }
        return c.json(
          {
            success: true,
            result,
            message: `Worker '${script_name}' deployed with ${result.assets_uploaded} assets`
          },
          201
        );
      } catch (error) {
        console.error("Error in deploy-from-canvas flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    deployFlows.post("/with-config", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const {
          script_name,
          content,
          config,
          // Full wrangler-style config
          dispatch_namespace
        } = body;
        if (!script_name || !content || !config) {
          return c.json(
            {
              success: false,
              error: "script_name, content, and config are required"
            },
            400
          );
        }
        const result = {
          script_name,
          steps_completed: [],
          errors: []
        };
        const bindings = {
          kv: config.kv_namespaces || [],
          d1: config.d1_databases || [],
          r2: config.r2_buckets || [],
          durable_objects: config.durable_objects?.bindings || [],
          services: config.services || []
        };
        const workerBindings = buildWorkerBindings(bindings);
        const metadata = {
          main_module: "index.js",
          compatibility_date: config.compatibility_date || "2024-06-01",
          compatibility_flags: config.compatibility_flags,
          bindings: workerBindings
        };
        if (config.migrations) {
          const mergedMigration = mergeMigrations(config.migrations);
          if (mergedMigration) {
            metadata.migrations = mergedMigration;
            const doClasses = [
              ...mergedMigration.new_classes || [],
              ...mergedMigration.new_sqlite_classes || []
            ];
            if (doClasses.length > 0) {
              metadata.exported_handlers = doClasses;
            }
          }
        }
        if (config.vars && Object.keys(config.vars).length > 0) {
          metadata.vars = config.vars;
        }
        try {
          await deployWorkerScript(
            cf,
            accountId,
            script_name,
            content,
            metadata,
            dispatch_namespace
          );
          result.steps_completed.push("worker_deployed");
        } catch (error) {
          result.errors.push({
            step: "deploy_worker",
            error: error.message
          });
          return c.json(
            {
              success: false,
              error: "Failed to deploy worker",
              details: error.message,
              partial_result: result
            },
            500
          );
        }
        return c.json(
          {
            success: true,
            result,
            message: `Worker '${script_name}' deployed with configuration`
          },
          201
        );
      } catch (error) {
        console.error("Error in deploy-with-config flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    deployFlows.put("/update/:scriptName", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const scriptName = c.req.param("scriptName");
        const body = await c.req.json();
        const {
          content,
          vars,
          compatibility_date,
          compatibility_flags,
          dispatch_namespace
        } = body;
        const result = {
          script_name: scriptName,
          steps_completed: [],
          errors: []
        };
        let currentWorker;
        try {
          currentWorker = await cf.workers.scripts.get(scriptName, {
            account_id: accountId
          });
          result.steps_completed.push("current_deployment_fetched");
        } catch (error) {
          return c.json(
            { success: false, error: `Worker '${scriptName}' not found` },
            404
          );
        }
        const metadata = {
          main_module: "index.js",
          compatibility_date: compatibility_date || currentWorker.compatibility_date || "2024-06-01",
          compatibility_flags: compatibility_flags || currentWorker.compatibility_flags,
          bindings: currentWorker.bindings || []
        };
        if (vars) {
          metadata.vars = vars;
        }
        try {
          await deployWorkerScript(
            cf,
            accountId,
            scriptName,
            content || currentWorker.script,
            metadata,
            dispatch_namespace
          );
          result.steps_completed.push("worker_updated");
        } catch (error) {
          result.errors.push({
            step: "update_worker",
            error: error.message
          });
          return c.json(
            {
              success: false,
              error: "Failed to update worker",
              details: error.message,
              partial_result: result
            },
            500
          );
        }
        return c.json({
          success: true,
          result,
          message: `Worker '${scriptName}' updated successfully`
        });
      } catch (error) {
        console.error("Error in update deployment flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    deployFlows.post("/rollback/:scriptName", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const scriptName = c.req.param("scriptName");
        const body = await c.req.json();
        const { version_id, dispatch_namespace } = body;
        const result = {
          script_name: scriptName,
          steps_completed: [],
          errors: []
        };
        let deployments;
        try {
          deployments = await cf.workers.scripts.deployments.list({
            account_id: accountId,
            script_name: scriptName
          });
          result.steps_completed.push("deployment_history_fetched");
        } catch (error) {
          return c.json(
            {
              success: false,
              error: `Failed to get deployment history for '${scriptName}'`,
              details: error.message
            },
            500
          );
        }
        const targetDeployment = version_id ? deployments.find((d) => d.id === version_id) : deployments[1];
        if (!targetDeployment) {
          return c.json(
            { success: false, error: "Target deployment not found" },
            404
          );
        }
        result.target_deployment = {
          id: targetDeployment.id,
          created_on: targetDeployment.created_on
        };
        return c.json({
          success: true,
          result,
          message: `Rollback information retrieved for '${scriptName}'`,
          note: "Actual rollback requires worker content to be stored. Consider using Workers Versions API."
        });
      } catch (error) {
        console.error("Error in rollback flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    deployFlows.post("/batch", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const { workers: workers2, dispatch_namespace } = body;
        if (!Array.isArray(workers2) || workers2.length === 0) {
          return c.json(
            { success: false, error: "workers array is required" },
            400
          );
        }
        const results = [];
        let successCount = 0;
        let failureCount = 0;
        for (const worker of workers2) {
          const { script_name, content, bindings = {}, vars = {} } = worker;
          const workerResult = {
            script_name,
            success: false,
            steps_completed: [],
            errors: []
          };
          try {
            const workerBindings = buildWorkerBindings(bindings);
            const metadata = {
              main_module: "index.js",
              compatibility_date: worker.compatibility_date || "2024-06-01",
              compatibility_flags: worker.compatibility_flags,
              bindings: workerBindings
            };
            if (Object.keys(vars).length > 0) {
              metadata.vars = vars;
            }
            await deployWorkerScript(
              cf,
              accountId,
              script_name,
              content,
              metadata,
              dispatch_namespace
            );
            workerResult.success = true;
            workerResult.steps_completed.push("deployed");
            successCount++;
          } catch (error) {
            workerResult.errors.push({
              step: "deploy",
              error: error.message
            });
            failureCount++;
          }
          results.push(workerResult);
        }
        return c.json({
          success: failureCount === 0,
          result: {
            total: workers2.length,
            successful: successCount,
            failed: failureCount,
            deployments: results
          },
          message: `Batch deployment completed: ${successCount}/${workers2.length} successful`
        });
      } catch (error) {
        console.error("Error in batch deploy flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    deployFlows.get("/status/:scriptName", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const scriptName = c.req.param("scriptName");
        const status = {
          script_name: scriptName
        };
        try {
          const workerResponse = await cf.workers.scripts.get(scriptName, {
            account_id: accountId
          });
          const worker = await workerResponse.json();
          status.worker = {
            id: worker.id,
            created_on: worker.created_on,
            modified_on: worker.modified_on,
            compatibility_date: worker.compatibility_date,
            bindings: worker.bindings?.length || 0
          };
        } catch (error) {
          return c.json(
            { success: false, error: `Worker '${scriptName}' not found` },
            404
          );
        }
        try {
          const deployments = await cf.workers.scripts.deployments.list({
            account_id: accountId,
            script_name: scriptName
          });
          status.deployments = deployments.slice(0, 10).map((d) => ({
            id: d.id,
            created_on: d.created_on,
            source: d.source
          }));
          status.deployment_count = deployments.length;
        } catch (error) {
          console.error("Failed to get deployment history:", error);
        }
        try {
          const subdomainResponse = await cf.workers.subdomains.get({
            account_id: accountId
          });
          const subdomain = subdomainResponse.subdomain;
          status.url = `https://${scriptName}.${subdomain}.workers.dev`;
        } catch (error) {
          console.error("Failed to get subdomain:", error);
        }
        return c.json({
          success: true,
          result: status
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    deployFlows.delete("/:scriptName", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const scriptName = c.req.param("scriptName");
        const dispatchNamespace = c.req.query("dispatch_namespace");
        await cf.workers.scripts.delete(scriptName, {
          account_id: accountId
        });
        return c.json({
          success: true,
          message: `Worker '${scriptName}' deleted successfully`
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    deploy_default = deployFlows;
  }
});

// src/routes/flows/github-deploy.ts
var githubDeployFlows, github_deploy_default;
var init_github_deploy = __esm({
  "src/routes/flows/github-deploy.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    init_deploy();
    githubDeployFlows = new Hono2();
    githubDeployFlows.post("/deploy-with-github", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const apiClient = c.get("apiClient");
        const body = await c.req.json();
        const {
          worker_name,
          github_owner,
          github_repo,
          worker_content,
          // Worker script content
          wrangler_config,
          // wrangler.jsonc content (optional)
          assets = {},
          // Simple assets map { path: content } (max 2-3 for fast pass)
          production_branch = "main",
          build_command = "npm run build",
          deploy_command = "npm run deploy",
          create_github_repo = true,
          // Default: create repo if doesn't exist
          core_github_api_url,
          // URL to core-github-api service
          auto_fix_builds = true
          // Enable AI-powered auto-fix
        } = body;
        const result = {
          worker_name,
          steps_completed: [],
          errors: [],
          bindings_created: []
        };
        let detectedBindings = {};
        let compatibilityDate = "2024-06-01";
        let compatibilityFlags = [];
        if (wrangler_config) {
          try {
            const config = typeof wrangler_config === "string" ? JSON.parse(wrangler_config.replace(/\/\/.*$/gm, "")) : wrangler_config;
            compatibilityDate = config.compatibility_date || compatibilityDate;
            compatibilityFlags = config.compatibility_flags || [];
            detectedBindings = {
              kv: config.kv_namespaces || [],
              d1: config.d1_databases || [],
              r2: config.r2_buckets || [],
              vectorize: config.vectorize || [],
              durable_objects: config.durable_objects?.bindings || [],
              services: config.services || [],
              analytics_engine: config.analytics_engine_datasets || [],
              queues: config.queues?.producers || []
            };
            result.steps_completed.push("wrangler_config_parsed");
            result.detected_bindings = Object.keys(detectedBindings).filter(
              (key) => Array.isArray(detectedBindings[key]) && detectedBindings[key].length > 0
            );
          } catch (error) {
            result.errors.push({
              step: "parse_wrangler_config",
              error: error.message
            });
          }
        }
        const createdBindings = {
          kv: [],
          d1: [],
          r2: [],
          vectorize: [],
          durable_objects: []
        };
        for (const kv of detectedBindings.kv || []) {
          if (!kv.id && !kv.namespace_id) {
            try {
              const namespace = await cf.kv.namespaces.create({
                account_id: accountId,
                title: kv.binding || `kv-${worker_name}`
              });
              createdBindings.kv.push({
                binding: kv.binding,
                id: namespace.id,
                namespace_id: namespace.id
              });
              result.bindings_created.push({ type: "kv", name: kv.binding, id: namespace.id });
            } catch (error) {
              result.errors.push({
                step: "create_kv",
                binding: kv.binding,
                error: error.message
              });
            }
          } else {
            createdBindings.kv.push({
              binding: kv.binding,
              id: kv.id || kv.namespace_id,
              namespace_id: kv.id || kv.namespace_id
            });
          }
        }
        for (const d1 of detectedBindings.d1 || []) {
          if (!d1.database_id) {
            try {
              const database = await cf.d1.database.create({
                account_id: accountId,
                name: d1.binding || `d1-${worker_name}`
              });
              createdBindings.d1.push({
                binding: d1.binding,
                database_id: database.uuid,
                database_name: database.name
              });
              result.bindings_created.push({ type: "d1", name: d1.binding, id: database.uuid });
            } catch (error) {
              result.errors.push({
                step: "create_d1",
                binding: d1.binding,
                error: error.message
              });
            }
          } else {
            createdBindings.d1.push({
              binding: d1.binding,
              database_id: d1.database_id,
              database_name: d1.database_name
            });
          }
        }
        for (const r2 of detectedBindings.r2 || []) {
          if (!r2.bucket_name) {
            try {
              const bucketName = (r2.binding || `r2-${worker_name}`).toLowerCase();
              const bucket = await cf.r2.buckets.create({
                account_id: accountId,
                name: bucketName
              });
              createdBindings.r2.push({
                binding: r2.binding,
                bucket_name: bucketName
              });
              result.bindings_created.push({ type: "r2", name: r2.binding, bucket: bucketName });
            } catch (error) {
              result.errors.push({
                step: "create_r2",
                binding: r2.binding,
                error: error.message
              });
            }
          } else {
            createdBindings.r2.push({
              binding: r2.binding,
              bucket_name: r2.bucket_name
            });
          }
        }
        for (const vec of detectedBindings.vectorize || []) {
          if (!vec.index_name) {
            try {
              const indexName = vec.binding || `vectorize-${worker_name}`;
              const index = await cf.vectorize.indexes.create({
                account_id: accountId,
                name: indexName,
                config: vec.config || {
                  dimensions: 768,
                  metric: "cosine"
                }
              });
              createdBindings.vectorize.push({
                binding: vec.binding,
                index_name: indexName,
                index_id: index.id
              });
              result.bindings_created.push({ type: "vectorize", name: vec.binding, id: index.id });
            } catch (error) {
              result.errors.push({
                step: "create_vectorize",
                binding: vec.binding,
                error: error.message
              });
            }
          } else {
            createdBindings.vectorize.push({
              binding: vec.binding,
              index_name: vec.index_name,
              index_id: vec.index_id
            });
          }
        }
        if (result.bindings_created.length > 0) {
          result.steps_completed.push("bindings_created");
        }
        let githubRepoInfo = null;
        if (create_github_repo && core_github_api_url) {
          try {
            const githubApiResponse = await fetch(`${core_github_api_url}/repos/create`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: c.req.header("Authorization") || ""
              },
              body: JSON.stringify({
                owner: github_owner,
                name: github_repo,
                description: `Cloudflare Worker: ${worker_name}`,
                private: true,
                auto_init: true
              })
            });
            if (githubApiResponse.ok) {
              githubRepoInfo = await githubApiResponse.json();
              result.steps_completed.push("github_repo_created");
            } else {
              const getRepoResponse = await fetch(`${core_github_api_url}/repos/${github_owner}/${github_repo}`, {
                headers: {
                  Authorization: c.req.header("Authorization") || ""
                }
              });
              if (getRepoResponse.ok) {
                githubRepoInfo = await getRepoResponse.json();
                result.steps_completed.push("github_repo_found");
              }
            }
          } catch (error) {
            result.errors.push({
              step: "github_repo",
              error: error.message
            });
          }
        }
        try {
          try {
            await cf.workers.scripts.get(worker_name, { account_id: accountId });
            result.steps_completed.push("worker_found");
          } catch (error) {
            result.steps_completed.push("worker_will_be_created");
          }
        } catch (error) {
        }
        let assetJwt;
        const hasAssets = Object.keys(assets).length > 0 && Object.keys(assets).length <= 3;
        if (hasAssets) {
          try {
            const assetFiles = /* @__PURE__ */ new Map();
            for (const [path, content] of Object.entries(assets)) {
              const contentStr = typeof content === "string" ? content : JSON.stringify(content);
              const encoder = new TextEncoder();
              assetFiles.set(path.startsWith("/") ? path : `/${path}`, encoder.encode(contentStr).buffer);
            }
            const manifest = await createAssetManifest(assetFiles);
            result.steps_completed.push("asset_manifest_created");
            const uploadSession = await createAssetUploadSession(
              cf,
              accountId,
              worker_name,
              manifest
            );
            result.steps_completed.push("asset_upload_session_created");
            if (uploadSession.buckets && uploadSession.buckets.length > 0) {
              const hashToContent = /* @__PURE__ */ new Map();
              for (const [path, info] of Object.entries(manifest)) {
                const content = assetFiles.get(path);
                if (content) {
                  hashToContent.set(info.hash, content);
                }
              }
              let completionToken = uploadSession.jwt;
              for (const bucket of uploadSession.buckets) {
                const token = await uploadAssetBatch(
                  cf,
                  accountId,
                  uploadSession.jwt,
                  bucket,
                  hashToContent
                );
                if (token) {
                  completionToken = token;
                }
              }
              assetJwt = completionToken;
              result.steps_completed.push("assets_uploaded");
            } else {
              assetJwt = uploadSession.jwt;
            }
          } catch (error) {
            result.errors.push({
              step: "asset_upload",
              error: error.message
            });
          }
        }
        const allBindings = {
          kv: [...detectedBindings.kv || [], ...createdBindings.kv].map((kv) => ({
            binding: kv.binding,
            id: kv.id || kv.namespace_id
          })),
          d1: [...detectedBindings.d1 || [], ...createdBindings.d1].map((d1) => ({
            binding: d1.binding,
            database_id: d1.database_id
          })),
          r2: [...detectedBindings.r2 || [], ...createdBindings.r2].map((r2) => ({
            binding: r2.binding,
            bucket_name: r2.bucket_name
          })),
          vectorize: [...detectedBindings.vectorize || [], ...createdBindings.vectorize].map((vec) => ({
            binding: vec.binding,
            index_name: vec.index_name || vec.binding
          })),
          durable_objects: detectedBindings.durable_objects || [],
          services: detectedBindings.services || [],
          analytics_engine: detectedBindings.analytics_engine || [],
          queues: detectedBindings.queues || []
        };
        const workerBindings = buildWorkerBindings(allBindings, hasAssets, "ASSETS");
        try {
          const metadata = {
            main_module: "index.js",
            compatibility_date: compatibilityDate,
            compatibility_flags: compatibilityFlags,
            bindings: workerBindings
          };
          if (assetJwt) {
            metadata.assets = {
              jwt: assetJwt,
              config: {
                binding: "ASSETS",
                not_found_handling: "single-page-application"
                // Default for SPA
              }
            };
          }
          await deployWorkerScript(
            cf,
            accountId,
            worker_name,
            worker_content,
            metadata
          );
          result.steps_completed.push("worker_deployed");
        } catch (error) {
          result.errors.push({
            step: "worker_deployment",
            error: error.message
          });
          return c.json(
            {
              success: false,
              error: "Failed to deploy worker",
              details: error.message,
              partial_result: result
            },
            500
          );
        }
        if (github_owner && github_repo) {
          try {
            const repoConnectionResponse = await apiClient.put(
              `/accounts/${accountId}/builds/repos/connections`,
              {
                provider_type: "github",
                provider_account_id: "cloudflare",
                provider_account_name: "Cloudflare",
                repo_id: github_repo,
                repo_name: github_repo
              }
            );
            const repoConnection = repoConnectionResponse.result;
            result.repo_connection = {
              id: repoConnection.uuid || repoConnection.id
            };
            result.steps_completed.push("repo_connection_created");
            let buildTokenUuid;
            try {
              const tokensResponse = await apiClient.get(
                `/accounts/${accountId}/builds/tokens`
              );
              if (tokensResponse.result && tokensResponse.result.length > 0) {
                buildTokenUuid = tokensResponse.result[0].build_token_uuid;
              } else {
                const newTokenResponse = await apiClient.post(
                  `/accounts/${accountId}/builds/tokens`,
                  {
                    build_token_name: `${worker_name}-build-token`
                  }
                );
                buildTokenUuid = newTokenResponse.result.build_token_uuid;
              }
            } catch (tokenError) {
              console.warn("Could not get/create build token:", tokenError.message);
            }
            if (buildTokenUuid) {
              const triggerResponse = await apiClient.post(
                `/accounts/${accountId}/builds/triggers`,
                {
                  repo_connection_uuid: repoConnection.uuid || repoConnection.id,
                  external_script_id: worker_name,
                  trigger_name: `${worker_name}-production`,
                  branch_includes: [production_branch],
                  branch_excludes: [],
                  build_command: build_command || "npm run build",
                  deploy_command: deploy_command || "npm run deploy",
                  root_directory: "/",
                  path_includes: ["*"],
                  path_excludes: [],
                  build_token_uuid: buildTokenUuid
                }
              );
              result.trigger = {
                id: triggerResponse.result.trigger_uuid,
                branch: production_branch
              };
              result.steps_completed.push("cicd_trigger_created");
            }
          } catch (error) {
            result.errors.push({
              step: "cicd_setup",
              error: error.message
            });
          }
        }
        return c.json(
          {
            success: result.errors.length === 0,
            result,
            message: result.errors.length === 0 ? `Worker '${worker_name}' deployed with GitHub CI/CD` : "Worker deployed with some errors"
          },
          result.errors.length === 0 ? 201 : 207
        );
      } catch (error) {
        console.error("Error in GitHub deployment flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    githubDeployFlows.post("/analyze-and-fix-build", async (c) => {
      try {
        const apiClient = c.get("apiClient");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const {
          build_uuid,
          trigger_uuid,
          github_owner,
          github_repo,
          github_branch = "main",
          core_github_api_url,
          auto_fix = true
        } = body;
        const result = {
          build_uuid,
          analysis: {},
          fixes_applied: [],
          errors: []
        };
        let buildLogs = "";
        try {
          const logsResponse = await apiClient.get(
            `/accounts/${accountId}/builds/builds/${build_uuid}/logs`
          );
          buildLogs = JSON.stringify(logsResponse.result || logsResponse);
          result.steps_completed = ["build_logs_fetched"];
        } catch (error) {
          return c.json(
            {
              success: false,
              error: "Failed to fetch build logs",
              details: error.message
            },
            500
          );
        }
        let aiAnalysis = null;
        try {
          if (c.env.AI) {
            const aiResponse = await c.env.AI.run("@cf/openai/gpt-oss-120b", {
              instructions: `You are a build log analyzer. Analyze the following build logs and identify:
1. The root cause of the build failure
2. Specific error messages
3. Recommended fixes (especially for common issues like outdated package-lock.json, missing dependencies, etc.)
4. Whether the fix can be automated

Return a JSON object with: error_type, root_cause, recommended_fixes (array), can_auto_fix (boolean), fix_commands (array)`,
              input: buildLogs
            });
            aiAnalysis = typeof aiResponse === "string" ? JSON.parse(aiResponse) : aiResponse;
            result.analysis = aiAnalysis;
            result.steps_completed.push("ai_analysis_complete");
          } else {
            const commonErrors = [
              { pattern: /package-lock\.json.*outdated/i, fix: "npm install", type: "outdated_lockfile" },
              { pattern: /Cannot find module/i, fix: "npm install", type: "missing_dependency" },
              { pattern: /EACCES|permission denied/i, fix: "sudo npm install", type: "permission_error" }
            ];
            for (const error of commonErrors) {
              if (error.pattern.test(buildLogs)) {
                aiAnalysis = {
                  error_type: error.type,
                  root_cause: "Common build error detected",
                  recommended_fixes: [error.fix],
                  can_auto_fix: true,
                  fix_commands: [error.fix]
                };
                result.analysis = aiAnalysis;
                break;
              }
            }
          }
        } catch (error) {
          result.errors.push({
            step: "ai_analysis",
            error: error.message
          });
        }
        if (auto_fix && aiAnalysis?.can_auto_fix && core_github_api_url && github_owner && github_repo) {
          try {
            const fixResponse = await fetch(`${core_github_api_url}/repos/${github_owner}/${github_repo}/fix-build`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: c.req.header("Authorization") || ""
              },
              body: JSON.stringify({
                branch: github_branch,
                fixes: aiAnalysis.fix_commands || [],
                error_type: aiAnalysis.error_type
              })
            });
            if (fixResponse.ok) {
              const fixResult = await fixResponse.json();
              result.fixes_applied = fixResult.fixes || [];
              result.steps_completed.push("auto_fix_applied");
              if (trigger_uuid) {
                const newBuildResponse = await apiClient.post(
                  `/accounts/${accountId}/builds/triggers/${trigger_uuid}/builds`,
                  { branch: github_branch }
                );
                result.new_build = {
                  build_uuid: newBuildResponse.result?.build_uuid || newBuildResponse.result?.id,
                  status: "triggered"
                };
                result.steps_completed.push("new_build_triggered");
              }
            }
          } catch (error) {
            result.errors.push({
              step: "auto_fix",
              error: error.message
            });
          }
        }
        return c.json({
          success: result.errors.length === 0,
          result,
          message: aiAnalysis?.can_auto_fix ? "Build analyzed and fixes applied" : "Build analyzed - manual intervention may be required"
        });
      } catch (error) {
        console.error("Error in build analysis flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    githubDeployFlows.post("/fast-deploy", async (c) => {
      try {
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const body = await c.req.json();
        const {
          worker_name,
          worker_content,
          assets = {},
          // Max 2-3 assets for fast pass
          github_owner,
          github_repo,
          skip_github = false
          // Allow skipping GitHub for ultra-fast deploys
        } = body;
        if (Object.keys(assets).length > 3) {
          return c.json(
            {
              success: false,
              error: "Fast deploy supports maximum 3 assets. Use /deploy-with-github for more."
            },
            400
          );
        }
        const deployBody = {
          worker_name,
          worker_content,
          assets,
          github_owner: skip_github ? void 0 : github_owner,
          github_repo: skip_github ? void 0 : github_repo,
          create_github_repo: !skip_github,
          production_branch: "main",
          build_command: "npm run build",
          deploy_command: "npm run deploy",
          auto_fix_builds: false
          // Skip AI analysis for speed
        };
        const deployResponse = await fetch(`${c.req.url.replace("/fast-deploy", "/deploy-with-github")}`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: c.req.header("Authorization") || ""
          },
          body: JSON.stringify(deployBody)
        });
        const deployResult = await deployResponse.json();
        return c.json({
          ...deployResult,
          fast_deploy: true,
          message: `Fast deployment completed for ${worker_name}`
        }, deployResponse.status);
      } catch (error) {
        console.error("Error in fast deploy flow:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    github_deploy_default = githubDeployFlows;
  }
});

// src/routes/flows/index.ts
var flows, flows_default;
var init_flows = __esm({
  "src/routes/flows/index.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    init_token3();
    init_project();
    init_health2();
    init_cicd2();
    init_deploy2();
    init_github_deploy();
    flows = new Hono2();
    flows.route("/token", token_default);
    flows.route("/project", project_default);
    flows.route("/health", health_default);
    flows.route("/cicd", cicd_default2);
    flows.route("/deploy", deploy_default);
    flows.route("/github-deploy", github_deploy_default);
    flows_default = flows;
  }
});

// node_modules/kysely/dist/esm/util/object-utils.js
function isUndefined(obj) {
  return typeof obj === "undefined" || obj === void 0;
}
function isString(obj) {
  return typeof obj === "string";
}
function isNumber(obj) {
  return typeof obj === "number";
}
function isBoolean(obj) {
  return typeof obj === "boolean";
}
function isNull(obj) {
  return obj === null;
}
function isDate(obj) {
  return obj instanceof Date;
}
function isBigInt(obj) {
  return typeof obj === "bigint";
}
function isBuffer(obj) {
  return typeof Buffer !== "undefined" && Buffer.isBuffer(obj);
}
function isFunction(obj) {
  return typeof obj === "function";
}
function isObject(obj) {
  return typeof obj === "object" && obj !== null;
}
function freeze(obj) {
  return Object.freeze(obj);
}
function asArray(arg) {
  if (isReadonlyArray(arg)) {
    return arg;
  } else {
    return [arg];
  }
}
function isReadonlyArray(arg) {
  return Array.isArray(arg);
}
function noop(obj) {
  return obj;
}
var init_object_utils = __esm({
  "node_modules/kysely/dist/esm/util/object-utils.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    __name(isUndefined, "isUndefined");
    __name(isString, "isString");
    __name(isNumber, "isNumber");
    __name(isBoolean, "isBoolean");
    __name(isNull, "isNull");
    __name(isDate, "isDate");
    __name(isBigInt, "isBigInt");
    __name(isBuffer, "isBuffer");
    __name(isFunction, "isFunction");
    __name(isObject, "isObject");
    __name(freeze, "freeze");
    __name(asArray, "asArray");
    __name(isReadonlyArray, "isReadonlyArray");
    __name(noop, "noop");
  }
});

// node_modules/kysely/dist/esm/operation-node/alter-table-node.js
var AlterTableNode;
var init_alter_table_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/alter-table-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    AlterTableNode = freeze({
      is(node) {
        return node.kind === "AlterTableNode";
      },
      create(table) {
        return freeze({
          kind: "AlterTableNode",
          table
        });
      },
      cloneWithTableProps(node, props) {
        return freeze({
          ...node,
          ...props
        });
      },
      cloneWithColumnAlteration(node, columnAlteration) {
        return freeze({
          ...node,
          columnAlterations: node.columnAlterations ? [...node.columnAlterations, columnAlteration] : [columnAlteration]
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/identifier-node.js
var IdentifierNode;
var init_identifier_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/identifier-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    IdentifierNode = freeze({
      is(node) {
        return node.kind === "IdentifierNode";
      },
      create(name) {
        return freeze({
          kind: "IdentifierNode",
          name
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/create-index-node.js
var CreateIndexNode;
var init_create_index_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/create-index-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_identifier_node();
    CreateIndexNode = freeze({
      is(node) {
        return node.kind === "CreateIndexNode";
      },
      create(name) {
        return freeze({
          kind: "CreateIndexNode",
          name: IdentifierNode.create(name)
        });
      },
      cloneWith(node, props) {
        return freeze({
          ...node,
          ...props
        });
      },
      cloneWithColumns(node, columns) {
        return freeze({
          ...node,
          columns: [...node.columns || [], ...columns]
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/create-schema-node.js
var CreateSchemaNode;
var init_create_schema_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/create-schema-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_identifier_node();
    CreateSchemaNode = freeze({
      is(node) {
        return node.kind === "CreateSchemaNode";
      },
      create(schema, params) {
        return freeze({
          kind: "CreateSchemaNode",
          schema: IdentifierNode.create(schema),
          ...params
        });
      },
      cloneWith(createSchema, params) {
        return freeze({
          ...createSchema,
          ...params
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/create-table-node.js
var ON_COMMIT_ACTIONS, CreateTableNode;
var init_create_table_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/create-table-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    ON_COMMIT_ACTIONS = ["preserve rows", "delete rows", "drop"];
    CreateTableNode = freeze({
      is(node) {
        return node.kind === "CreateTableNode";
      },
      create(table) {
        return freeze({
          kind: "CreateTableNode",
          table,
          columns: freeze([])
        });
      },
      cloneWithColumn(createTable, column) {
        return freeze({
          ...createTable,
          columns: freeze([...createTable.columns, column])
        });
      },
      cloneWithConstraint(createTable, constraint) {
        return freeze({
          ...createTable,
          constraints: createTable.constraints ? freeze([...createTable.constraints, constraint]) : freeze([constraint])
        });
      },
      cloneWithFrontModifier(createTable, modifier) {
        return freeze({
          ...createTable,
          frontModifiers: createTable.frontModifiers ? freeze([...createTable.frontModifiers, modifier]) : freeze([modifier])
        });
      },
      cloneWithEndModifier(createTable, modifier) {
        return freeze({
          ...createTable,
          endModifiers: createTable.endModifiers ? freeze([...createTable.endModifiers, modifier]) : freeze([modifier])
        });
      },
      cloneWith(createTable, params) {
        return freeze({
          ...createTable,
          ...params
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/schemable-identifier-node.js
var SchemableIdentifierNode;
var init_schemable_identifier_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/schemable-identifier-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_identifier_node();
    SchemableIdentifierNode = freeze({
      is(node) {
        return node.kind === "SchemableIdentifierNode";
      },
      create(identifier) {
        return freeze({
          kind: "SchemableIdentifierNode",
          identifier: IdentifierNode.create(identifier)
        });
      },
      createWithSchema(schema, identifier) {
        return freeze({
          kind: "SchemableIdentifierNode",
          schema: IdentifierNode.create(schema),
          identifier: IdentifierNode.create(identifier)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/drop-index-node.js
var DropIndexNode;
var init_drop_index_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/drop-index-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_schemable_identifier_node();
    DropIndexNode = freeze({
      is(node) {
        return node.kind === "DropIndexNode";
      },
      create(name, params) {
        return freeze({
          kind: "DropIndexNode",
          name: SchemableIdentifierNode.create(name),
          ...params
        });
      },
      cloneWith(dropIndex, props) {
        return freeze({
          ...dropIndex,
          ...props
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/drop-schema-node.js
var DropSchemaNode;
var init_drop_schema_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/drop-schema-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_identifier_node();
    DropSchemaNode = freeze({
      is(node) {
        return node.kind === "DropSchemaNode";
      },
      create(schema, params) {
        return freeze({
          kind: "DropSchemaNode",
          schema: IdentifierNode.create(schema),
          ...params
        });
      },
      cloneWith(dropSchema, params) {
        return freeze({
          ...dropSchema,
          ...params
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/drop-table-node.js
var DropTableNode;
var init_drop_table_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/drop-table-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    DropTableNode = freeze({
      is(node) {
        return node.kind === "DropTableNode";
      },
      create(table, params) {
        return freeze({
          kind: "DropTableNode",
          table,
          ...params
        });
      },
      cloneWith(dropIndex, params) {
        return freeze({
          ...dropIndex,
          ...params
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/alias-node.js
var AliasNode;
var init_alias_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/alias-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    AliasNode = freeze({
      is(node) {
        return node.kind === "AliasNode";
      },
      create(node, alias) {
        return freeze({
          kind: "AliasNode",
          node,
          alias
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/table-node.js
var TableNode;
var init_table_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/table-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_schemable_identifier_node();
    TableNode = freeze({
      is(node) {
        return node.kind === "TableNode";
      },
      create(table) {
        return freeze({
          kind: "TableNode",
          table: SchemableIdentifierNode.create(table)
        });
      },
      createWithSchema(schema, table) {
        return freeze({
          kind: "TableNode",
          table: SchemableIdentifierNode.createWithSchema(schema, table)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/operation-node-source.js
function isOperationNodeSource(obj) {
  return isObject(obj) && isFunction(obj.toOperationNode);
}
var init_operation_node_source = __esm({
  "node_modules/kysely/dist/esm/operation-node/operation-node-source.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    __name(isOperationNodeSource, "isOperationNodeSource");
  }
});

// node_modules/kysely/dist/esm/expression/expression.js
function isExpression(obj) {
  return isObject(obj) && "expressionType" in obj && isOperationNodeSource(obj);
}
function isAliasedExpression(obj) {
  return isObject(obj) && "expression" in obj && isString(obj.alias) && isOperationNodeSource(obj);
}
var init_expression = __esm({
  "node_modules/kysely/dist/esm/expression/expression.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_operation_node_source();
    init_object_utils();
    __name(isExpression, "isExpression");
    __name(isAliasedExpression, "isAliasedExpression");
  }
});

// node_modules/kysely/dist/esm/operation-node/select-modifier-node.js
var SelectModifierNode;
var init_select_modifier_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/select-modifier-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    SelectModifierNode = freeze({
      is(node) {
        return node.kind === "SelectModifierNode";
      },
      create(modifier, of) {
        return freeze({
          kind: "SelectModifierNode",
          modifier,
          of
        });
      },
      createWithExpression(modifier) {
        return freeze({
          kind: "SelectModifierNode",
          rawModifier: modifier
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/and-node.js
var AndNode;
var init_and_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/and-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    AndNode = freeze({
      is(node) {
        return node.kind === "AndNode";
      },
      create(left, right) {
        return freeze({
          kind: "AndNode",
          left,
          right
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/or-node.js
var OrNode;
var init_or_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/or-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    OrNode = freeze({
      is(node) {
        return node.kind === "OrNode";
      },
      create(left, right) {
        return freeze({
          kind: "OrNode",
          left,
          right
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/on-node.js
var OnNode;
var init_on_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/on-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_and_node();
    init_or_node();
    OnNode = freeze({
      is(node) {
        return node.kind === "OnNode";
      },
      create(filter) {
        return freeze({
          kind: "OnNode",
          on: filter
        });
      },
      cloneWithOperation(onNode, operator, operation) {
        return freeze({
          ...onNode,
          on: operator === "And" ? AndNode.create(onNode.on, operation) : OrNode.create(onNode.on, operation)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/join-node.js
var JoinNode;
var init_join_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/join-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_on_node();
    JoinNode = freeze({
      is(node) {
        return node.kind === "JoinNode";
      },
      create(joinType, table) {
        return freeze({
          kind: "JoinNode",
          joinType,
          table,
          on: void 0
        });
      },
      createWithOn(joinType, table, on) {
        return freeze({
          kind: "JoinNode",
          joinType,
          table,
          on: OnNode.create(on)
        });
      },
      cloneWithOn(joinNode, operation) {
        return freeze({
          ...joinNode,
          on: joinNode.on ? OnNode.cloneWithOperation(joinNode.on, "And", operation) : OnNode.create(operation)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/binary-operation-node.js
var BinaryOperationNode;
var init_binary_operation_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/binary-operation-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    BinaryOperationNode = freeze({
      is(node) {
        return node.kind === "BinaryOperationNode";
      },
      create(leftOperand, operator, rightOperand) {
        return freeze({
          kind: "BinaryOperationNode",
          leftOperand,
          operator,
          rightOperand
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/operator-node.js
function isJSONOperator(op) {
  return isString(op) && JSON_OPERATORS.includes(op);
}
var COMPARISON_OPERATORS, ARITHMETIC_OPERATORS, JSON_OPERATORS, BINARY_OPERATORS, UNARY_FILTER_OPERATORS, UNARY_OPERATORS, OPERATORS, OperatorNode;
var init_operator_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/operator-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    COMPARISON_OPERATORS = [
      "=",
      "==",
      "!=",
      "<>",
      ">",
      ">=",
      "<",
      "<=",
      "in",
      "not in",
      "is",
      "is not",
      "like",
      "not like",
      "match",
      "ilike",
      "not ilike",
      "@>",
      "<@",
      "^@",
      "&&",
      "?",
      "?&",
      "?|",
      "!<",
      "!>",
      "<=>",
      "!~",
      "~",
      "~*",
      "!~*",
      "@@",
      "@@@",
      "!!",
      "<->",
      "regexp",
      "is distinct from",
      "is not distinct from"
    ];
    ARITHMETIC_OPERATORS = [
      "+",
      "-",
      "*",
      "/",
      "%",
      "^",
      "&",
      "|",
      "#",
      "<<",
      ">>"
    ];
    JSON_OPERATORS = ["->", "->>"];
    BINARY_OPERATORS = [
      ...COMPARISON_OPERATORS,
      ...ARITHMETIC_OPERATORS,
      "&&",
      "||"
    ];
    UNARY_FILTER_OPERATORS = ["exists", "not exists"];
    UNARY_OPERATORS = ["not", "-", ...UNARY_FILTER_OPERATORS];
    OPERATORS = [
      ...BINARY_OPERATORS,
      ...JSON_OPERATORS,
      ...UNARY_OPERATORS,
      "between",
      "between symmetric"
    ];
    OperatorNode = freeze({
      is(node) {
        return node.kind === "OperatorNode";
      },
      create(operator) {
        return freeze({
          kind: "OperatorNode",
          operator
        });
      }
    });
    __name(isJSONOperator, "isJSONOperator");
  }
});

// node_modules/kysely/dist/esm/operation-node/column-node.js
var ColumnNode;
var init_column_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/column-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_identifier_node();
    ColumnNode = freeze({
      is(node) {
        return node.kind === "ColumnNode";
      },
      create(column) {
        return freeze({
          kind: "ColumnNode",
          column: IdentifierNode.create(column)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/select-all-node.js
var SelectAllNode;
var init_select_all_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/select-all-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    SelectAllNode = freeze({
      is(node) {
        return node.kind === "SelectAllNode";
      },
      create() {
        return freeze({
          kind: "SelectAllNode"
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/reference-node.js
var ReferenceNode;
var init_reference_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/reference-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_select_all_node();
    init_object_utils();
    ReferenceNode = freeze({
      is(node) {
        return node.kind === "ReferenceNode";
      },
      create(column, table) {
        return freeze({
          kind: "ReferenceNode",
          table,
          column
        });
      },
      createSelectAll(table) {
        return freeze({
          kind: "ReferenceNode",
          table,
          column: SelectAllNode.create()
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/dynamic/dynamic-reference-builder.js
function isDynamicReferenceBuilder(obj) {
  return isObject(obj) && isOperationNodeSource(obj) && isString(obj.dynamicReference);
}
var DynamicReferenceBuilder;
var init_dynamic_reference_builder = __esm({
  "node_modules/kysely/dist/esm/dynamic/dynamic-reference-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_operation_node_source();
    init_reference_parser();
    init_object_utils();
    DynamicReferenceBuilder = class {
      static {
        __name(this, "DynamicReferenceBuilder");
      }
      #dynamicReference;
      get dynamicReference() {
        return this.#dynamicReference;
      }
      /**
       * @private
       *
       * This needs to be here just so that the typings work. Without this
       * the generated .d.ts file contains no reference to the type param R
       * which causes this type to be equal to DynamicReferenceBuilder with
       * any R.
       */
      get refType() {
        return void 0;
      }
      constructor(reference) {
        this.#dynamicReference = reference;
      }
      toOperationNode() {
        return parseSimpleReferenceExpression(this.#dynamicReference);
      }
    };
    __name(isDynamicReferenceBuilder, "isDynamicReferenceBuilder");
  }
});

// node_modules/kysely/dist/esm/operation-node/order-by-item-node.js
var OrderByItemNode;
var init_order_by_item_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/order-by-item-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    OrderByItemNode = freeze({
      is(node) {
        return node.kind === "OrderByItemNode";
      },
      create(orderBy, direction) {
        return freeze({
          kind: "OrderByItemNode",
          orderBy,
          direction
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/raw-node.js
var RawNode;
var init_raw_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/raw-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    RawNode = freeze({
      is(node) {
        return node.kind === "RawNode";
      },
      create(sqlFragments, parameters) {
        return freeze({
          kind: "RawNode",
          sqlFragments: freeze(sqlFragments),
          parameters: freeze(parameters)
        });
      },
      createWithSql(sql2) {
        return RawNode.create([sql2], []);
      },
      createWithChild(child) {
        return RawNode.create(["", ""], [child]);
      },
      createWithChildren(children) {
        return RawNode.create(new Array(children.length + 1).fill(""), children);
      }
    });
  }
});

// node_modules/kysely/dist/esm/parser/order-by-parser.js
function isOrderByDirection(thing) {
  return thing === "asc" || thing === "desc";
}
function parseOrderBy(args) {
  if (args.length === 2) {
    return [parseOrderByItem(args[0], args[1])];
  }
  if (args.length === 1) {
    const [orderBy] = args;
    if (Array.isArray(orderBy)) {
      return orderBy.map((item) => parseOrderByItem(item));
    }
    return [parseOrderByItem(orderBy)];
  }
  throw new Error(`Invalid number of arguments at order by! expected 1-2, received ${args.length}`);
}
function parseOrderByItem(ref, direction) {
  const parsedRef = parseOrderByExpression(ref);
  if (OrderByItemNode.is(parsedRef)) {
    if (direction) {
      throw new Error("Cannot specify direction twice!");
    }
    return parsedRef;
  }
  return OrderByItemNode.create(parsedRef, parseOrderByDirectionExpression(direction));
}
function parseOrderByExpression(expr) {
  if (isExpressionOrFactory(expr)) {
    return parseExpression(expr);
  }
  if (isDynamicReferenceBuilder(expr)) {
    return expr.toOperationNode();
  }
  const [ref, direction] = expr.split(" ");
  if (direction) {
    if (!isOrderByDirection(direction)) {
      throw new Error(`Invalid order by direction: ${direction}`);
    }
    return OrderByItemNode.create(parseStringReference(ref), parseOrderByDirectionExpression(direction));
  }
  return parseStringReference(expr);
}
function parseOrderByDirectionExpression(expr) {
  if (!expr) {
    return void 0;
  }
  if (expr === "asc" || expr === "desc") {
    return RawNode.createWithSql(expr);
  }
  return expr.toOperationNode();
}
var init_order_by_parser = __esm({
  "node_modules/kysely/dist/esm/parser/order-by-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_dynamic_reference_builder();
    init_order_by_item_node();
    init_raw_node();
    init_expression_parser();
    init_reference_parser();
    __name(isOrderByDirection, "isOrderByDirection");
    __name(parseOrderBy, "parseOrderBy");
    __name(parseOrderByItem, "parseOrderByItem");
    __name(parseOrderByExpression, "parseOrderByExpression");
    __name(parseOrderByDirectionExpression, "parseOrderByDirectionExpression");
  }
});

// node_modules/kysely/dist/esm/operation-node/json-reference-node.js
var JSONReferenceNode;
var init_json_reference_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/json-reference-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    JSONReferenceNode = freeze({
      is(node) {
        return node.kind === "JSONReferenceNode";
      },
      create(reference, traversal) {
        return freeze({
          kind: "JSONReferenceNode",
          reference,
          traversal
        });
      },
      cloneWithTraversal(node, traversal) {
        return freeze({
          ...node,
          traversal
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/json-operator-chain-node.js
var JSONOperatorChainNode;
var init_json_operator_chain_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/json-operator-chain-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    JSONOperatorChainNode = freeze({
      is(node) {
        return node.kind === "JSONOperatorChainNode";
      },
      create(operator) {
        return freeze({
          kind: "JSONOperatorChainNode",
          operator,
          values: freeze([])
        });
      },
      cloneWithValue(node, value) {
        return freeze({
          ...node,
          values: freeze([...node.values, value])
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/json-path-node.js
var JSONPathNode;
var init_json_path_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/json-path-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    JSONPathNode = freeze({
      is(node) {
        return node.kind === "JSONPathNode";
      },
      create(inOperator) {
        return freeze({
          kind: "JSONPathNode",
          inOperator,
          pathLegs: freeze([])
        });
      },
      cloneWithLeg(jsonPathNode, pathLeg) {
        return freeze({
          ...jsonPathNode,
          pathLegs: freeze([...jsonPathNode.pathLegs, pathLeg])
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/parser/reference-parser.js
function parseSimpleReferenceExpression(exp) {
  if (isString(exp)) {
    return parseStringReference(exp);
  }
  return exp.toOperationNode();
}
function parseReferenceExpressionOrList(arg) {
  if (isReadonlyArray(arg)) {
    return arg.map((it) => parseReferenceExpression(it));
  } else {
    return [parseReferenceExpression(arg)];
  }
}
function parseReferenceExpression(exp) {
  if (isExpressionOrFactory(exp)) {
    return parseExpression(exp);
  }
  return parseSimpleReferenceExpression(exp);
}
function parseJSONReference(ref, op) {
  const referenceNode = parseStringReference(ref);
  if (isJSONOperator(op)) {
    return JSONReferenceNode.create(referenceNode, JSONOperatorChainNode.create(OperatorNode.create(op)));
  }
  const opWithoutLastChar = op.slice(0, -1);
  if (isJSONOperator(opWithoutLastChar)) {
    return JSONReferenceNode.create(referenceNode, JSONPathNode.create(OperatorNode.create(opWithoutLastChar)));
  }
  throw new Error(`Invalid JSON operator: ${op}`);
}
function parseStringReference(ref) {
  const COLUMN_SEPARATOR = ".";
  if (!ref.includes(COLUMN_SEPARATOR)) {
    return ReferenceNode.create(ColumnNode.create(ref));
  }
  const parts = ref.split(COLUMN_SEPARATOR).map(trim);
  if (parts.length === 3) {
    return parseStringReferenceWithTableAndSchema(parts);
  }
  if (parts.length === 2) {
    return parseStringReferenceWithTable(parts);
  }
  throw new Error(`invalid column reference ${ref}`);
}
function parseAliasedStringReference(ref) {
  const ALIAS_SEPARATOR = " as ";
  if (ref.includes(ALIAS_SEPARATOR)) {
    const [columnRef, alias] = ref.split(ALIAS_SEPARATOR).map(trim);
    return AliasNode.create(parseStringReference(columnRef), IdentifierNode.create(alias));
  } else {
    return parseStringReference(ref);
  }
}
function parseColumnName(column) {
  return ColumnNode.create(column);
}
function parseOrderedColumnName(column) {
  const ORDER_SEPARATOR = " ";
  if (column.includes(ORDER_SEPARATOR)) {
    const [columnName, order] = column.split(ORDER_SEPARATOR).map(trim);
    if (!isOrderByDirection(order)) {
      throw new Error(`invalid order direction "${order}" next to "${columnName}"`);
    }
    return parseOrderBy([columnName, order])[0];
  } else {
    return parseColumnName(column);
  }
}
function parseStringReferenceWithTableAndSchema(parts) {
  const [schema, table, column] = parts;
  return ReferenceNode.create(ColumnNode.create(column), TableNode.createWithSchema(schema, table));
}
function parseStringReferenceWithTable(parts) {
  const [table, column] = parts;
  return ReferenceNode.create(ColumnNode.create(column), TableNode.create(table));
}
function trim(str) {
  return str.trim();
}
var init_reference_parser = __esm({
  "node_modules/kysely/dist/esm/parser/reference-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_alias_node();
    init_column_node();
    init_reference_node();
    init_table_node();
    init_object_utils();
    init_expression_parser();
    init_identifier_node();
    init_order_by_parser();
    init_operator_node();
    init_json_reference_node();
    init_json_operator_chain_node();
    init_json_path_node();
    __name(parseSimpleReferenceExpression, "parseSimpleReferenceExpression");
    __name(parseReferenceExpressionOrList, "parseReferenceExpressionOrList");
    __name(parseReferenceExpression, "parseReferenceExpression");
    __name(parseJSONReference, "parseJSONReference");
    __name(parseStringReference, "parseStringReference");
    __name(parseAliasedStringReference, "parseAliasedStringReference");
    __name(parseColumnName, "parseColumnName");
    __name(parseOrderedColumnName, "parseOrderedColumnName");
    __name(parseStringReferenceWithTableAndSchema, "parseStringReferenceWithTableAndSchema");
    __name(parseStringReferenceWithTable, "parseStringReferenceWithTable");
    __name(trim, "trim");
  }
});

// node_modules/kysely/dist/esm/operation-node/primitive-value-list-node.js
var PrimitiveValueListNode;
var init_primitive_value_list_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/primitive-value-list-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    PrimitiveValueListNode = freeze({
      is(node) {
        return node.kind === "PrimitiveValueListNode";
      },
      create(values) {
        return freeze({
          kind: "PrimitiveValueListNode",
          values: freeze([...values])
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/value-list-node.js
var ValueListNode;
var init_value_list_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/value-list-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    ValueListNode = freeze({
      is(node) {
        return node.kind === "ValueListNode";
      },
      create(values) {
        return freeze({
          kind: "ValueListNode",
          values: freeze(values)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/value-node.js
var ValueNode;
var init_value_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/value-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    ValueNode = freeze({
      is(node) {
        return node.kind === "ValueNode";
      },
      create(value) {
        return freeze({
          kind: "ValueNode",
          value
        });
      },
      createImmediate(value) {
        return freeze({
          kind: "ValueNode",
          value,
          immediate: true
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/parser/value-parser.js
function parseValueExpressionOrList(arg) {
  if (isReadonlyArray(arg)) {
    return parseValueExpressionList(arg);
  }
  return parseValueExpression(arg);
}
function parseValueExpression(exp) {
  if (isExpressionOrFactory(exp)) {
    return parseExpression(exp);
  }
  return ValueNode.create(exp);
}
function isSafeImmediateValue(value) {
  return isNumber(value) || isBoolean(value) || isNull(value);
}
function parseSafeImmediateValue(value) {
  if (!isSafeImmediateValue(value)) {
    throw new Error(`unsafe immediate value ${JSON.stringify(value)}`);
  }
  return ValueNode.createImmediate(value);
}
function parseValueExpressionList(arg) {
  if (arg.some(isExpressionOrFactory)) {
    return ValueListNode.create(arg.map((it) => parseValueExpression(it)));
  }
  return PrimitiveValueListNode.create(arg);
}
var init_value_parser = __esm({
  "node_modules/kysely/dist/esm/parser/value-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_primitive_value_list_node();
    init_value_list_node();
    init_value_node();
    init_object_utils();
    init_expression_parser();
    __name(parseValueExpressionOrList, "parseValueExpressionOrList");
    __name(parseValueExpression, "parseValueExpression");
    __name(isSafeImmediateValue, "isSafeImmediateValue");
    __name(parseSafeImmediateValue, "parseSafeImmediateValue");
    __name(parseValueExpressionList, "parseValueExpressionList");
  }
});

// node_modules/kysely/dist/esm/operation-node/parens-node.js
var ParensNode;
var init_parens_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/parens-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    ParensNode = freeze({
      is(node) {
        return node.kind === "ParensNode";
      },
      create(node) {
        return freeze({
          kind: "ParensNode",
          node
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/parser/binary-operation-parser.js
function parseValueBinaryOperationOrExpression(args) {
  if (args.length === 3) {
    return parseValueBinaryOperation(args[0], args[1], args[2]);
  } else if (args.length === 1) {
    return parseValueExpression(args[0]);
  }
  throw new Error(`invalid arguments: ${JSON.stringify(args)}`);
}
function parseValueBinaryOperation(left, operator, right) {
  if (isIsOperator(operator) && needsIsOperator(right)) {
    return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), ValueNode.createImmediate(right));
  }
  return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseValueExpressionOrList(right));
}
function parseReferentialBinaryOperation(left, operator, right) {
  return BinaryOperationNode.create(parseReferenceExpression(left), parseOperator(operator), parseReferenceExpression(right));
}
function parseFilterObject(obj, combinator) {
  return parseFilterList(Object.entries(obj).filter(([, v]) => !isUndefined(v)).map(([k, v]) => parseValueBinaryOperation(k, needsIsOperator(v) ? "is" : "=", v)), combinator);
}
function parseFilterList(list, combinator, withParens = true) {
  const combine = combinator === "and" ? AndNode.create : OrNode.create;
  if (list.length === 0) {
    return BinaryOperationNode.create(ValueNode.createImmediate(1), OperatorNode.create("="), ValueNode.createImmediate(combinator === "and" ? 1 : 0));
  }
  let node = toOperationNode(list[0]);
  for (let i = 1; i < list.length; ++i) {
    node = combine(node, toOperationNode(list[i]));
  }
  if (list.length > 1 && withParens) {
    return ParensNode.create(node);
  }
  return node;
}
function isIsOperator(operator) {
  return operator === "is" || operator === "is not";
}
function needsIsOperator(value) {
  return isNull(value) || isBoolean(value);
}
function parseOperator(operator) {
  if (isString(operator) && OPERATORS.includes(operator)) {
    return OperatorNode.create(operator);
  }
  if (isOperationNodeSource(operator)) {
    return operator.toOperationNode();
  }
  throw new Error(`invalid operator ${JSON.stringify(operator)}`);
}
function toOperationNode(nodeOrSource) {
  return isOperationNodeSource(nodeOrSource) ? nodeOrSource.toOperationNode() : nodeOrSource;
}
var init_binary_operation_parser = __esm({
  "node_modules/kysely/dist/esm/parser/binary-operation-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_binary_operation_node();
    init_object_utils();
    init_operation_node_source();
    init_operator_node();
    init_reference_parser();
    init_value_parser();
    init_value_node();
    init_and_node();
    init_parens_node();
    init_or_node();
    __name(parseValueBinaryOperationOrExpression, "parseValueBinaryOperationOrExpression");
    __name(parseValueBinaryOperation, "parseValueBinaryOperation");
    __name(parseReferentialBinaryOperation, "parseReferentialBinaryOperation");
    __name(parseFilterObject, "parseFilterObject");
    __name(parseFilterList, "parseFilterList");
    __name(isIsOperator, "isIsOperator");
    __name(needsIsOperator, "needsIsOperator");
    __name(parseOperator, "parseOperator");
    __name(toOperationNode, "toOperationNode");
  }
});

// node_modules/kysely/dist/esm/operation-node/order-by-node.js
var OrderByNode;
var init_order_by_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/order-by-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    OrderByNode = freeze({
      is(node) {
        return node.kind === "OrderByNode";
      },
      create(items) {
        return freeze({
          kind: "OrderByNode",
          items: freeze([...items])
        });
      },
      cloneWithItems(orderBy, items) {
        return freeze({
          ...orderBy,
          items: freeze([...orderBy.items, ...items])
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/partition-by-node.js
var PartitionByNode;
var init_partition_by_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/partition-by-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    PartitionByNode = freeze({
      is(node) {
        return node.kind === "PartitionByNode";
      },
      create(items) {
        return freeze({
          kind: "PartitionByNode",
          items: freeze(items)
        });
      },
      cloneWithItems(partitionBy, items) {
        return freeze({
          ...partitionBy,
          items: freeze([...partitionBy.items, ...items])
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/over-node.js
var OverNode;
var init_over_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/over-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_order_by_node();
    init_partition_by_node();
    OverNode = freeze({
      is(node) {
        return node.kind === "OverNode";
      },
      create() {
        return freeze({
          kind: "OverNode"
        });
      },
      cloneWithOrderByItems(overNode, items) {
        return freeze({
          ...overNode,
          orderBy: overNode.orderBy ? OrderByNode.cloneWithItems(overNode.orderBy, items) : OrderByNode.create(items)
        });
      },
      cloneWithPartitionByItems(overNode, items) {
        return freeze({
          ...overNode,
          partitionBy: overNode.partitionBy ? PartitionByNode.cloneWithItems(overNode.partitionBy, items) : PartitionByNode.create(items)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/from-node.js
var FromNode;
var init_from_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/from-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    FromNode = freeze({
      is(node) {
        return node.kind === "FromNode";
      },
      create(froms) {
        return freeze({
          kind: "FromNode",
          froms: freeze(froms)
        });
      },
      cloneWithFroms(from, froms) {
        return freeze({
          ...from,
          froms: freeze([...from.froms, ...froms])
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/group-by-node.js
var GroupByNode;
var init_group_by_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/group-by-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    GroupByNode = freeze({
      is(node) {
        return node.kind === "GroupByNode";
      },
      create(items) {
        return freeze({
          kind: "GroupByNode",
          items: freeze(items)
        });
      },
      cloneWithItems(groupBy, items) {
        return freeze({
          ...groupBy,
          items: freeze([...groupBy.items, ...items])
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/having-node.js
var HavingNode;
var init_having_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/having-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_and_node();
    init_or_node();
    HavingNode = freeze({
      is(node) {
        return node.kind === "HavingNode";
      },
      create(filter) {
        return freeze({
          kind: "HavingNode",
          having: filter
        });
      },
      cloneWithOperation(havingNode, operator, operation) {
        return freeze({
          ...havingNode,
          having: operator === "And" ? AndNode.create(havingNode.having, operation) : OrNode.create(havingNode.having, operation)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/select-query-node.js
var SelectQueryNode;
var init_select_query_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/select-query-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_from_node();
    init_group_by_node();
    init_having_node();
    init_order_by_node();
    SelectQueryNode = freeze({
      is(node) {
        return node.kind === "SelectQueryNode";
      },
      create(withNode) {
        return freeze({
          kind: "SelectQueryNode",
          ...withNode && { with: withNode }
        });
      },
      createFrom(fromItems, withNode) {
        return freeze({
          kind: "SelectQueryNode",
          from: FromNode.create(fromItems),
          ...withNode && { with: withNode }
        });
      },
      cloneWithSelections(select, selections) {
        return freeze({
          ...select,
          selections: select.selections ? freeze([...select.selections, ...selections]) : freeze(selections)
        });
      },
      cloneWithDistinctOn(select, expressions) {
        return freeze({
          ...select,
          distinctOn: select.distinctOn ? freeze([...select.distinctOn, ...expressions]) : freeze(expressions)
        });
      },
      cloneWithFrontModifier(select, modifier) {
        return freeze({
          ...select,
          frontModifiers: select.frontModifiers ? freeze([...select.frontModifiers, modifier]) : freeze([modifier])
        });
      },
      cloneWithOrderByItems(selectNode, items) {
        return freeze({
          ...selectNode,
          orderBy: selectNode.orderBy ? OrderByNode.cloneWithItems(selectNode.orderBy, items) : OrderByNode.create(items)
        });
      },
      cloneWithGroupByItems(selectNode, items) {
        return freeze({
          ...selectNode,
          groupBy: selectNode.groupBy ? GroupByNode.cloneWithItems(selectNode.groupBy, items) : GroupByNode.create(items)
        });
      },
      cloneWithLimit(selectNode, limit) {
        return freeze({
          ...selectNode,
          limit
        });
      },
      cloneWithOffset(selectNode, offset) {
        return freeze({
          ...selectNode,
          offset
        });
      },
      cloneWithFetch(selectNode, fetch3) {
        return freeze({
          ...selectNode,
          fetch: fetch3
        });
      },
      cloneWithHaving(selectNode, operation) {
        return freeze({
          ...selectNode,
          having: selectNode.having ? HavingNode.cloneWithOperation(selectNode.having, "And", operation) : HavingNode.create(operation)
        });
      },
      cloneWithSetOperations(selectNode, setOperations) {
        return freeze({
          ...selectNode,
          setOperations: selectNode.setOperations ? freeze([...selectNode.setOperations, ...setOperations]) : freeze([...setOperations])
        });
      },
      cloneWithoutSelections(select) {
        return freeze({
          ...select,
          selections: []
        });
      },
      cloneWithoutLimit(select) {
        return freeze({
          ...select,
          limit: void 0
        });
      },
      cloneWithoutOffset(select) {
        return freeze({
          ...select,
          offset: void 0
        });
      },
      cloneWithoutOrderBy(select) {
        return freeze({
          ...select,
          orderBy: void 0
        });
      },
      cloneWithoutGroupBy(select) {
        return freeze({
          ...select,
          groupBy: void 0
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/util/prevent-await.js
function preventAwait(clazz, message) {
  Object.defineProperties(clazz.prototype, {
    then: {
      enumerable: false,
      value: /* @__PURE__ */ __name(() => {
        throw new Error(message);
      }, "value")
    }
  });
}
var init_prevent_await = __esm({
  "node_modules/kysely/dist/esm/util/prevent-await.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    __name(preventAwait, "preventAwait");
  }
});

// node_modules/kysely/dist/esm/query-builder/join-builder.js
var JoinBuilder;
var init_join_builder = __esm({
  "node_modules/kysely/dist/esm/query-builder/join-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_join_node();
    init_raw_node();
    init_binary_operation_parser();
    init_object_utils();
    init_prevent_await();
    JoinBuilder = class _JoinBuilder {
      static {
        __name(this, "JoinBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      on(...args) {
        return new _JoinBuilder({
          ...this.#props,
          joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseValueBinaryOperationOrExpression(args))
        });
      }
      /**
       * Just like {@link WhereInterface.whereRef} but adds an item to the join's
       * `on` clause instead.
       *
       * See {@link WhereInterface.whereRef} for documentation and examples.
       */
      onRef(lhs, op, rhs) {
        return new _JoinBuilder({
          ...this.#props,
          joinNode: JoinNode.cloneWithOn(this.#props.joinNode, parseReferentialBinaryOperation(lhs, op, rhs))
        });
      }
      /**
       * Adds `on true`.
       */
      onTrue() {
        return new _JoinBuilder({
          ...this.#props,
          joinNode: JoinNode.cloneWithOn(this.#props.joinNode, RawNode.createWithSql("true"))
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#props.joinNode;
      }
    };
    preventAwait(JoinBuilder, "don't await JoinBuilder instances. They are never executed directly and are always just a part of a query.");
  }
});

// node_modules/kysely/dist/esm/operation-node/partition-by-item-node.js
var PartitionByItemNode;
var init_partition_by_item_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/partition-by-item-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    PartitionByItemNode = freeze({
      is(node) {
        return node.kind === "PartitionByItemNode";
      },
      create(partitionBy) {
        return freeze({
          kind: "PartitionByItemNode",
          partitionBy
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/parser/partition-by-parser.js
function parsePartitionBy(partitionBy) {
  return parseReferenceExpressionOrList(partitionBy).map(PartitionByItemNode.create);
}
var init_partition_by_parser = __esm({
  "node_modules/kysely/dist/esm/parser/partition-by-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_partition_by_item_node();
    init_reference_parser();
    __name(parsePartitionBy, "parsePartitionBy");
  }
});

// node_modules/kysely/dist/esm/query-builder/over-builder.js
var OverBuilder;
var init_over_builder = __esm({
  "node_modules/kysely/dist/esm/query-builder/over-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_over_node();
    init_order_by_parser();
    init_partition_by_parser();
    init_object_utils();
    init_prevent_await();
    OverBuilder = class _OverBuilder {
      static {
        __name(this, "OverBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      /**
       * Adds an order by clause item inside the over function.
       *
       * ```ts
       * const result = await db
       *   .selectFrom('person')
       *   .select(
       *     (eb) => eb.fn.avg<number>('age').over(
       *       ob => ob.orderBy('first_name', 'asc').orderBy('last_name', 'asc')
       *     ).as('average_age')
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * select avg("age") over(order by "first_name" asc, "last_name" asc) as "average_age"
       * from "person"
       * ```
       */
      orderBy(orderBy, direction) {
        return new _OverBuilder({
          overNode: OverNode.cloneWithOrderByItems(this.#props.overNode, parseOrderBy([orderBy, direction]))
        });
      }
      partitionBy(partitionBy) {
        return new _OverBuilder({
          overNode: OverNode.cloneWithPartitionByItems(this.#props.overNode, parsePartitionBy(partitionBy))
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#props.overNode;
      }
    };
    preventAwait(OverBuilder, "don't await OverBuilder instances. They are never executed directly and are always just a part of a query.");
  }
});

// node_modules/kysely/dist/esm/operation-node/selection-node.js
var SelectionNode;
var init_selection_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/selection-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_reference_node();
    init_select_all_node();
    SelectionNode = freeze({
      is(node) {
        return node.kind === "SelectionNode";
      },
      create(selection) {
        return freeze({
          kind: "SelectionNode",
          selection
        });
      },
      createSelectAll() {
        return freeze({
          kind: "SelectionNode",
          selection: SelectAllNode.create()
        });
      },
      createSelectAllFromTable(table) {
        return freeze({
          kind: "SelectionNode",
          selection: ReferenceNode.createSelectAll(table)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/parser/select-parser.js
function parseSelectArg(selection) {
  if (isFunction(selection)) {
    return parseSelectArg(selection(expressionBuilder()));
  } else if (isReadonlyArray(selection)) {
    return selection.map((it) => parseSelectExpression(it));
  } else {
    return [parseSelectExpression(selection)];
  }
}
function parseSelectExpression(selection) {
  if (isString(selection)) {
    return SelectionNode.create(parseAliasedStringReference(selection));
  } else if (isDynamicReferenceBuilder(selection)) {
    return SelectionNode.create(selection.toOperationNode());
  } else {
    return SelectionNode.create(parseAliasedExpression(selection));
  }
}
function parseSelectAll(table) {
  if (!table) {
    return [SelectionNode.createSelectAll()];
  } else if (Array.isArray(table)) {
    return table.map(parseSelectAllArg);
  } else {
    return [parseSelectAllArg(table)];
  }
}
function parseSelectAllArg(table) {
  if (isString(table)) {
    return SelectionNode.createSelectAllFromTable(parseTable(table));
  }
  throw new Error(`invalid value selectAll expression: ${JSON.stringify(table)}`);
}
var init_select_parser = __esm({
  "node_modules/kysely/dist/esm/parser/select-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_selection_node();
    init_reference_parser();
    init_dynamic_reference_builder();
    init_expression_parser();
    init_table_parser();
    init_expression_builder();
    __name(parseSelectArg, "parseSelectArg");
    __name(parseSelectExpression, "parseSelectExpression");
    __name(parseSelectAll, "parseSelectAll");
    __name(parseSelectAllArg, "parseSelectAllArg");
  }
});

// node_modules/kysely/dist/esm/operation-node/values-node.js
var ValuesNode;
var init_values_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/values-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    ValuesNode = freeze({
      is(node) {
        return node.kind === "ValuesNode";
      },
      create(values) {
        return freeze({
          kind: "ValuesNode",
          values: freeze(values)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/default-insert-value-node.js
var DefaultInsertValueNode;
var init_default_insert_value_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/default-insert-value-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    DefaultInsertValueNode = freeze({
      is(node) {
        return node.kind === "DefaultInsertValueNode";
      },
      create() {
        return freeze({
          kind: "DefaultInsertValueNode"
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/parser/insert-values-parser.js
function parseInsertExpression(arg) {
  const objectOrList = isFunction(arg) ? arg(expressionBuilder()) : arg;
  const list = isReadonlyArray(objectOrList) ? objectOrList : freeze([objectOrList]);
  return parseInsertColumnsAndValues(list);
}
function parseInsertColumnsAndValues(rows) {
  const columns = parseColumnNamesAndIndexes(rows);
  return [
    freeze([...columns.keys()].map(ColumnNode.create)),
    ValuesNode.create(rows.map((row) => parseRowValues(row, columns)))
  ];
}
function parseColumnNamesAndIndexes(rows) {
  const columns = /* @__PURE__ */ new Map();
  for (const row of rows) {
    const cols = Object.keys(row);
    for (const col of cols) {
      if (!columns.has(col) && row[col] !== void 0) {
        columns.set(col, columns.size);
      }
    }
  }
  return columns;
}
function parseRowValues(row, columns) {
  const rowColumns = Object.keys(row);
  const rowValues = Array.from({
    length: columns.size
  });
  let hasUndefinedOrComplexColumns = false;
  let indexedRowColumns = rowColumns.length;
  for (const col of rowColumns) {
    const columnIdx = columns.get(col);
    if (isUndefined(columnIdx)) {
      indexedRowColumns--;
      continue;
    }
    const value = row[col];
    if (isUndefined(value) || isExpressionOrFactory(value)) {
      hasUndefinedOrComplexColumns = true;
    }
    rowValues[columnIdx] = value;
  }
  const hasMissingColumns = indexedRowColumns < columns.size;
  if (hasMissingColumns || hasUndefinedOrComplexColumns) {
    const defaultValue = DefaultInsertValueNode.create();
    return ValueListNode.create(rowValues.map((it) => isUndefined(it) ? defaultValue : parseValueExpression(it)));
  }
  return PrimitiveValueListNode.create(rowValues);
}
var init_insert_values_parser = __esm({
  "node_modules/kysely/dist/esm/parser/insert-values-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_column_node();
    init_primitive_value_list_node();
    init_value_list_node();
    init_object_utils();
    init_value_parser();
    init_values_node();
    init_expression_parser();
    init_default_insert_value_node();
    init_expression_builder();
    __name(parseInsertExpression, "parseInsertExpression");
    __name(parseInsertColumnsAndValues, "parseInsertColumnsAndValues");
    __name(parseColumnNamesAndIndexes, "parseColumnNamesAndIndexes");
    __name(parseRowValues, "parseRowValues");
  }
});

// node_modules/kysely/dist/esm/operation-node/insert-query-node.js
var InsertQueryNode;
var init_insert_query_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/insert-query-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    InsertQueryNode = freeze({
      is(node) {
        return node.kind === "InsertQueryNode";
      },
      create(into, withNode, replace) {
        return freeze({
          kind: "InsertQueryNode",
          into,
          ...withNode && { with: withNode },
          replace
        });
      },
      createWithoutInto() {
        return freeze({
          kind: "InsertQueryNode"
        });
      },
      cloneWith(insertQuery, props) {
        return freeze({
          ...insertQuery,
          ...props
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/update-query-node.js
var UpdateQueryNode;
var init_update_query_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/update-query-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_from_node();
    UpdateQueryNode = freeze({
      is(node) {
        return node.kind === "UpdateQueryNode";
      },
      create(table, withNode) {
        return freeze({
          kind: "UpdateQueryNode",
          table,
          ...withNode && { with: withNode }
        });
      },
      createWithoutTable() {
        return freeze({
          kind: "UpdateQueryNode"
        });
      },
      cloneWithFromItems(updateQuery, fromItems) {
        return freeze({
          ...updateQuery,
          from: updateQuery.from ? FromNode.cloneWithFroms(updateQuery.from, fromItems) : FromNode.create(fromItems)
        });
      },
      cloneWithUpdates(updateQuery, updates) {
        return freeze({
          ...updateQuery,
          updates: updateQuery.updates ? freeze([...updateQuery.updates, ...updates]) : updates
        });
      },
      cloneWithLimit(updateQuery, limit) {
        return freeze({
          ...updateQuery,
          limit
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/using-node.js
var UsingNode;
var init_using_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/using-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    UsingNode = freeze({
      is(node) {
        return node.kind === "UsingNode";
      },
      create(tables) {
        return freeze({
          kind: "UsingNode",
          tables: freeze(tables)
        });
      },
      cloneWithTables(using, tables) {
        return freeze({
          ...using,
          tables: freeze([...using.tables, ...tables])
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/delete-query-node.js
var DeleteQueryNode;
var init_delete_query_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/delete-query-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_from_node();
    init_order_by_node();
    init_using_node();
    DeleteQueryNode = freeze({
      is(node) {
        return node.kind === "DeleteQueryNode";
      },
      create(fromItems, withNode) {
        return freeze({
          kind: "DeleteQueryNode",
          from: FromNode.create(fromItems),
          ...withNode && { with: withNode }
        });
      },
      cloneWithOrderByItems(deleteNode, items) {
        return freeze({
          ...deleteNode,
          orderBy: deleteNode.orderBy ? OrderByNode.cloneWithItems(deleteNode.orderBy, items) : OrderByNode.create(items)
        });
      },
      cloneWithoutOrderBy(deleteNode) {
        return freeze({
          ...deleteNode,
          orderBy: void 0
        });
      },
      cloneWithLimit(deleteNode, limit) {
        return freeze({
          ...deleteNode,
          limit
        });
      },
      cloneWithoutLimit(deleteNode) {
        return freeze({
          ...deleteNode,
          limit: void 0
        });
      },
      cloneWithUsing(deleteNode, tables) {
        return freeze({
          ...deleteNode,
          using: deleteNode.using !== void 0 ? UsingNode.cloneWithTables(deleteNode.using, tables) : UsingNode.create(tables)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/where-node.js
var WhereNode;
var init_where_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/where-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_and_node();
    init_or_node();
    WhereNode = freeze({
      is(node) {
        return node.kind === "WhereNode";
      },
      create(filter) {
        return freeze({
          kind: "WhereNode",
          where: filter
        });
      },
      cloneWithOperation(whereNode, operator, operation) {
        return freeze({
          ...whereNode,
          where: operator === "And" ? AndNode.create(whereNode.where, operation) : OrNode.create(whereNode.where, operation)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/returning-node.js
var ReturningNode;
var init_returning_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/returning-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    ReturningNode = freeze({
      is(node) {
        return node.kind === "ReturningNode";
      },
      create(selections) {
        return freeze({
          kind: "ReturningNode",
          selections: freeze(selections)
        });
      },
      cloneWithSelections(returning, selections) {
        return freeze({
          ...returning,
          selections: returning.selections ? freeze([...returning.selections, ...selections]) : freeze(selections)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/explain-node.js
var ExplainNode;
var init_explain_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/explain-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    ExplainNode = freeze({
      is(node) {
        return node.kind === "ExplainNode";
      },
      create(format, options) {
        return freeze({
          kind: "ExplainNode",
          format,
          options
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/when-node.js
var WhenNode;
var init_when_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/when-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    WhenNode = freeze({
      is(node) {
        return node.kind === "WhenNode";
      },
      create(condition) {
        return freeze({
          kind: "WhenNode",
          condition
        });
      },
      cloneWithResult(whenNode, result) {
        return freeze({
          ...whenNode,
          result
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/merge-query-node.js
var MergeQueryNode;
var init_merge_query_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/merge-query-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_when_node();
    MergeQueryNode = freeze({
      is(node) {
        return node.kind === "MergeQueryNode";
      },
      create(into, withNode) {
        return freeze({
          kind: "MergeQueryNode",
          into,
          ...withNode && { with: withNode }
        });
      },
      cloneWithUsing(mergeNode, using) {
        return freeze({
          ...mergeNode,
          using
        });
      },
      cloneWithWhen(mergeNode, when) {
        return freeze({
          ...mergeNode,
          whens: mergeNode.whens ? freeze([...mergeNode.whens, when]) : freeze([when])
        });
      },
      cloneWithThen(mergeNode, then) {
        return freeze({
          ...mergeNode,
          whens: mergeNode.whens ? freeze([
            ...mergeNode.whens.slice(0, -1),
            WhenNode.cloneWithResult(mergeNode.whens[mergeNode.whens.length - 1], then)
          ]) : void 0
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/output-node.js
var OutputNode;
var init_output_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/output-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    OutputNode = freeze({
      is(node) {
        return node.kind === "OutputNode";
      },
      create(selections) {
        return freeze({
          kind: "OutputNode",
          selections: freeze(selections)
        });
      },
      cloneWithSelections(output, selections) {
        return freeze({
          ...output,
          selections: output.selections ? freeze([...output.selections, ...selections]) : freeze(selections)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/query-node.js
var QueryNode;
var init_query_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/query-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_insert_query_node();
    init_select_query_node();
    init_update_query_node();
    init_delete_query_node();
    init_where_node();
    init_object_utils();
    init_returning_node();
    init_explain_node();
    init_merge_query_node();
    init_output_node();
    QueryNode = freeze({
      is(node) {
        return SelectQueryNode.is(node) || InsertQueryNode.is(node) || UpdateQueryNode.is(node) || DeleteQueryNode.is(node) || MergeQueryNode.is(node);
      },
      cloneWithEndModifier(node, modifier) {
        return freeze({
          ...node,
          endModifiers: node.endModifiers ? freeze([...node.endModifiers, modifier]) : freeze([modifier])
        });
      },
      cloneWithWhere(node, operation) {
        return freeze({
          ...node,
          where: node.where ? WhereNode.cloneWithOperation(node.where, "And", operation) : WhereNode.create(operation)
        });
      },
      cloneWithJoin(node, join) {
        return freeze({
          ...node,
          joins: node.joins ? freeze([...node.joins, join]) : freeze([join])
        });
      },
      cloneWithReturning(node, selections) {
        return freeze({
          ...node,
          returning: node.returning ? ReturningNode.cloneWithSelections(node.returning, selections) : ReturningNode.create(selections)
        });
      },
      cloneWithoutReturning(node) {
        return freeze({
          ...node,
          returning: void 0
        });
      },
      cloneWithoutWhere(node) {
        return freeze({
          ...node,
          where: void 0
        });
      },
      cloneWithExplain(node, format, options) {
        return freeze({
          ...node,
          explain: ExplainNode.create(format, options?.toOperationNode())
        });
      },
      cloneWithTop(node, top) {
        return freeze({
          ...node,
          top
        });
      },
      cloneWithOutput(node, selections) {
        return freeze({
          ...node,
          output: node.output ? OutputNode.cloneWithSelections(node.output, selections) : OutputNode.create(selections)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/column-update-node.js
var ColumnUpdateNode;
var init_column_update_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/column-update-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    ColumnUpdateNode = freeze({
      is(node) {
        return node.kind === "ColumnUpdateNode";
      },
      create(column, value) {
        return freeze({
          kind: "ColumnUpdateNode",
          column,
          value
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/parser/update-set-parser.js
function parseUpdate(...args) {
  if (args.length === 2) {
    return [
      ColumnUpdateNode.create(parseReferenceExpression(args[0]), parseValueExpression(args[1]))
    ];
  }
  return parseUpdateObjectExpression(args[0]);
}
function parseUpdateObjectExpression(update) {
  const updateObj = isFunction(update) ? update(expressionBuilder()) : update;
  return Object.entries(updateObj).filter(([_, value]) => value !== void 0).map(([key, value]) => {
    return ColumnUpdateNode.create(ColumnNode.create(key), parseValueExpression(value));
  });
}
var init_update_set_parser = __esm({
  "node_modules/kysely/dist/esm/parser/update-set-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_column_node();
    init_column_update_node();
    init_expression_builder();
    init_object_utils();
    init_value_parser();
    init_reference_parser();
    __name(parseUpdate, "parseUpdate");
    __name(parseUpdateObjectExpression, "parseUpdateObjectExpression");
  }
});

// node_modules/kysely/dist/esm/operation-node/on-duplicate-key-node.js
var OnDuplicateKeyNode;
var init_on_duplicate_key_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/on-duplicate-key-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    OnDuplicateKeyNode = freeze({
      is(node) {
        return node.kind === "OnDuplicateKeyNode";
      },
      create(updates) {
        return freeze({
          kind: "OnDuplicateKeyNode",
          updates
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/query-builder/insert-result.js
var InsertResult;
var init_insert_result = __esm({
  "node_modules/kysely/dist/esm/query-builder/insert-result.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    InsertResult = class {
      static {
        __name(this, "InsertResult");
      }
      /**
       * The auto incrementing primary key of the inserted row.
       *
       * This property can be undefined when the query contains an `on conflict`
       * clause that makes the query succeed even when nothing gets inserted.
       *
       * This property is always undefined on dialects like PostgreSQL that
       * don't return the inserted id by default. On those dialects you need
       * to use the {@link ReturningInterface.returning | returning} method.
       */
      insertId;
      /**
       * Affected rows count.
       */
      numInsertedOrUpdatedRows;
      constructor(insertId, numInsertedOrUpdatedRows) {
        this.insertId = insertId;
        this.numInsertedOrUpdatedRows = numInsertedOrUpdatedRows;
      }
    };
  }
});

// node_modules/kysely/dist/esm/query-builder/no-result-error.js
function isNoResultErrorConstructor(fn) {
  return Object.prototype.hasOwnProperty.call(fn, "prototype");
}
var NoResultError;
var init_no_result_error = __esm({
  "node_modules/kysely/dist/esm/query-builder/no-result-error.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    NoResultError = class extends Error {
      static {
        __name(this, "NoResultError");
      }
      /**
       * The operation node tree of the query that was executed.
       */
      node;
      constructor(node) {
        super("no result");
        this.node = node;
      }
    };
    __name(isNoResultErrorConstructor, "isNoResultErrorConstructor");
  }
});

// node_modules/kysely/dist/esm/operation-node/on-conflict-node.js
var OnConflictNode;
var init_on_conflict_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/on-conflict-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_where_node();
    OnConflictNode = freeze({
      is(node) {
        return node.kind === "OnConflictNode";
      },
      create() {
        return freeze({
          kind: "OnConflictNode"
        });
      },
      cloneWith(node, props) {
        return freeze({
          ...node,
          ...props
        });
      },
      cloneWithIndexWhere(node, operation) {
        return freeze({
          ...node,
          indexWhere: node.indexWhere ? WhereNode.cloneWithOperation(node.indexWhere, "And", operation) : WhereNode.create(operation)
        });
      },
      cloneWithIndexOrWhere(node, operation) {
        return freeze({
          ...node,
          indexWhere: node.indexWhere ? WhereNode.cloneWithOperation(node.indexWhere, "Or", operation) : WhereNode.create(operation)
        });
      },
      cloneWithUpdateWhere(node, operation) {
        return freeze({
          ...node,
          updateWhere: node.updateWhere ? WhereNode.cloneWithOperation(node.updateWhere, "And", operation) : WhereNode.create(operation)
        });
      },
      cloneWithUpdateOrWhere(node, operation) {
        return freeze({
          ...node,
          updateWhere: node.updateWhere ? WhereNode.cloneWithOperation(node.updateWhere, "Or", operation) : WhereNode.create(operation)
        });
      },
      cloneWithoutIndexWhere(node) {
        return freeze({
          ...node,
          indexWhere: void 0
        });
      },
      cloneWithoutUpdateWhere(node) {
        return freeze({
          ...node,
          updateWhere: void 0
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/query-builder/on-conflict-builder.js
var OnConflictBuilder, OnConflictDoNothingBuilder, OnConflictUpdateBuilder;
var init_on_conflict_builder = __esm({
  "node_modules/kysely/dist/esm/query-builder/on-conflict-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_column_node();
    init_identifier_node();
    init_on_conflict_node();
    init_binary_operation_parser();
    init_update_set_parser();
    init_object_utils();
    init_prevent_await();
    OnConflictBuilder = class _OnConflictBuilder {
      static {
        __name(this, "OnConflictBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      /**
       * Specify a single column as the conflict target.
       *
       * Also see the {@link columns}, {@link constraint} and {@link expression}
       * methods for alternative ways to specify the conflict target.
       */
      column(column) {
        const columnNode = ColumnNode.create(column);
        return new _OnConflictBuilder({
          ...this.#props,
          onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
            columns: this.#props.onConflictNode.columns ? freeze([...this.#props.onConflictNode.columns, columnNode]) : freeze([columnNode])
          })
        });
      }
      /**
       * Specify a list of columns as the conflict target.
       *
       * Also see the {@link column}, {@link constraint} and {@link expression}
       * methods for alternative ways to specify the conflict target.
       */
      columns(columns) {
        const columnNodes = columns.map(ColumnNode.create);
        return new _OnConflictBuilder({
          ...this.#props,
          onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
            columns: this.#props.onConflictNode.columns ? freeze([...this.#props.onConflictNode.columns, ...columnNodes]) : freeze(columnNodes)
          })
        });
      }
      /**
       * Specify a specific constraint by name as the conflict target.
       *
       * Also see the {@link column}, {@link columns} and {@link expression}
       * methods for alternative ways to specify the conflict target.
       */
      constraint(constraintName) {
        return new _OnConflictBuilder({
          ...this.#props,
          onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
            constraint: IdentifierNode.create(constraintName)
          })
        });
      }
      /**
       * Specify an expression as the conflict target.
       *
       * This can be used if the unique index is an expression index.
       *
       * Also see the {@link column}, {@link columns} and {@link constraint}
       * methods for alternative ways to specify the conflict target.
       */
      expression(expression) {
        return new _OnConflictBuilder({
          ...this.#props,
          onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
            indexExpression: expression.toOperationNode()
          })
        });
      }
      where(...args) {
        return new _OnConflictBuilder({
          ...this.#props,
          onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args))
        });
      }
      whereRef(lhs, op, rhs) {
        return new _OnConflictBuilder({
          ...this.#props,
          onConflictNode: OnConflictNode.cloneWithIndexWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))
        });
      }
      clearWhere() {
        return new _OnConflictBuilder({
          ...this.#props,
          onConflictNode: OnConflictNode.cloneWithoutIndexWhere(this.#props.onConflictNode)
        });
      }
      /**
       * Adds the "do nothing" conflict action.
       *
       * ### Examples
       *
       * ```ts
       * const id = 1
       * const first_name = 'John'
       *
       * await db
       *   .insertInto('person')
       *   .values({first_name, id })
       *   .onConflict((oc) => oc
       *     .column('id')
       *     .doNothing()
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * insert into "person" ("first_name", "id")
       * values ($1, $2)
       * on conflict ("id") do nothing
       * ```
       */
      doNothing() {
        return new OnConflictDoNothingBuilder({
          ...this.#props,
          onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
            doNothing: true
          })
        });
      }
      /**
       * Adds the "do update set" conflict action.
       *
       * ### Examples
       *
       * ```ts
       * const id = 1
       * const first_name = 'John'
       *
       * await db
       *   .insertInto('person')
       *   .values({first_name, id })
       *   .onConflict((oc) => oc
       *     .column('id')
       *     .doUpdateSet({ first_name })
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * insert into "person" ("first_name", "id")
       * values ($1, $2)
       * on conflict ("id")
       * do update set "first_name" = $3
       * ```
       *
       * In the next example we use the `ref` method to reference
       * columns of the virtual table `excluded` in a type-safe way
       * to create an upsert operation:
       *
       * ```ts
       * import type { NewPerson } from 'type-editor' // imaginary module
       *
       * async function upsertPerson(person: NewPerson): Promise<void> {
       *   await db.insertInto('person')
       *     .values(person)
       *     .onConflict((oc) => oc
       *       .column('id')
       *       .doUpdateSet((eb) => ({
       *         first_name: eb.ref('excluded.first_name'),
       *         last_name: eb.ref('excluded.last_name')
       *       })
       *     )
       *   )
       *   .execute()
       * }
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * insert into "person" ("first_name", "last_name")
       * values ($1, $2)
       * on conflict ("id")
       * do update set
       *  "first_name" = excluded."first_name",
       *  "last_name" = excluded."last_name"
       * ```
       */
      doUpdateSet(update) {
        return new OnConflictUpdateBuilder({
          ...this.#props,
          onConflictNode: OnConflictNode.cloneWith(this.#props.onConflictNode, {
            updates: parseUpdateObjectExpression(update)
          })
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
    };
    preventAwait(OnConflictBuilder, "don't await OnConflictBuilder instances.");
    OnConflictDoNothingBuilder = class {
      static {
        __name(this, "OnConflictDoNothingBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      toOperationNode() {
        return this.#props.onConflictNode;
      }
    };
    preventAwait(OnConflictDoNothingBuilder, "don't await OnConflictDoNothingBuilder instances.");
    OnConflictUpdateBuilder = class _OnConflictUpdateBuilder {
      static {
        __name(this, "OnConflictUpdateBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      where(...args) {
        return new _OnConflictUpdateBuilder({
          ...this.#props,
          onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseValueBinaryOperationOrExpression(args))
        });
      }
      /**
       * Specify a where condition for the update operation.
       *
       * See {@link WhereInterface.whereRef} for more info.
       */
      whereRef(lhs, op, rhs) {
        return new _OnConflictUpdateBuilder({
          ...this.#props,
          onConflictNode: OnConflictNode.cloneWithUpdateWhere(this.#props.onConflictNode, parseReferentialBinaryOperation(lhs, op, rhs))
        });
      }
      clearWhere() {
        return new _OnConflictUpdateBuilder({
          ...this.#props,
          onConflictNode: OnConflictNode.cloneWithoutUpdateWhere(this.#props.onConflictNode)
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#props.onConflictNode;
      }
    };
    preventAwait(OnConflictUpdateBuilder, "don't await OnConflictUpdateBuilder instances.");
  }
});

// node_modules/kysely/dist/esm/operation-node/top-node.js
var TopNode;
var init_top_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/top-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    TopNode = freeze({
      is(node) {
        return node.kind === "TopNode";
      },
      create(expression, modifiers) {
        return freeze({
          kind: "TopNode",
          expression,
          modifiers
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/parser/top-parser.js
function parseTop(expression, modifiers) {
  if (!isNumber(expression) && !isBigInt(expression)) {
    throw new Error(`Invalid top expression: ${expression}`);
  }
  if (!isUndefined(modifiers) && !isTopModifiers(modifiers)) {
    throw new Error(`Invalid top modifiers: ${modifiers}`);
  }
  return TopNode.create(expression, modifiers);
}
function isTopModifiers(modifiers) {
  return modifiers === "percent" || modifiers === "with ties" || modifiers === "percent with ties";
}
var init_top_parser = __esm({
  "node_modules/kysely/dist/esm/parser/top-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_top_node();
    init_object_utils();
    __name(parseTop, "parseTop");
    __name(isTopModifiers, "isTopModifiers");
  }
});

// node_modules/kysely/dist/esm/query-builder/insert-query-builder.js
var InsertQueryBuilder;
var init_insert_query_builder = __esm({
  "node_modules/kysely/dist/esm/query-builder/insert-query-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_select_parser();
    init_insert_values_parser();
    init_insert_query_node();
    init_query_node();
    init_update_set_parser();
    init_prevent_await();
    init_object_utils();
    init_on_duplicate_key_node();
    init_insert_result();
    init_no_result_error();
    init_expression_parser();
    init_column_node();
    init_on_conflict_builder();
    init_on_conflict_node();
    init_top_parser();
    InsertQueryBuilder = class _InsertQueryBuilder {
      static {
        __name(this, "InsertQueryBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      /**
       * Sets the values to insert for an {@link Kysely.insertInto | insert} query.
       *
       * This method takes an object whose keys are column names and values are
       * values to insert. In addition to the column's type, the values can be
       * raw {@link sql} snippets or select queries.
       *
       * You must provide all fields you haven't explicitly marked as nullable
       * or optional using {@link Generated} or {@link ColumnType}.
       *
       * The return value of an `insert` query is an instance of {@link InsertResult}. The
       * {@link InsertResult.insertId | insertId} field holds the auto incremented primary
       * key if the database returned one.
       *
       * On PostgreSQL and some other dialects, you need to call `returning` to get
       * something out of the query.
       *
       * Also see the {@link expression} method for inserting the result of a select
       * query or any other expression.
       *
       * ### Examples
       *
       * <!-- siteExample("insert", "Single row", 10) -->
       *
       * Insert a single row:
       *
       * ```ts
       * const result = await db
       *   .insertInto('person')
       *   .values({
       *     first_name: 'Jennifer',
       *     last_name: 'Aniston',
       *     age: 40
       *   })
       *   .executeTakeFirst()
       *
       * // `insertId` is only available on dialects that
       * // automatically return the id of the inserted row
       * // such as MySQL and SQLite. On PostgreSQL, for example,
       * // you need to add a `returning` clause to the query to
       * // get anything out. See the "returning data" example.
       * console.log(result.insertId)
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * insert into `person` (`first_name`, `last_name`, `age`) values (?, ?, ?)
       * ```
       *
       * <!-- siteExample("insert", "Multiple rows", 20) -->
       *
       * On dialects that support it (for example PostgreSQL) you can insert multiple
       * rows by providing an array. Note that the return value is once again very
       * dialect-specific. Some databases may only return the id of the *last* inserted
       * row and some return nothing at all unless you call `returning`.
       *
       * ```ts
       * await db
       *   .insertInto('person')
       *   .values([{
       *     first_name: 'Jennifer',
       *     last_name: 'Aniston',
       *     age: 40,
       *   }, {
       *     first_name: 'Arnold',
       *     last_name: 'Schwarzenegger',
       *     age: 70,
       *   }])
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * insert into "person" ("first_name", "last_name", "age") values (($1, $2, $3), ($4, $5, $6))
       * ```
       *
       * <!-- siteExample("insert", "Returning data", 30) -->
       *
       * On supported dialects like PostgreSQL you need to chain `returning` to the query to get
       * the inserted row's columns (or any other expression) as the return value. `returning`
       * works just like `select`. Refer to `select` method's examples and documentation for
       * more info.
       *
       * ```ts
       * const result = await db
       *   .insertInto('person')
       *   .values({
       *     first_name: 'Jennifer',
       *     last_name: 'Aniston',
       *     age: 40,
       *   })
       *   .returning(['id', 'first_name as name'])
       *   .executeTakeFirstOrThrow()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * insert into "person" ("first_name", "last_name", "age") values ($1, $2, $3) returning "id", "first_name" as "name"
       * ```
       *
       * <!-- siteExample("insert", "Complex values", 40) -->
       *
       * In addition to primitives, the values can also be arbitrary expressions.
       * You can build the expressions by using a callback and calling the methods
       * on the expression builder passed to it:
       *
       * ```ts
       * import { sql } from 'kysely'
       *
       * const ani = "Ani"
       * const ston = "ston"
       *
       * const result = await db
       *   .insertInto('person')
       *   .values(({ ref, selectFrom, fn }) => ({
       *     first_name: 'Jennifer',
       *     last_name: sql<string>`concat(${ani}, ${ston})`,
       *     middle_name: ref('first_name'),
       *     age: selectFrom('person')
       *       .select(fn.avg<number>('age').as('avg_age')),
       *   }))
       *   .executeTakeFirst()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * insert into "person" (
       *   "first_name",
       *   "last_name",
       *   "middle_name",
       *   "age"
       * )
       * values (
       *   $1,
       *   concat($2, $3),
       *   "first_name",
       *   (select avg("age") as "avg_age" from "person")
       * )
       * ```
       *
       * You can also use the callback version of subqueries or raw expressions:
       *
       * ```ts
       * await db.with('jennifer', (db) => db
       *   .selectFrom('person')
       *   .where('first_name', '=', 'Jennifer')
       *   .select(['id', 'first_name', 'gender'])
       *   .limit(1)
       * ).insertInto('pet').values((eb) => ({
       *   owner_id: eb.selectFrom('jennifer').select('id'),
       *   name: eb.selectFrom('jennifer').select('first_name'),
       *   species: 'cat',
       * }))
       * .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * with "jennifer" as (
       *   select "id", "first_name", "gender"
       *   from "person"
       *   where "first_name" = $1
       *   limit $2
       * )
       * insert into "pet" ("owner_id", "name", "species")
       * values (
       *  (select "id" from "jennifer"),
       *  (select "first_name" from "jennifer"),
       *  $3
       * )
       * ```
       */
      values(insert) {
        const [columns, values] = parseInsertExpression(insert);
        return new _InsertQueryBuilder({
          ...this.#props,
          queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
            columns,
            values
          })
        });
      }
      /**
       * Sets the columns to insert.
       *
       * The {@link values} method sets both the columns and the values and this method
       * is not needed. But if you are using the {@link expression} method, you can use
       * this method to set the columns to insert.
       *
       * ### Examples
       *
       * ```ts
       * await db.insertInto('person')
       *   .columns(['first_name'])
       *   .expression((eb) => eb.selectFrom('pet').select('pet.name'))
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * insert into "person" ("first_name")
       * select "pet"."name" from "pet"
       * ```
       */
      columns(columns) {
        return new _InsertQueryBuilder({
          ...this.#props,
          queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
            columns: freeze(columns.map(ColumnNode.create))
          })
        });
      }
      /**
       * Insert an arbitrary expression. For example the result of a select query.
       *
       * ### Examples
       *
       * <!-- siteExample("insert", "Insert subquery", 50) -->
       *
       * You can create an `INSERT INTO SELECT FROM` query using the `expression` method.
       * This API doesn't follow our WYSIWYG principles and might be a bit difficult to
       * remember. The reasons for this design stem from implementation difficulties.
       *
       * ```ts
       * const result = await db.insertInto('person')
       *   .columns(['first_name', 'last_name', 'age'])
       *   .expression((eb) => eb
       *     .selectFrom('pet')
       *     .select((eb) => [
       *       'pet.name',
       *       eb.val('Petson').as('last_name'),
       *       eb.lit(7).as('age'),
       *     ])
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * insert into "person" ("first_name", "last_name", "age")
       * select "pet"."name", $1 as "last_name", 7 as "age from "pet"
       * ```
       */
      expression(expression) {
        return new _InsertQueryBuilder({
          ...this.#props,
          queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
            values: parseExpression(expression)
          })
        });
      }
      /**
       * Creates an `insert into "person" default values` query.
       *
       * ### Examples
       *
       * ```ts
       * await db.insertInto('person')
       *   .defaultValues()
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * insert into "person" default values
       * ```
       */
      defaultValues() {
        return new _InsertQueryBuilder({
          ...this.#props,
          queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
            defaultValues: true
          })
        });
      }
      /**
       * This can be used to add any additional SQL to the end of the query.
       *
       * ### Examples
       *
       * ```ts
       * import { sql } from 'kysely'
       *
       * await db.insertInto('person')
       *   .values({
       *     first_name: 'John',
       *     last_name: 'Doe',
       *     gender: 'male',
       *   })
       *   .modifyEnd(sql`-- This is a comment`)
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * insert into `person` ("first_name", "last_name", "gender")
       * values (?, ?, ?) -- This is a comment
       * ```
       */
      modifyEnd(modifier) {
        return new _InsertQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
        });
      }
      /**
       * Changes an `insert into` query to an `insert ignore into` query.
       *
       * If you use the ignore modifier, ignorable errors that occur while executing the
       * insert statement are ignored. For example, without ignore, a row that duplicates
       * an existing unique index or primary key value in the table causes a duplicate-key
       * error and the statement is aborted. With ignore, the row is discarded and no error
       * occurs.
       *
       * This is only supported on some dialects like MySQL. On most dialects you should
       * use the {@link onConflict} method.
       *
       * ### Examples
       *
       * ```ts
       * await db.insertInto('person')
       *   .ignore()
       *   .values({
       *     first_name: 'John',
       *     last_name: 'Doe',
       *     gender: 'female',
       *   })
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * insert ignore into `person` ("first_name", "last_name", "gender") values (?, ?, ?)
       * ```
       */
      ignore() {
        return new _InsertQueryBuilder({
          ...this.#props,
          queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
            ignore: true
          })
        });
      }
      /**
       * Changes an `insert into` query to an `insert top into` query.
       *
       * `top` clause is only supported by some dialects like MS SQL Server.
       *
       * ### Examples
       *
       * Insert the first 5 rows:
       *
       * ```ts
       * import { sql } from 'kysely'
       *
       * await db.insertInto('person')
       *   .top(5)
       *   .columns(['first_name', 'gender'])
       *   .expression(
       *     (eb) => eb.selectFrom('pet').select(['name', sql.lit('other').as('gender')])
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (MS SQL Server):
       *
       * ```sql
       * insert top(5) into "person" ("first_name", "gender") select "name", 'other' as "gender" from "pet"
       * ```
       *
       * Insert the first 50 percent of rows:
       *
       * ```ts
       * import { sql } from 'kysely'
       *
       * await db.insertInto('person')
       *   .top(50, 'percent')
       *   .columns(['first_name', 'gender'])
       *   .expression(
       *     (eb) => eb.selectFrom('pet').select(['name', sql.lit('other').as('gender')])
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (MS SQL Server):
       *
       * ```sql
       * insert top(50) percent into "person" ("first_name", "gender") select "name", 'other' as "gender" from "pet"
       * ```
       */
      top(expression, modifiers) {
        return new _InsertQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
        });
      }
      /**
       * Adds an `on conflict` clause to the query.
       *
       * `on conflict` is only supported by some dialects like PostgreSQL and SQLite. On MySQL
       * you can use {@link ignore} and {@link onDuplicateKeyUpdate} to achieve similar results.
       *
       * ### Examples
       *
       * ```ts
       * await db
       *   .insertInto('pet')
       *   .values({
       *     name: 'Catto',
       *     species: 'cat',
       *     owner_id: 3,
       *   })
       *   .onConflict((oc) => oc
       *     .column('name')
       *     .doUpdateSet({ species: 'hamster' })
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * insert into "pet" ("name", "species", "owner_id")
       * values ($1, $2, $3)
       * on conflict ("name")
       * do update set "species" = $4
       * ```
       *
       * You can provide the name of the constraint instead of a column name:
       *
       * ```ts
       * await db
       *   .insertInto('pet')
       *   .values({
       *     name: 'Catto',
       *     species: 'cat',
       *     owner_id: 3,
       *   })
       *   .onConflict((oc) => oc
       *     .constraint('pet_name_key')
       *     .doUpdateSet({ species: 'hamster' })
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * insert into "pet" ("name", "species", "owner_id")
       * values ($1, $2, $3)
       * on conflict on constraint "pet_name_key"
       * do update set "species" = $4
       * ```
       *
       * You can also specify an expression as the conflict target in case
       * the unique index is an expression index:
       *
       * ```ts
       * import { sql } from 'kysely'
       *
       * await db
       *   .insertInto('pet')
       *   .values({
       *     name: 'Catto',
       *     species: 'cat',
       *     owner_id: 3,
       *   })
       *   .onConflict((oc) => oc
       *     .expression(sql<string>`lower(name)`)
       *     .doUpdateSet({ species: 'hamster' })
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * insert into "pet" ("name", "species", "owner_id")
       * values ($1, $2, $3)
       * on conflict (lower(name))
       * do update set "species" = $4
       * ```
       *
       * You can add a filter for the update statement like this:
       *
       * ```ts
       * await db
       *   .insertInto('pet')
       *   .values({
       *     name: 'Catto',
       *     species: 'cat',
       *     owner_id: 3,
       *   })
       *   .onConflict((oc) => oc
       *     .column('name')
       *     .doUpdateSet({ species: 'hamster' })
       *     .where('excluded.name', '!=', 'Catto')
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * insert into "pet" ("name", "species", "owner_id")
       * values ($1, $2, $3)
       * on conflict ("name")
       * do update set "species" = $4
       * where "excluded"."name" != $5
       * ```
       *
       * You can create an `on conflict do nothing` clauses like this:
       *
       * ```ts
       * await db
       *   .insertInto('pet')
       *   .values({
       *     name: 'Catto',
       *     species: 'cat',
       *     owner_id: 3,
       *   })
       *   .onConflict((oc) => oc
       *     .column('name')
       *     .doNothing()
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * insert into "pet" ("name", "species", "owner_id")
       * values ($1, $2, $3)
       * on conflict ("name") do nothing
       * ```
       *
       * You can refer to the columns of the virtual `excluded` table
       * in a type-safe way using a callback and the `ref` method of
       * `ExpressionBuilder`:
       *
       * ```ts
       * await db.insertInto('person')
       *   .values({
       *     id: 1,
       *     first_name: 'John',
       *     last_name: 'Doe',
       *     gender: 'male',
       *   })
       *   .onConflict(oc => oc
       *     .column('id')
       *     .doUpdateSet({
       *       first_name: (eb) => eb.ref('excluded.first_name'),
       *       last_name: (eb) => eb.ref('excluded.last_name')
       *     })
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * insert into "person" ("id", "first_name", "last_name", "gender")
       * values ($1, $2, $3, $4)
       * on conflict ("id")
       * do update set
       *  "first_name" = "excluded"."first_name",
       *  "last_name" = "excluded"."last_name"
       * ```
       */
      onConflict(callback) {
        return new _InsertQueryBuilder({
          ...this.#props,
          queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
            onConflict: callback(new OnConflictBuilder({
              onConflictNode: OnConflictNode.create()
            })).toOperationNode()
          })
        });
      }
      /**
       * Adds `on duplicate key update` to the query.
       *
       * If you specify `on duplicate key update`, and a row is inserted that would cause
       * a duplicate value in a unique index or primary key, an update of the old row occurs.
       *
       * This is only implemented by some dialects like MySQL. On most dialects you should
       * use {@link onConflict} instead.
       *
       * ### Examples
       *
       * ```ts
       * await db
       *   .insertInto('person')
       *   .values({
       *     id: 1,
       *     first_name: 'John',
       *     last_name: 'Doe',
       *     gender: 'male',
       *   })
       *   .onDuplicateKeyUpdate({ updated_at: new Date().toISOString() })
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * insert into `person` (`id`, `first_name`, `last_name`, `gender`)
       * values (?, ?, ?, ?)
       * on duplicate key update `updated_at` = ?
       * ```
       */
      onDuplicateKeyUpdate(update) {
        return new _InsertQueryBuilder({
          ...this.#props,
          queryNode: InsertQueryNode.cloneWith(this.#props.queryNode, {
            onDuplicateKey: OnDuplicateKeyNode.create(parseUpdateObjectExpression(update))
          })
        });
      }
      returning(selection) {
        return new _InsertQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
        });
      }
      returningAll() {
        return new _InsertQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll())
        });
      }
      output(args) {
        return new _InsertQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
        });
      }
      outputAll(table) {
        return new _InsertQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
        });
      }
      /**
       * Clears all `returning` clauses from the query.
       *
       * ### Examples
       *
       * ```ts
       * await db.insertInto('person')
       *   .values({ first_name: 'James', last_name: 'Smith', gender: 'male' })
       *   .returning(['first_name'])
       *   .clearReturning()
       *   .execute()
       * ```
       *
       * The generated SQL(PostgreSQL):
       *
       * ```sql
       * insert into "person" ("first_name", "last_name", "gender") values ($1, $2, $3)
       * ```
       */
      clearReturning() {
        return new _InsertQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       *
       * If you want to conditionally call a method on `this`, see
       * the {@link $if} method.
       *
       * ### Examples
       *
       * The next example uses a helper function `log` to log a query:
       *
       * ```ts
       * import type { Compilable } from 'kysely'
       *
       * function log<T extends Compilable>(qb: T): T {
       *   console.log(qb.compile())
       *   return qb
       * }
       *
       * await db.insertInto('person')
       *   .values({ first_name: 'John', last_name: 'Doe', gender: 'male' })
       *   .$call(log)
       *   .execute()
       * ```
       */
      $call(func) {
        return func(this);
      }
      /**
       * Call `func(this)` if `condition` is true.
       *
       * This method is especially handy with optional selects. Any `returning` or `returningAll`
       * method calls add columns as optional fields to the output type when called inside
       * the `func` callback. This is because we can't know if those selections were actually
       * made before running the code.
       *
       * You can also call any other methods inside the callback.
       *
       * ### Examples
       *
       * ```ts
       * import type { NewPerson } from 'type-editor' // imaginary module
       *
       * async function insertPerson(values: NewPerson, returnLastName: boolean) {
       *   return await db
       *     .insertInto('person')
       *     .values(values)
       *     .returning(['id', 'first_name'])
       *     .$if(returnLastName, (qb) => qb.returning('last_name'))
       *     .executeTakeFirstOrThrow()
       * }
       * ```
       *
       * Any selections added inside the `if` callback will be added as optional fields to the
       * output type since we can't know if the selections were actually made before running
       * the code. In the example above the return type of the `insertPerson` function is:
       *
       * ```ts
       * Promise<{
       *   id: number
       *   first_name: string
       *   last_name?: string
       * }>
       * ```
       */
      $if(condition, func) {
        if (condition) {
          return func(this);
        }
        return new _InsertQueryBuilder({
          ...this.#props
        });
      }
      /**
       * Change the output type of the query.
       *
       * This method call doesn't change the SQL in any way. This methods simply
       * returns a copy of this `InsertQueryBuilder` with a new output type.
       */
      $castTo() {
        return new _InsertQueryBuilder(this.#props);
      }
      /**
       * Narrows (parts of) the output type of the query.
       *
       * Kysely tries to be as type-safe as possible, but in some cases we have to make
       * compromises for better maintainability and compilation performance. At present,
       * Kysely doesn't narrow the output type of the query based on {@link values} input
       * when using {@link returning} or {@link returningAll}.
       *
       * This utility method is very useful for these situations, as it removes unncessary
       * runtime assertion/guard code. Its input type is limited to the output type
       * of the query, so you can't add a column that doesn't exist, or change a column's
       * type to something that doesn't exist in its union type.
       *
       * ### Examples
       *
       * Turn this code:
       *
       * ```ts
       * import type { Person } from 'type-editor' // imaginary module
       *
       * const person = await db.insertInto('person')
       *   .values({
       *     first_name: 'John',
       *     last_name: 'Doe',
       *     gender: 'male',
       *     nullable_column: 'hell yeah!'
       *   })
       *   .returningAll()
       *   .executeTakeFirstOrThrow()
       *
       * if (isWithNoNullValue(person)) {
       *   functionThatExpectsPersonWithNonNullValue(person)
       * }
       *
       * function isWithNoNullValue(person: Person): person is Person & { nullable_column: string } {
       *   return person.nullable_column != null
       * }
       * ```
       *
       * Into this:
       *
       * ```ts
       * import type { NotNull } from 'kysely'
       *
       * const person = await db.insertInto('person')
       *   .values({
       *     first_name: 'John',
       *     last_name: 'Doe',
       *     gender: 'male',
       *     nullable_column: 'hell yeah!'
       *   })
       *   .returningAll()
       *   .$narrowType<{ nullable_column: NotNull }>()
       *   .executeTakeFirstOrThrow()
       *
       * functionThatExpectsPersonWithNonNullValue(person)
       * ```
       */
      $narrowType() {
        return new _InsertQueryBuilder(this.#props);
      }
      /**
       * Asserts that query's output row type equals the given type `T`.
       *
       * This method can be used to simplify excessively complex types to make TypeScript happy
       * and much faster.
       *
       * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
       * for TypeScript and you get errors like this:
       *
       * ```
       * error TS2589: Type instantiation is excessively deep and possibly infinite.
       * ```
       *
       * In these case you can often use this method to help TypeScript a little bit. When you use this
       * method to assert the output type of a query, Kysely can drop the complex output type that
       * consists of multiple nested helper types and replace it with the simple asserted type.
       *
       * Using this method doesn't reduce type safety at all. You have to pass in a type that is
       * structurally equal to the current type.
       *
       * ### Examples
       *
       * ```ts
       * import type { NewPerson, NewPet, Species } from 'type-editor' // imaginary module
       *
       * async function insertPersonAndPet(person: NewPerson, pet: Omit<NewPet, 'owner_id'>) {
       *   return await db
       *     .with('new_person', (qb) => qb
       *       .insertInto('person')
       *       .values(person)
       *       .returning('id')
       *       .$assertType<{ id: number }>()
       *     )
       *     .with('new_pet', (qb) => qb
       *       .insertInto('pet')
       *       .values((eb) => ({
       *         owner_id: eb.selectFrom('new_person').select('id'),
       *         ...pet
       *       }))
       *       .returning(['name as pet_name', 'species'])
       *       .$assertType<{ pet_name: string, species: Species }>()
       *     )
       *     .selectFrom(['new_person', 'new_pet'])
       *     .selectAll()
       *     .executeTakeFirstOrThrow()
       * }
       * ```
       */
      $assertType() {
        return new _InsertQueryBuilder(this.#props);
      }
      /**
       * Returns a copy of this InsertQueryBuilder instance with the given plugin installed.
       */
      withPlugin(plugin) {
        return new _InsertQueryBuilder({
          ...this.#props,
          executor: this.#props.executor.withPlugin(plugin)
        });
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      /**
       * Executes the query and returns an array of rows.
       *
       * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
       */
      async execute() {
        const compiledQuery = this.compile();
        const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
        const { adapter } = this.#props.executor;
        const query = compiledQuery.query;
        if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
          return result.rows;
        }
        return [
          new InsertResult(
            result.insertId,
            // TODO: remove numUpdatedOrDeletedRows.
            result.numAffectedRows ?? result.numUpdatedOrDeletedRows
          )
        ];
      }
      /**
       * Executes the query and returns the first result or undefined if
       * the query returned no result.
       */
      async executeTakeFirst() {
        const [result] = await this.execute();
        return result;
      }
      /**
       * Executes the query and returns the first result or throws if
       * the query returned no result.
       *
       * By default an instance of {@link NoResultError} is thrown, but you can
       * provide a custom error class, or callback as the only argument to throw a different
       * error.
       */
      async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
        const result = await this.executeTakeFirst();
        if (result === void 0) {
          const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
          throw error;
        }
        return result;
      }
      async *stream(chunkSize = 100) {
        const compiledQuery = this.compile();
        const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
        for await (const item of stream) {
          yield* item.rows;
        }
      }
      async explain(format, options) {
        const builder = new _InsertQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
        });
        return await builder.execute();
      }
    };
    preventAwait(InsertQueryBuilder, "don't await InsertQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");
  }
});

// node_modules/kysely/dist/esm/query-builder/delete-result.js
var DeleteResult;
var init_delete_result = __esm({
  "node_modules/kysely/dist/esm/query-builder/delete-result.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    DeleteResult = class {
      static {
        __name(this, "DeleteResult");
      }
      numDeletedRows;
      constructor(numDeletedRows) {
        this.numDeletedRows = numDeletedRows;
      }
    };
  }
});

// node_modules/kysely/dist/esm/operation-node/limit-node.js
var LimitNode;
var init_limit_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/limit-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    LimitNode = freeze({
      is(node) {
        return node.kind === "LimitNode";
      },
      create(limit) {
        return freeze({
          kind: "LimitNode",
          limit
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/query-builder/delete-query-builder.js
var DeleteQueryBuilder;
var init_delete_query_builder = __esm({
  "node_modules/kysely/dist/esm/query-builder/delete-query-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_join_parser();
    init_table_parser();
    init_select_parser();
    init_query_node();
    init_prevent_await();
    init_object_utils();
    init_no_result_error();
    init_delete_result();
    init_delete_query_node();
    init_limit_node();
    init_order_by_parser();
    init_binary_operation_parser();
    init_value_parser();
    init_top_parser();
    DeleteQueryBuilder = class _DeleteQueryBuilder {
      static {
        __name(this, "DeleteQueryBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      where(...args) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
        });
      }
      whereRef(lhs, op, rhs) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
        });
      }
      clearWhere() {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
        });
      }
      /**
       * Changes a `delete from` query into a `delete top from` query.
       *
       * `top` clause is only supported by some dialects like MS SQL Server.
       *
       * ### Examples
       *
       * Delete the first 5 rows:
       *
       * ```ts
       * await db
       *   .deleteFrom('person')
       *   .top(5)
       *   .where('age', '>', 18)
       *   .executeTakeFirstOrThrow()
       * ```
       *
       * The generated SQL (MS SQL Server):
       *
       * ```sql
       * delete top(5) from "person" where "age" > @1
       * ```
       *
       * Delete the first 50% of rows:
       *
       * ```ts
       * await db
       *   .deleteFrom('person')
       *   .top(50, 'percent')
       *   .where('age', '>', 18)
       *   .executeTakeFirstOrThrow()
       * ```
       *
       * The generated SQL (MS SQL Server):
       *
       * ```sql
       * delete top(50) percent from "person" where "age" > @1
       * ```
       */
      top(expression, modifiers) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
        });
      }
      using(tables) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: DeleteQueryNode.cloneWithUsing(this.#props.queryNode, parseTableExpressionOrList(tables))
        });
      }
      innerJoin(...args) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("InnerJoin", args))
        });
      }
      leftJoin(...args) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("LeftJoin", args))
        });
      }
      rightJoin(...args) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("RightJoin", args))
        });
      }
      fullJoin(...args) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("FullJoin", args))
        });
      }
      returning(selection) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
        });
      }
      returningAll(table) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
        });
      }
      output(args) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
        });
      }
      outputAll(table) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
        });
      }
      /**
       * Clears all `returning` clauses from the query.
       *
       * ### Examples
       *
       * ```ts
       * await db.deleteFrom('pet')
       *   .returningAll()
       *   .where('name', '=', 'Max')
       *   .clearReturning()
       *   .execute()
       * ```
       *
       * The generated SQL(PostgreSQL):
       *
       * ```sql
       * delete from "pet" where "name" = "Max"
       * ```
       */
      clearReturning() {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
        });
      }
      /**
       * Clears the `limit` clause from the query.
       *
       * ### Examples
       *
       * ```ts
       * await db.deleteFrom('pet')
       *   .returningAll()
       *   .where('name', '=', 'Max')
       *   .limit(5)
       *   .clearLimit()
       *   .execute()
       * ```
       *
       * The generated SQL(PostgreSQL):
       *
       * ```sql
       * delete from "pet" where "name" = "Max" returning *
       * ```
       */
      clearLimit() {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: DeleteQueryNode.cloneWithoutLimit(this.#props.queryNode)
        });
      }
      /**
       * Clears the `order by` clause from the query.
       *
       * ### Examples
       *
       * ```ts
       * await db.deleteFrom('pet')
       *   .returningAll()
       *   .where('name', '=', 'Max')
       *   .orderBy('id')
       *   .clearOrderBy()
       *   .execute()
       * ```
       *
       * The generated SQL(PostgreSQL):
       *
       * ```sql
       * delete from "pet" where "name" = "Max" returning *
       * ```
       */
      clearOrderBy() {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: DeleteQueryNode.cloneWithoutOrderBy(this.#props.queryNode)
        });
      }
      /**
       * Adds an `order by` clause to the query.
       *
       * `orderBy` calls are additive. To order by multiple columns, call `orderBy`
       * multiple times.
       *
       * The first argument is the expression to order by and the second is the
       * order (`asc` or `desc`).
       *
       * An `order by` clause in a delete query is only supported by some dialects
       * like MySQL.
       *
       * See {@link SelectQueryBuilder.orderBy} for more examples.
       *
       * ### Examples
       *
       * Delete 5 oldest items in a table:
       *
       * ```ts
       * await db
       *   .deleteFrom('pet')
       *   .orderBy('created_at')
       *   .limit(5)
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * delete from `pet`
       * order by `created_at`
       * limit ?
       * ```
       */
      orderBy(orderBy, direction) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: DeleteQueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy([orderBy, direction]))
        });
      }
      /**
       * Adds a limit clause to the query.
       *
       * A limit clause in a delete query is only supported by some dialects
       * like MySQL.
       *
       * ### Examples
       *
       * Delete 5 oldest items in a table:
       *
       * ```ts
       * await db
       *   .deleteFrom('pet')
       *   .orderBy('created_at')
       *   .limit(5)
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * delete from `pet` order by `created_at` limit ?
       * ```
       */
      limit(limit) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: DeleteQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))
        });
      }
      /**
       * This can be used to add any additional SQL to the end of the query.
       *
       * ### Examples
       *
       * ```ts
       * import { sql } from 'kysely'
       *
       * await db.deleteFrom('person')
       *   .where('first_name', '=', 'John')
       *   .modifyEnd(sql`-- This is a comment`)
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * delete from `person`
       * where `first_name` = "John" -- This is a comment
       * ```
       */
      modifyEnd(modifier) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       *
       * If you want to conditionally call a method on `this`, see
       * the {@link $if} method.
       *
       * ### Examples
       *
       * The next example uses a helper function `log` to log a query:
       *
       * ```ts
       * import type { Compilable } from 'kysely'
       *
       * function log<T extends Compilable>(qb: T): T {
       *   console.log(qb.compile())
       *   return qb
       * }
       *
       * await db.deleteFrom('person')
       *   .$call(log)
       *   .execute()
       * ```
       */
      $call(func) {
        return func(this);
      }
      /**
       * Call `func(this)` if `condition` is true.
       *
       * This method is especially handy with optional selects. Any `returning` or `returningAll`
       * method calls add columns as optional fields to the output type when called inside
       * the `func` callback. This is because we can't know if those selections were actually
       * made before running the code.
       *
       * You can also call any other methods inside the callback.
       *
       * ### Examples
       *
       * ```ts
       * async function deletePerson(id: number, returnLastName: boolean) {
       *   return await db
       *     .deleteFrom('person')
       *     .where('id', '=', id)
       *     .returning(['id', 'first_name'])
       *     .$if(returnLastName, (qb) => qb.returning('last_name'))
       *     .executeTakeFirstOrThrow()
       * }
       * ```
       *
       * Any selections added inside the `if` callback will be added as optional fields to the
       * output type since we can't know if the selections were actually made before running
       * the code. In the example above the return type of the `deletePerson` function is:
       *
       * ```ts
       * Promise<{
       *   id: number
       *   first_name: string
       *   last_name?: string
       * }>
       * ```
       */
      $if(condition, func) {
        if (condition) {
          return func(this);
        }
        return new _DeleteQueryBuilder({
          ...this.#props
        });
      }
      /**
       * Change the output type of the query.
       *
       * This method call doesn't change the SQL in any way. This methods simply
       * returns a copy of this `DeleteQueryBuilder` with a new output type.
       */
      $castTo() {
        return new _DeleteQueryBuilder(this.#props);
      }
      /**
       * Narrows (parts of) the output type of the query.
       *
       * Kysely tries to be as type-safe as possible, but in some cases we have to make
       * compromises for better maintainability and compilation performance. At present,
       * Kysely doesn't narrow the output type of the query when using {@link where} and {@link returning} or {@link returningAll}.
       *
       * This utility method is very useful for these situations, as it removes unncessary
       * runtime assertion/guard code. Its input type is limited to the output type
       * of the query, so you can't add a column that doesn't exist, or change a column's
       * type to something that doesn't exist in its union type.
       *
       * ### Examples
       *
       * Turn this code:
       *
       * ```ts
       * import type { Person } from 'type-editor' // imaginary module
       *
       * const person = await db.deleteFrom('person')
       *   .where('id', '=', 3)
       *   .where('nullable_column', 'is not', null)
       *   .returningAll()
       *   .executeTakeFirstOrThrow()
       *
       * if (isWithNoNullValue(person)) {
       *   functionThatExpectsPersonWithNonNullValue(person)
       * }
       *
       * function isWithNoNullValue(person: Person): person is Person & { nullable_column: string } {
       *   return person.nullable_column != null
       * }
       * ```
       *
       * Into this:
       *
       * ```ts
       * import type { NotNull } from 'kysely'
       *
       * const person = await db.deleteFrom('person')
       *   .where('id', '=', 3)
       *   .where('nullable_column', 'is not', null)
       *   .returningAll()
       *   .$narrowType<{ nullable_column: NotNull }>()
       *   .executeTakeFirstOrThrow()
       *
       * functionThatExpectsPersonWithNonNullValue(person)
       * ```
       */
      $narrowType() {
        return new _DeleteQueryBuilder(this.#props);
      }
      /**
       * Asserts that query's output row type equals the given type `T`.
       *
       * This method can be used to simplify excessively complex types to make TypeScript happy
       * and much faster.
       *
       * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
       * for TypeScript and you get errors like this:
       *
       * ```
       * error TS2589: Type instantiation is excessively deep and possibly infinite.
       * ```
       *
       * In these case you can often use this method to help TypeScript a little bit. When you use this
       * method to assert the output type of a query, Kysely can drop the complex output type that
       * consists of multiple nested helper types and replace it with the simple asserted type.
       *
       * Using this method doesn't reduce type safety at all. You have to pass in a type that is
       * structurally equal to the current type.
       *
       * ### Examples
       *
       * ```ts
       * import type { Species } from 'type-editor' // imaginary module
       *
       * async function deletePersonAndPets(personId: number) {
       *   return await db
       *     .with('deleted_person', (qb) => qb
       *        .deleteFrom('person')
       *        .where('id', '=', personId)
       *        .returning('first_name')
       *        .$assertType<{ first_name: string }>()
       *     )
       *     .with('deleted_pets', (qb) => qb
       *       .deleteFrom('pet')
       *       .where('owner_id', '=', personId)
       *       .returning(['name as pet_name', 'species'])
       *       .$assertType<{ pet_name: string, species: Species }>()
       *     )
       *     .selectFrom(['deleted_person', 'deleted_pets'])
       *     .selectAll()
       *     .execute()
       * }
       * ```
       */
      $assertType() {
        return new _DeleteQueryBuilder(this.#props);
      }
      /**
       * Returns a copy of this DeleteQueryBuilder instance with the given plugin installed.
       */
      withPlugin(plugin) {
        return new _DeleteQueryBuilder({
          ...this.#props,
          executor: this.#props.executor.withPlugin(plugin)
        });
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      /**
       * Executes the query and returns an array of rows.
       *
       * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
       */
      async execute() {
        const compiledQuery = this.compile();
        const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
        const { adapter } = this.#props.executor;
        const query = compiledQuery.query;
        if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
          return result.rows;
        }
        return [
          new DeleteResult(
            // TODO: remove numUpdatedOrDeletedRows.
            result.numAffectedRows ?? result.numUpdatedOrDeletedRows ?? BigInt(0)
          )
        ];
      }
      /**
       * Executes the query and returns the first result or undefined if
       * the query returned no result.
       */
      async executeTakeFirst() {
        const [result] = await this.execute();
        return result;
      }
      /**
       * Executes the query and returns the first result or throws if
       * the query returned no result.
       *
       * By default an instance of {@link NoResultError} is thrown, but you can
       * provide a custom error class, or callback as the only argument to throw a different
       * error.
       */
      async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
        const result = await this.executeTakeFirst();
        if (result === void 0) {
          const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
          throw error;
        }
        return result;
      }
      async *stream(chunkSize = 100) {
        const compiledQuery = this.compile();
        const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
        for await (const item of stream) {
          yield* item.rows;
        }
      }
      async explain(format, options) {
        const builder = new _DeleteQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
        });
        return await builder.execute();
      }
    };
    preventAwait(DeleteQueryBuilder, "don't await DeleteQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");
  }
});

// node_modules/kysely/dist/esm/query-builder/update-result.js
var UpdateResult;
var init_update_result = __esm({
  "node_modules/kysely/dist/esm/query-builder/update-result.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    UpdateResult = class {
      static {
        __name(this, "UpdateResult");
      }
      /**
       * The number of rows the update query updated (even if not changed).
       */
      numUpdatedRows;
      /**
       * The number of rows the update query changed.
       *
       * This is **optional** and only supported in dialects such as MySQL.
       * You would probably use {@link numUpdatedRows} in most cases.
       */
      numChangedRows;
      constructor(numUpdatedRows, numChangedRows) {
        this.numUpdatedRows = numUpdatedRows;
        this.numChangedRows = numChangedRows;
      }
    };
  }
});

// node_modules/kysely/dist/esm/query-builder/update-query-builder.js
var UpdateQueryBuilder;
var init_update_query_builder = __esm({
  "node_modules/kysely/dist/esm/query-builder/update-query-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_join_parser();
    init_table_parser();
    init_select_parser();
    init_query_node();
    init_update_query_node();
    init_update_set_parser();
    init_prevent_await();
    init_object_utils();
    init_update_result();
    init_no_result_error();
    init_binary_operation_parser();
    init_value_parser();
    init_limit_node();
    init_top_parser();
    UpdateQueryBuilder = class _UpdateQueryBuilder {
      static {
        __name(this, "UpdateQueryBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      where(...args) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
        });
      }
      whereRef(lhs, op, rhs) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
        });
      }
      clearWhere() {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
        });
      }
      /**
       * Changes an `update` query into a `update top` query.
       *
       * `top` clause is only supported by some dialects like MS SQL Server.
       *
       * ### Examples
       *
       * Update the first row:
       *
       * ```ts
       * await db.updateTable('person')
       *   .top(1)
       *   .set({ first_name: 'Foo' })
       *   .where('age', '>', 18)
       *   .executeTakeFirstOrThrow()
       * ```
       *
       * The generated SQL (MS SQL Server):
       *
       * ```sql
       * update top(1) "person" set "first_name" = @1 where "age" > @2
       * ```
       *
       * Update the 50% first rows:
       *
       * ```ts
       * await db.updateTable('person')
       *   .top(50, 'percent')
       *   .set({ first_name: 'Foo' })
       *   .where('age', '>', 18)
       *   .executeTakeFirstOrThrow()
       * ```
       *
       * The generated SQL (MS SQL Server):
       *
       * ```sql
       * update top(50) percent "person" set "first_name" = @1 where "age" > @2
       * ```
       */
      top(expression, modifiers) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
        });
      }
      from(from) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: UpdateQueryNode.cloneWithFromItems(this.#props.queryNode, parseTableExpressionOrList(from))
        });
      }
      innerJoin(...args) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("InnerJoin", args))
        });
      }
      leftJoin(...args) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("LeftJoin", args))
        });
      }
      rightJoin(...args) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("RightJoin", args))
        });
      }
      fullJoin(...args) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("FullJoin", args))
        });
      }
      /**
       * Adds a limit clause to the update query for supported databases, such as MySQL.
       *
       * ### Examples
       *
       * Update the first 2 rows in the 'person' table:
       *
       * ```ts
       * await db
       *   .updateTable('person')
       *   .set({ first_name: 'Foo' })
       *   .limit(2)
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * update `person` set `first_name` = ? limit ?
       * ```
       */
      limit(limit) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: UpdateQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))
        });
      }
      set(...args) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: UpdateQueryNode.cloneWithUpdates(this.#props.queryNode, parseUpdate(...args))
        });
      }
      returning(selection) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectArg(selection))
        });
      }
      returningAll(table) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithReturning(this.#props.queryNode, parseSelectAll(table))
        });
      }
      output(args) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
        });
      }
      outputAll(table) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
        });
      }
      /**
       * This can be used to add any additional SQL to the end of the query.
       *
       * ### Examples
       *
       * ```ts
       * import { sql } from 'kysely'
       *
       * await db.updateTable('person')
       *   .set({ age: 39 })
       *   .where('first_name', '=', 'John')
       *   .modifyEnd(sql.raw('-- This is a comment'))
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * update `person`
       * set `age` = 39
       * where `first_name` = "John" -- This is a comment
       * ```
       */
      modifyEnd(modifier) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
        });
      }
      /**
       * Clears all `returning` clauses from the query.
       *
       * ### Examples
       *
       * ```ts
       * db.updateTable('person')
       *   .returningAll()
       *   .set({ age: 39 })
       *   .where('first_name', '=', 'John')
       *   .clearReturning()
       * ```
       *
       * The generated SQL(PostgreSQL):
       *
       * ```sql
       * update "person" set "age" = 39 where "first_name" = "John"
       * ```
       */
      clearReturning() {
        return new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithoutReturning(this.#props.queryNode)
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       *
       * If you want to conditionally call a method on `this`, see
       * the {@link $if} method.
       *
       * ### Examples
       *
       * The next example uses a helper function `log` to log a query:
       *
       * ```ts
       * import type { Compilable } from 'kysely'
       * import type { PersonUpdate } from 'type-editor' // imaginary module
       *
       * function log<T extends Compilable>(qb: T): T {
       *   console.log(qb.compile())
       *   return qb
       * }
       *
       * const values = {
       *   first_name: 'John',
       * } satisfies PersonUpdate
       *
       * db.updateTable('person')
       *   .set(values)
       *   .$call(log)
       *   .execute()
       * ```
       */
      $call(func) {
        return func(this);
      }
      /**
       * Call `func(this)` if `condition` is true.
       *
       * This method is especially handy with optional selects. Any `returning` or `returningAll`
       * method calls add columns as optional fields to the output type when called inside
       * the `func` callback. This is because we can't know if those selections were actually
       * made before running the code.
       *
       * You can also call any other methods inside the callback.
       *
       * ### Examples
       *
       * ```ts
       * import type { PersonUpdate } from 'type-editor' // imaginary module
       *
       * async function updatePerson(id: number, updates: PersonUpdate, returnLastName: boolean) {
       *   return await db
       *     .updateTable('person')
       *     .set(updates)
       *     .where('id', '=', id)
       *     .returning(['id', 'first_name'])
       *     .$if(returnLastName, (qb) => qb.returning('last_name'))
       *     .executeTakeFirstOrThrow()
       * }
       * ```
       *
       * Any selections added inside the `if` callback will be added as optional fields to the
       * output type since we can't know if the selections were actually made before running
       * the code. In the example above the return type of the `updatePerson` function is:
       *
       * ```ts
       * Promise<{
       *   id: number
       *   first_name: string
       *   last_name?: string
       * }>
       * ```
       */
      $if(condition, func) {
        if (condition) {
          return func(this);
        }
        return new _UpdateQueryBuilder({
          ...this.#props
        });
      }
      /**
       * Change the output type of the query.
       *
       * This method call doesn't change the SQL in any way. This methods simply
       * returns a copy of this `UpdateQueryBuilder` with a new output type.
       */
      $castTo() {
        return new _UpdateQueryBuilder(this.#props);
      }
      /**
       * Narrows (parts of) the output type of the query.
       *
       * Kysely tries to be as type-safe as possible, but in some cases we have to make
       * compromises for better maintainability and compilation performance. At present,
       * Kysely doesn't narrow the output type of the query based on {@link set} input
       * when using {@link where} and/or {@link returning} or {@link returningAll}.
       *
       * This utility method is very useful for these situations, as it removes unncessary
       * runtime assertion/guard code. Its input type is limited to the output type
       * of the query, so you can't add a column that doesn't exist, or change a column's
       * type to something that doesn't exist in its union type.
       *
       * ### Examples
       *
       * Turn this code:
       *
       * ```ts
       * import type { Person } from 'type-editor' // imaginary module
       *
       * const id = 1
       * const now = new Date().toISOString()
       *
       * const person = await db.updateTable('person')
       *   .set({ deleted_at: now })
       *   .where('id', '=', id)
       *   .where('nullable_column', 'is not', null)
       *   .returningAll()
       *   .executeTakeFirstOrThrow()
       *
       * if (isWithNoNullValue(person)) {
       *   functionThatExpectsPersonWithNonNullValue(person)
       * }
       *
       * function isWithNoNullValue(person: Person): person is Person & { nullable_column: string } {
       *   return person.nullable_column != null
       * }
       * ```
       *
       * Into this:
       *
       * ```ts
       * import type { NotNull } from 'kysely'
       *
       * const id = 1
       * const now = new Date().toISOString()
       *
       * const person = await db.updateTable('person')
       *   .set({ deleted_at: now })
       *   .where('id', '=', id)
       *   .where('nullable_column', 'is not', null)
       *   .returningAll()
       *   .$narrowType<{ deleted_at: Date; nullable_column: NotNull }>()
       *   .executeTakeFirstOrThrow()
       *
       * functionThatExpectsPersonWithNonNullValue(person)
       * ```
       */
      $narrowType() {
        return new _UpdateQueryBuilder(this.#props);
      }
      /**
       * Asserts that query's output row type equals the given type `T`.
       *
       * This method can be used to simplify excessively complex types to make TypeScript happy
       * and much faster.
       *
       * Kysely uses complex type magic to achieve its type safety. This complexity is sometimes too much
       * for TypeScript and you get errors like this:
       *
       * ```
       * error TS2589: Type instantiation is excessively deep and possibly infinite.
       * ```
       *
       * In these case you can often use this method to help TypeScript a little bit. When you use this
       * method to assert the output type of a query, Kysely can drop the complex output type that
       * consists of multiple nested helper types and replace it with the simple asserted type.
       *
       * Using this method doesn't reduce type safety at all. You have to pass in a type that is
       * structurally equal to the current type.
       *
       * ### Examples
       *
       * ```ts
       * import type { PersonUpdate, PetUpdate, Species } from 'type-editor' // imaginary module
       *
       * const person = {
       *   id: 1,
       *   gender: 'other',
       * } satisfies PersonUpdate
       *
       * const pet = {
       *   name: 'Fluffy',
       * } satisfies PetUpdate
       *
       * const result = await db
       *   .with('updated_person', (qb) => qb
       *     .updateTable('person')
       *     .set(person)
       *     .where('id', '=', person.id)
       *     .returning('first_name')
       *     .$assertType<{ first_name: string }>()
       *   )
       *   .with('updated_pet', (qb) => qb
       *     .updateTable('pet')
       *     .set(pet)
       *     .where('owner_id', '=', person.id)
       *     .returning(['name as pet_name', 'species'])
       *     .$assertType<{ pet_name: string, species: Species }>()
       *   )
       *   .selectFrom(['updated_person', 'updated_pet'])
       *   .selectAll()
       *   .executeTakeFirstOrThrow()
       * ```
       */
      $assertType() {
        return new _UpdateQueryBuilder(this.#props);
      }
      /**
       * Returns a copy of this UpdateQueryBuilder instance with the given plugin installed.
       */
      withPlugin(plugin) {
        return new _UpdateQueryBuilder({
          ...this.#props,
          executor: this.#props.executor.withPlugin(plugin)
        });
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      /**
       * Executes the query and returns an array of rows.
       *
       * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
       */
      async execute() {
        const compiledQuery = this.compile();
        const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
        const { adapter } = this.#props.executor;
        const query = compiledQuery.query;
        if (query.returning && adapter.supportsReturning || query.output && adapter.supportsOutput) {
          return result.rows;
        }
        return [
          new UpdateResult(
            // TODO: remove numUpdatedOrDeletedRows.
            // TODO: https://github.com/kysely-org/kysely/pull/431#discussion_r1172330899
            result.numAffectedRows ?? result.numUpdatedOrDeletedRows ?? BigInt(0),
            result.numChangedRows
          )
        ];
      }
      /**
       * Executes the query and returns the first result or undefined if
       * the query returned no result.
       */
      async executeTakeFirst() {
        const [result] = await this.execute();
        return result;
      }
      /**
       * Executes the query and returns the first result or throws if
       * the query returned no result.
       *
       * By default an instance of {@link NoResultError} is thrown, but you can
       * provide a custom error class, or callback as the only argument to throw a different
       * error.
       */
      async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
        const result = await this.executeTakeFirst();
        if (result === void 0) {
          const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
          throw error;
        }
        return result;
      }
      async *stream(chunkSize = 100) {
        const compiledQuery = this.compile();
        const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
        for await (const item of stream) {
          yield* item.rows;
        }
      }
      async explain(format, options) {
        const builder = new _UpdateQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
        });
        return await builder.execute();
      }
    };
    preventAwait(UpdateQueryBuilder, "don't await UpdateQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");
  }
});

// node_modules/kysely/dist/esm/operation-node/common-table-expression-name-node.js
var CommonTableExpressionNameNode;
var init_common_table_expression_name_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/common-table-expression-name-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_column_node();
    init_table_node();
    CommonTableExpressionNameNode = freeze({
      is(node) {
        return node.kind === "CommonTableExpressionNameNode";
      },
      create(tableName, columnNames) {
        return freeze({
          kind: "CommonTableExpressionNameNode",
          table: TableNode.create(tableName),
          columns: columnNames ? freeze(columnNames.map(ColumnNode.create)) : void 0
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/common-table-expression-node.js
var CommonTableExpressionNode;
var init_common_table_expression_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/common-table-expression-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    CommonTableExpressionNode = freeze({
      is(node) {
        return node.kind === "CommonTableExpressionNode";
      },
      create(name, expression) {
        return freeze({
          kind: "CommonTableExpressionNode",
          name,
          expression
        });
      },
      cloneWith(node, props) {
        return freeze({
          ...node,
          ...props
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/query-builder/cte-builder.js
var CTEBuilder;
var init_cte_builder = __esm({
  "node_modules/kysely/dist/esm/query-builder/cte-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_common_table_expression_node();
    init_prevent_await();
    init_object_utils();
    CTEBuilder = class _CTEBuilder {
      static {
        __name(this, "CTEBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      /**
       * Makes the common table expression materialized.
       */
      materialized() {
        return new _CTEBuilder({
          ...this.#props,
          node: CommonTableExpressionNode.cloneWith(this.#props.node, {
            materialized: true
          })
        });
      }
      /**
       * Makes the common table expression not materialized.
       */
      notMaterialized() {
        return new _CTEBuilder({
          ...this.#props,
          node: CommonTableExpressionNode.cloneWith(this.#props.node, {
            materialized: false
          })
        });
      }
      toOperationNode() {
        return this.#props.node;
      }
    };
    preventAwait(CTEBuilder, "don't await CTEBuilder instances. They are never executed directly and are always just a part of a query.");
  }
});

// node_modules/kysely/dist/esm/parser/with-parser.js
function parseCommonTableExpression(nameOrBuilderCallback, expression) {
  const expressionNode = expression(createQueryCreator()).toOperationNode();
  if (isFunction(nameOrBuilderCallback)) {
    return nameOrBuilderCallback(cteBuilderFactory(expressionNode)).toOperationNode();
  }
  return CommonTableExpressionNode.create(parseCommonTableExpressionName(nameOrBuilderCallback), expressionNode);
}
function cteBuilderFactory(expressionNode) {
  return (name) => {
    return new CTEBuilder({
      node: CommonTableExpressionNode.create(parseCommonTableExpressionName(name), expressionNode)
    });
  };
}
function parseCommonTableExpressionName(name) {
  if (name.includes("(")) {
    const parts = name.split(/[\(\)]/);
    const table = parts[0];
    const columns = parts[1].split(",").map((it) => it.trim());
    return CommonTableExpressionNameNode.create(table, columns);
  } else {
    return CommonTableExpressionNameNode.create(name);
  }
}
var init_with_parser = __esm({
  "node_modules/kysely/dist/esm/parser/with-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_common_table_expression_name_node();
    init_parse_utils();
    init_object_utils();
    init_cte_builder();
    init_common_table_expression_node();
    __name(parseCommonTableExpression, "parseCommonTableExpression");
    __name(cteBuilderFactory, "cteBuilderFactory");
    __name(parseCommonTableExpressionName, "parseCommonTableExpressionName");
  }
});

// node_modules/kysely/dist/esm/operation-node/with-node.js
var WithNode;
var init_with_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/with-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    WithNode = freeze({
      is(node) {
        return node.kind === "WithNode";
      },
      create(expression, params) {
        return freeze({
          kind: "WithNode",
          expressions: freeze([expression]),
          ...params
        });
      },
      cloneWithExpression(withNode, expression) {
        return freeze({
          ...withNode,
          expressions: freeze([...withNode.expressions, expression])
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/util/random-string.js
function randomString(length) {
  let chars = "";
  for (let i = 0; i < length; ++i) {
    chars += randomChar();
  }
  return chars;
}
function randomChar() {
  return CHARS[~~(Math.random() * CHARS.length)];
}
var CHARS;
var init_random_string = __esm({
  "node_modules/kysely/dist/esm/util/random-string.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    CHARS = [
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    __name(randomString, "randomString");
    __name(randomChar, "randomChar");
  }
});

// node_modules/kysely/dist/esm/util/query-id.js
function createQueryId() {
  return new LazyQueryId();
}
var LazyQueryId;
var init_query_id = __esm({
  "node_modules/kysely/dist/esm/util/query-id.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_random_string();
    __name(createQueryId, "createQueryId");
    LazyQueryId = class {
      static {
        __name(this, "LazyQueryId");
      }
      #queryId;
      get queryId() {
        if (this.#queryId === void 0) {
          this.#queryId = randomString(8);
        }
        return this.#queryId;
      }
    };
  }
});

// node_modules/kysely/dist/esm/util/require-all-props.js
function requireAllProps(obj) {
  return obj;
}
var init_require_all_props = __esm({
  "node_modules/kysely/dist/esm/util/require-all-props.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    __name(requireAllProps, "requireAllProps");
  }
});

// node_modules/kysely/dist/esm/operation-node/operation-node-transformer.js
var OperationNodeTransformer;
var init_operation_node_transformer = __esm({
  "node_modules/kysely/dist/esm/operation-node/operation-node-transformer.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_require_all_props();
    OperationNodeTransformer = class {
      static {
        __name(this, "OperationNodeTransformer");
      }
      nodeStack = [];
      #transformers = freeze({
        AliasNode: this.transformAlias.bind(this),
        ColumnNode: this.transformColumn.bind(this),
        IdentifierNode: this.transformIdentifier.bind(this),
        SchemableIdentifierNode: this.transformSchemableIdentifier.bind(this),
        RawNode: this.transformRaw.bind(this),
        ReferenceNode: this.transformReference.bind(this),
        SelectQueryNode: this.transformSelectQuery.bind(this),
        SelectionNode: this.transformSelection.bind(this),
        TableNode: this.transformTable.bind(this),
        FromNode: this.transformFrom.bind(this),
        SelectAllNode: this.transformSelectAll.bind(this),
        AndNode: this.transformAnd.bind(this),
        OrNode: this.transformOr.bind(this),
        ValueNode: this.transformValue.bind(this),
        ValueListNode: this.transformValueList.bind(this),
        PrimitiveValueListNode: this.transformPrimitiveValueList.bind(this),
        ParensNode: this.transformParens.bind(this),
        JoinNode: this.transformJoin.bind(this),
        OperatorNode: this.transformOperator.bind(this),
        WhereNode: this.transformWhere.bind(this),
        InsertQueryNode: this.transformInsertQuery.bind(this),
        DeleteQueryNode: this.transformDeleteQuery.bind(this),
        ReturningNode: this.transformReturning.bind(this),
        CreateTableNode: this.transformCreateTable.bind(this),
        AddColumnNode: this.transformAddColumn.bind(this),
        ColumnDefinitionNode: this.transformColumnDefinition.bind(this),
        DropTableNode: this.transformDropTable.bind(this),
        DataTypeNode: this.transformDataType.bind(this),
        OrderByNode: this.transformOrderBy.bind(this),
        OrderByItemNode: this.transformOrderByItem.bind(this),
        GroupByNode: this.transformGroupBy.bind(this),
        GroupByItemNode: this.transformGroupByItem.bind(this),
        UpdateQueryNode: this.transformUpdateQuery.bind(this),
        ColumnUpdateNode: this.transformColumnUpdate.bind(this),
        LimitNode: this.transformLimit.bind(this),
        OffsetNode: this.transformOffset.bind(this),
        OnConflictNode: this.transformOnConflict.bind(this),
        OnDuplicateKeyNode: this.transformOnDuplicateKey.bind(this),
        CreateIndexNode: this.transformCreateIndex.bind(this),
        DropIndexNode: this.transformDropIndex.bind(this),
        ListNode: this.transformList.bind(this),
        PrimaryKeyConstraintNode: this.transformPrimaryKeyConstraint.bind(this),
        UniqueConstraintNode: this.transformUniqueConstraint.bind(this),
        ReferencesNode: this.transformReferences.bind(this),
        CheckConstraintNode: this.transformCheckConstraint.bind(this),
        WithNode: this.transformWith.bind(this),
        CommonTableExpressionNode: this.transformCommonTableExpression.bind(this),
        CommonTableExpressionNameNode: this.transformCommonTableExpressionName.bind(this),
        HavingNode: this.transformHaving.bind(this),
        CreateSchemaNode: this.transformCreateSchema.bind(this),
        DropSchemaNode: this.transformDropSchema.bind(this),
        AlterTableNode: this.transformAlterTable.bind(this),
        DropColumnNode: this.transformDropColumn.bind(this),
        RenameColumnNode: this.transformRenameColumn.bind(this),
        AlterColumnNode: this.transformAlterColumn.bind(this),
        ModifyColumnNode: this.transformModifyColumn.bind(this),
        AddConstraintNode: this.transformAddConstraint.bind(this),
        DropConstraintNode: this.transformDropConstraint.bind(this),
        ForeignKeyConstraintNode: this.transformForeignKeyConstraint.bind(this),
        CreateViewNode: this.transformCreateView.bind(this),
        DropViewNode: this.transformDropView.bind(this),
        GeneratedNode: this.transformGenerated.bind(this),
        DefaultValueNode: this.transformDefaultValue.bind(this),
        OnNode: this.transformOn.bind(this),
        ValuesNode: this.transformValues.bind(this),
        SelectModifierNode: this.transformSelectModifier.bind(this),
        CreateTypeNode: this.transformCreateType.bind(this),
        DropTypeNode: this.transformDropType.bind(this),
        ExplainNode: this.transformExplain.bind(this),
        DefaultInsertValueNode: this.transformDefaultInsertValue.bind(this),
        AggregateFunctionNode: this.transformAggregateFunction.bind(this),
        OverNode: this.transformOver.bind(this),
        PartitionByNode: this.transformPartitionBy.bind(this),
        PartitionByItemNode: this.transformPartitionByItem.bind(this),
        SetOperationNode: this.transformSetOperation.bind(this),
        BinaryOperationNode: this.transformBinaryOperation.bind(this),
        UnaryOperationNode: this.transformUnaryOperation.bind(this),
        UsingNode: this.transformUsing.bind(this),
        FunctionNode: this.transformFunction.bind(this),
        CaseNode: this.transformCase.bind(this),
        WhenNode: this.transformWhen.bind(this),
        JSONReferenceNode: this.transformJSONReference.bind(this),
        JSONPathNode: this.transformJSONPath.bind(this),
        JSONPathLegNode: this.transformJSONPathLeg.bind(this),
        JSONOperatorChainNode: this.transformJSONOperatorChain.bind(this),
        TupleNode: this.transformTuple.bind(this),
        MergeQueryNode: this.transformMergeQuery.bind(this),
        MatchedNode: this.transformMatched.bind(this),
        AddIndexNode: this.transformAddIndex.bind(this),
        CastNode: this.transformCast.bind(this),
        FetchNode: this.transformFetch.bind(this),
        TopNode: this.transformTop.bind(this),
        OutputNode: this.transformOutput.bind(this)
      });
      transformNode(node) {
        if (!node) {
          return node;
        }
        this.nodeStack.push(node);
        const out = this.transformNodeImpl(node);
        this.nodeStack.pop();
        return freeze(out);
      }
      transformNodeImpl(node) {
        return this.#transformers[node.kind](node);
      }
      transformNodeList(list) {
        if (!list) {
          return list;
        }
        return freeze(list.map((node) => this.transformNode(node)));
      }
      transformSelectQuery(node) {
        return requireAllProps({
          kind: "SelectQueryNode",
          from: this.transformNode(node.from),
          selections: this.transformNodeList(node.selections),
          distinctOn: this.transformNodeList(node.distinctOn),
          joins: this.transformNodeList(node.joins),
          groupBy: this.transformNode(node.groupBy),
          orderBy: this.transformNode(node.orderBy),
          where: this.transformNode(node.where),
          frontModifiers: this.transformNodeList(node.frontModifiers),
          endModifiers: this.transformNodeList(node.endModifiers),
          limit: this.transformNode(node.limit),
          offset: this.transformNode(node.offset),
          with: this.transformNode(node.with),
          having: this.transformNode(node.having),
          explain: this.transformNode(node.explain),
          setOperations: this.transformNodeList(node.setOperations),
          fetch: this.transformNode(node.fetch),
          top: this.transformNode(node.top)
        });
      }
      transformSelection(node) {
        return requireAllProps({
          kind: "SelectionNode",
          selection: this.transformNode(node.selection)
        });
      }
      transformColumn(node) {
        return requireAllProps({
          kind: "ColumnNode",
          column: this.transformNode(node.column)
        });
      }
      transformAlias(node) {
        return requireAllProps({
          kind: "AliasNode",
          node: this.transformNode(node.node),
          alias: this.transformNode(node.alias)
        });
      }
      transformTable(node) {
        return requireAllProps({
          kind: "TableNode",
          table: this.transformNode(node.table)
        });
      }
      transformFrom(node) {
        return requireAllProps({
          kind: "FromNode",
          froms: this.transformNodeList(node.froms)
        });
      }
      transformReference(node) {
        return requireAllProps({
          kind: "ReferenceNode",
          column: this.transformNode(node.column),
          table: this.transformNode(node.table)
        });
      }
      transformAnd(node) {
        return requireAllProps({
          kind: "AndNode",
          left: this.transformNode(node.left),
          right: this.transformNode(node.right)
        });
      }
      transformOr(node) {
        return requireAllProps({
          kind: "OrNode",
          left: this.transformNode(node.left),
          right: this.transformNode(node.right)
        });
      }
      transformValueList(node) {
        return requireAllProps({
          kind: "ValueListNode",
          values: this.transformNodeList(node.values)
        });
      }
      transformParens(node) {
        return requireAllProps({
          kind: "ParensNode",
          node: this.transformNode(node.node)
        });
      }
      transformJoin(node) {
        return requireAllProps({
          kind: "JoinNode",
          joinType: node.joinType,
          table: this.transformNode(node.table),
          on: this.transformNode(node.on)
        });
      }
      transformRaw(node) {
        return requireAllProps({
          kind: "RawNode",
          sqlFragments: freeze([...node.sqlFragments]),
          parameters: this.transformNodeList(node.parameters)
        });
      }
      transformWhere(node) {
        return requireAllProps({
          kind: "WhereNode",
          where: this.transformNode(node.where)
        });
      }
      transformInsertQuery(node) {
        return requireAllProps({
          kind: "InsertQueryNode",
          into: this.transformNode(node.into),
          columns: this.transformNodeList(node.columns),
          values: this.transformNode(node.values),
          returning: this.transformNode(node.returning),
          onConflict: this.transformNode(node.onConflict),
          onDuplicateKey: this.transformNode(node.onDuplicateKey),
          endModifiers: this.transformNodeList(node.endModifiers),
          with: this.transformNode(node.with),
          ignore: node.ignore,
          replace: node.replace,
          explain: this.transformNode(node.explain),
          defaultValues: node.defaultValues,
          top: this.transformNode(node.top),
          output: this.transformNode(node.output)
        });
      }
      transformValues(node) {
        return requireAllProps({
          kind: "ValuesNode",
          values: this.transformNodeList(node.values)
        });
      }
      transformDeleteQuery(node) {
        return requireAllProps({
          kind: "DeleteQueryNode",
          from: this.transformNode(node.from),
          using: this.transformNode(node.using),
          joins: this.transformNodeList(node.joins),
          where: this.transformNode(node.where),
          returning: this.transformNode(node.returning),
          endModifiers: this.transformNodeList(node.endModifiers),
          with: this.transformNode(node.with),
          orderBy: this.transformNode(node.orderBy),
          limit: this.transformNode(node.limit),
          explain: this.transformNode(node.explain),
          top: this.transformNode(node.top),
          output: this.transformNode(node.output)
        });
      }
      transformReturning(node) {
        return requireAllProps({
          kind: "ReturningNode",
          selections: this.transformNodeList(node.selections)
        });
      }
      transformCreateTable(node) {
        return requireAllProps({
          kind: "CreateTableNode",
          table: this.transformNode(node.table),
          columns: this.transformNodeList(node.columns),
          constraints: this.transformNodeList(node.constraints),
          temporary: node.temporary,
          ifNotExists: node.ifNotExists,
          onCommit: node.onCommit,
          frontModifiers: this.transformNodeList(node.frontModifiers),
          endModifiers: this.transformNodeList(node.endModifiers),
          selectQuery: this.transformNode(node.selectQuery)
        });
      }
      transformColumnDefinition(node) {
        return requireAllProps({
          kind: "ColumnDefinitionNode",
          column: this.transformNode(node.column),
          dataType: this.transformNode(node.dataType),
          references: this.transformNode(node.references),
          primaryKey: node.primaryKey,
          autoIncrement: node.autoIncrement,
          unique: node.unique,
          notNull: node.notNull,
          unsigned: node.unsigned,
          defaultTo: this.transformNode(node.defaultTo),
          check: this.transformNode(node.check),
          generated: this.transformNode(node.generated),
          frontModifiers: this.transformNodeList(node.frontModifiers),
          endModifiers: this.transformNodeList(node.endModifiers),
          nullsNotDistinct: node.nullsNotDistinct,
          identity: node.identity,
          ifNotExists: node.ifNotExists
        });
      }
      transformAddColumn(node) {
        return requireAllProps({
          kind: "AddColumnNode",
          column: this.transformNode(node.column)
        });
      }
      transformDropTable(node) {
        return requireAllProps({
          kind: "DropTableNode",
          table: this.transformNode(node.table),
          ifExists: node.ifExists,
          cascade: node.cascade
        });
      }
      transformOrderBy(node) {
        return requireAllProps({
          kind: "OrderByNode",
          items: this.transformNodeList(node.items)
        });
      }
      transformOrderByItem(node) {
        return requireAllProps({
          kind: "OrderByItemNode",
          orderBy: this.transformNode(node.orderBy),
          direction: this.transformNode(node.direction)
        });
      }
      transformGroupBy(node) {
        return requireAllProps({
          kind: "GroupByNode",
          items: this.transformNodeList(node.items)
        });
      }
      transformGroupByItem(node) {
        return requireAllProps({
          kind: "GroupByItemNode",
          groupBy: this.transformNode(node.groupBy)
        });
      }
      transformUpdateQuery(node) {
        return requireAllProps({
          kind: "UpdateQueryNode",
          table: this.transformNode(node.table),
          from: this.transformNode(node.from),
          joins: this.transformNodeList(node.joins),
          where: this.transformNode(node.where),
          updates: this.transformNodeList(node.updates),
          returning: this.transformNode(node.returning),
          endModifiers: this.transformNodeList(node.endModifiers),
          with: this.transformNode(node.with),
          explain: this.transformNode(node.explain),
          limit: this.transformNode(node.limit),
          top: this.transformNode(node.top),
          output: this.transformNode(node.output)
        });
      }
      transformColumnUpdate(node) {
        return requireAllProps({
          kind: "ColumnUpdateNode",
          column: this.transformNode(node.column),
          value: this.transformNode(node.value)
        });
      }
      transformLimit(node) {
        return requireAllProps({
          kind: "LimitNode",
          limit: this.transformNode(node.limit)
        });
      }
      transformOffset(node) {
        return requireAllProps({
          kind: "OffsetNode",
          offset: this.transformNode(node.offset)
        });
      }
      transformOnConflict(node) {
        return requireAllProps({
          kind: "OnConflictNode",
          columns: this.transformNodeList(node.columns),
          constraint: this.transformNode(node.constraint),
          indexExpression: this.transformNode(node.indexExpression),
          indexWhere: this.transformNode(node.indexWhere),
          updates: this.transformNodeList(node.updates),
          updateWhere: this.transformNode(node.updateWhere),
          doNothing: node.doNothing
        });
      }
      transformOnDuplicateKey(node) {
        return requireAllProps({
          kind: "OnDuplicateKeyNode",
          updates: this.transformNodeList(node.updates)
        });
      }
      transformCreateIndex(node) {
        return requireAllProps({
          kind: "CreateIndexNode",
          name: this.transformNode(node.name),
          table: this.transformNode(node.table),
          columns: this.transformNodeList(node.columns),
          unique: node.unique,
          using: this.transformNode(node.using),
          ifNotExists: node.ifNotExists,
          where: this.transformNode(node.where),
          nullsNotDistinct: node.nullsNotDistinct
        });
      }
      transformList(node) {
        return requireAllProps({
          kind: "ListNode",
          items: this.transformNodeList(node.items)
        });
      }
      transformDropIndex(node) {
        return requireAllProps({
          kind: "DropIndexNode",
          name: this.transformNode(node.name),
          table: this.transformNode(node.table),
          ifExists: node.ifExists,
          cascade: node.cascade
        });
      }
      transformPrimaryKeyConstraint(node) {
        return requireAllProps({
          kind: "PrimaryKeyConstraintNode",
          columns: this.transformNodeList(node.columns),
          name: this.transformNode(node.name)
        });
      }
      transformUniqueConstraint(node) {
        return requireAllProps({
          kind: "UniqueConstraintNode",
          columns: this.transformNodeList(node.columns),
          name: this.transformNode(node.name),
          nullsNotDistinct: node.nullsNotDistinct
        });
      }
      transformForeignKeyConstraint(node) {
        return requireAllProps({
          kind: "ForeignKeyConstraintNode",
          columns: this.transformNodeList(node.columns),
          references: this.transformNode(node.references),
          name: this.transformNode(node.name),
          onDelete: node.onDelete,
          onUpdate: node.onUpdate
        });
      }
      transformSetOperation(node) {
        return requireAllProps({
          kind: "SetOperationNode",
          operator: node.operator,
          expression: this.transformNode(node.expression),
          all: node.all
        });
      }
      transformReferences(node) {
        return requireAllProps({
          kind: "ReferencesNode",
          table: this.transformNode(node.table),
          columns: this.transformNodeList(node.columns),
          onDelete: node.onDelete,
          onUpdate: node.onUpdate
        });
      }
      transformCheckConstraint(node) {
        return requireAllProps({
          kind: "CheckConstraintNode",
          expression: this.transformNode(node.expression),
          name: this.transformNode(node.name)
        });
      }
      transformWith(node) {
        return requireAllProps({
          kind: "WithNode",
          expressions: this.transformNodeList(node.expressions),
          recursive: node.recursive
        });
      }
      transformCommonTableExpression(node) {
        return requireAllProps({
          kind: "CommonTableExpressionNode",
          name: this.transformNode(node.name),
          materialized: node.materialized,
          expression: this.transformNode(node.expression)
        });
      }
      transformCommonTableExpressionName(node) {
        return requireAllProps({
          kind: "CommonTableExpressionNameNode",
          table: this.transformNode(node.table),
          columns: this.transformNodeList(node.columns)
        });
      }
      transformHaving(node) {
        return requireAllProps({
          kind: "HavingNode",
          having: this.transformNode(node.having)
        });
      }
      transformCreateSchema(node) {
        return requireAllProps({
          kind: "CreateSchemaNode",
          schema: this.transformNode(node.schema),
          ifNotExists: node.ifNotExists
        });
      }
      transformDropSchema(node) {
        return requireAllProps({
          kind: "DropSchemaNode",
          schema: this.transformNode(node.schema),
          ifExists: node.ifExists,
          cascade: node.cascade
        });
      }
      transformAlterTable(node) {
        return requireAllProps({
          kind: "AlterTableNode",
          table: this.transformNode(node.table),
          renameTo: this.transformNode(node.renameTo),
          setSchema: this.transformNode(node.setSchema),
          columnAlterations: this.transformNodeList(node.columnAlterations),
          addConstraint: this.transformNode(node.addConstraint),
          dropConstraint: this.transformNode(node.dropConstraint),
          addIndex: this.transformNode(node.addIndex),
          dropIndex: this.transformNode(node.dropIndex)
        });
      }
      transformDropColumn(node) {
        return requireAllProps({
          kind: "DropColumnNode",
          column: this.transformNode(node.column)
        });
      }
      transformRenameColumn(node) {
        return requireAllProps({
          kind: "RenameColumnNode",
          column: this.transformNode(node.column),
          renameTo: this.transformNode(node.renameTo)
        });
      }
      transformAlterColumn(node) {
        return requireAllProps({
          kind: "AlterColumnNode",
          column: this.transformNode(node.column),
          dataType: this.transformNode(node.dataType),
          dataTypeExpression: this.transformNode(node.dataTypeExpression),
          setDefault: this.transformNode(node.setDefault),
          dropDefault: node.dropDefault,
          setNotNull: node.setNotNull,
          dropNotNull: node.dropNotNull
        });
      }
      transformModifyColumn(node) {
        return requireAllProps({
          kind: "ModifyColumnNode",
          column: this.transformNode(node.column)
        });
      }
      transformAddConstraint(node) {
        return requireAllProps({
          kind: "AddConstraintNode",
          constraint: this.transformNode(node.constraint)
        });
      }
      transformDropConstraint(node) {
        return requireAllProps({
          kind: "DropConstraintNode",
          constraintName: this.transformNode(node.constraintName),
          ifExists: node.ifExists,
          modifier: node.modifier
        });
      }
      transformCreateView(node) {
        return requireAllProps({
          kind: "CreateViewNode",
          name: this.transformNode(node.name),
          temporary: node.temporary,
          orReplace: node.orReplace,
          ifNotExists: node.ifNotExists,
          materialized: node.materialized,
          columns: this.transformNodeList(node.columns),
          as: this.transformNode(node.as)
        });
      }
      transformDropView(node) {
        return requireAllProps({
          kind: "DropViewNode",
          name: this.transformNode(node.name),
          ifExists: node.ifExists,
          materialized: node.materialized,
          cascade: node.cascade
        });
      }
      transformGenerated(node) {
        return requireAllProps({
          kind: "GeneratedNode",
          byDefault: node.byDefault,
          always: node.always,
          identity: node.identity,
          stored: node.stored,
          expression: this.transformNode(node.expression)
        });
      }
      transformDefaultValue(node) {
        return requireAllProps({
          kind: "DefaultValueNode",
          defaultValue: this.transformNode(node.defaultValue)
        });
      }
      transformOn(node) {
        return requireAllProps({
          kind: "OnNode",
          on: this.transformNode(node.on)
        });
      }
      transformSelectModifier(node) {
        return requireAllProps({
          kind: "SelectModifierNode",
          modifier: node.modifier,
          rawModifier: this.transformNode(node.rawModifier),
          of: this.transformNodeList(node.of)
        });
      }
      transformCreateType(node) {
        return requireAllProps({
          kind: "CreateTypeNode",
          name: this.transformNode(node.name),
          enum: this.transformNode(node.enum)
        });
      }
      transformDropType(node) {
        return requireAllProps({
          kind: "DropTypeNode",
          name: this.transformNode(node.name),
          ifExists: node.ifExists
        });
      }
      transformExplain(node) {
        return requireAllProps({
          kind: "ExplainNode",
          format: node.format,
          options: this.transformNode(node.options)
        });
      }
      transformSchemableIdentifier(node) {
        return requireAllProps({
          kind: "SchemableIdentifierNode",
          schema: this.transformNode(node.schema),
          identifier: this.transformNode(node.identifier)
        });
      }
      transformAggregateFunction(node) {
        return requireAllProps({
          kind: "AggregateFunctionNode",
          aggregated: this.transformNodeList(node.aggregated),
          distinct: node.distinct,
          orderBy: this.transformNode(node.orderBy),
          filter: this.transformNode(node.filter),
          func: node.func,
          over: this.transformNode(node.over)
        });
      }
      transformOver(node) {
        return requireAllProps({
          kind: "OverNode",
          orderBy: this.transformNode(node.orderBy),
          partitionBy: this.transformNode(node.partitionBy)
        });
      }
      transformPartitionBy(node) {
        return requireAllProps({
          kind: "PartitionByNode",
          items: this.transformNodeList(node.items)
        });
      }
      transformPartitionByItem(node) {
        return requireAllProps({
          kind: "PartitionByItemNode",
          partitionBy: this.transformNode(node.partitionBy)
        });
      }
      transformBinaryOperation(node) {
        return requireAllProps({
          kind: "BinaryOperationNode",
          leftOperand: this.transformNode(node.leftOperand),
          operator: this.transformNode(node.operator),
          rightOperand: this.transformNode(node.rightOperand)
        });
      }
      transformUnaryOperation(node) {
        return requireAllProps({
          kind: "UnaryOperationNode",
          operator: this.transformNode(node.operator),
          operand: this.transformNode(node.operand)
        });
      }
      transformUsing(node) {
        return requireAllProps({
          kind: "UsingNode",
          tables: this.transformNodeList(node.tables)
        });
      }
      transformFunction(node) {
        return requireAllProps({
          kind: "FunctionNode",
          func: node.func,
          arguments: this.transformNodeList(node.arguments)
        });
      }
      transformCase(node) {
        return requireAllProps({
          kind: "CaseNode",
          value: this.transformNode(node.value),
          when: this.transformNodeList(node.when),
          else: this.transformNode(node.else),
          isStatement: node.isStatement
        });
      }
      transformWhen(node) {
        return requireAllProps({
          kind: "WhenNode",
          condition: this.transformNode(node.condition),
          result: this.transformNode(node.result)
        });
      }
      transformJSONReference(node) {
        return requireAllProps({
          kind: "JSONReferenceNode",
          reference: this.transformNode(node.reference),
          traversal: this.transformNode(node.traversal)
        });
      }
      transformJSONPath(node) {
        return requireAllProps({
          kind: "JSONPathNode",
          inOperator: this.transformNode(node.inOperator),
          pathLegs: this.transformNodeList(node.pathLegs)
        });
      }
      transformJSONPathLeg(node) {
        return requireAllProps({
          kind: "JSONPathLegNode",
          type: node.type,
          value: node.value
        });
      }
      transformJSONOperatorChain(node) {
        return requireAllProps({
          kind: "JSONOperatorChainNode",
          operator: this.transformNode(node.operator),
          values: this.transformNodeList(node.values)
        });
      }
      transformTuple(node) {
        return requireAllProps({
          kind: "TupleNode",
          values: this.transformNodeList(node.values)
        });
      }
      transformMergeQuery(node) {
        return requireAllProps({
          kind: "MergeQueryNode",
          into: this.transformNode(node.into),
          using: this.transformNode(node.using),
          whens: this.transformNodeList(node.whens),
          with: this.transformNode(node.with),
          top: this.transformNode(node.top),
          endModifiers: this.transformNodeList(node.endModifiers),
          output: this.transformNode(node.output)
        });
      }
      transformMatched(node) {
        return requireAllProps({
          kind: "MatchedNode",
          not: node.not,
          bySource: node.bySource
        });
      }
      transformAddIndex(node) {
        return requireAllProps({
          kind: "AddIndexNode",
          name: this.transformNode(node.name),
          columns: this.transformNodeList(node.columns),
          unique: node.unique,
          using: this.transformNode(node.using),
          ifNotExists: node.ifNotExists
        });
      }
      transformCast(node) {
        return requireAllProps({
          kind: "CastNode",
          expression: this.transformNode(node.expression),
          dataType: this.transformNode(node.dataType)
        });
      }
      transformFetch(node) {
        return requireAllProps({
          kind: "FetchNode",
          rowCount: this.transformNode(node.rowCount),
          modifier: node.modifier
        });
      }
      transformTop(node) {
        return requireAllProps({
          kind: "TopNode",
          expression: node.expression,
          modifiers: node.modifiers
        });
      }
      transformOutput(node) {
        return requireAllProps({
          kind: "OutputNode",
          selections: this.transformNodeList(node.selections)
        });
      }
      transformDataType(node) {
        return node;
      }
      transformSelectAll(node) {
        return node;
      }
      transformIdentifier(node) {
        return node;
      }
      transformValue(node) {
        return node;
      }
      transformPrimitiveValueList(node) {
        return node;
      }
      transformOperator(node) {
        return node;
      }
      transformDefaultInsertValue(node) {
        return node;
      }
    };
  }
});

// node_modules/kysely/dist/esm/plugin/with-schema/with-schema-transformer.js
var ROOT_OPERATION_NODES, SCHEMALESS_FUNCTIONS, WithSchemaTransformer;
var init_with_schema_transformer = __esm({
  "node_modules/kysely/dist/esm/plugin/with-schema/with-schema-transformer.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_alias_node();
    init_identifier_node();
    init_operation_node_transformer();
    init_schemable_identifier_node();
    init_table_node();
    init_object_utils();
    ROOT_OPERATION_NODES = freeze({
      AlterTableNode: true,
      CreateIndexNode: true,
      CreateSchemaNode: true,
      CreateTableNode: true,
      CreateTypeNode: true,
      CreateViewNode: true,
      DeleteQueryNode: true,
      DropIndexNode: true,
      DropSchemaNode: true,
      DropTableNode: true,
      DropTypeNode: true,
      DropViewNode: true,
      InsertQueryNode: true,
      RawNode: true,
      SelectQueryNode: true,
      UpdateQueryNode: true,
      MergeQueryNode: true
    });
    SCHEMALESS_FUNCTIONS = {
      json_agg: true,
      to_json: true
    };
    WithSchemaTransformer = class extends OperationNodeTransformer {
      static {
        __name(this, "WithSchemaTransformer");
      }
      #schema;
      #schemableIds = /* @__PURE__ */ new Set();
      #ctes = /* @__PURE__ */ new Set();
      constructor(schema) {
        super();
        this.#schema = schema;
      }
      transformNodeImpl(node) {
        if (!this.#isRootOperationNode(node)) {
          return super.transformNodeImpl(node);
        }
        const ctes = this.#collectCTEs(node);
        for (const cte of ctes) {
          this.#ctes.add(cte);
        }
        const tables = this.#collectSchemableIds(node);
        for (const table of tables) {
          this.#schemableIds.add(table);
        }
        const transformed = super.transformNodeImpl(node);
        for (const table of tables) {
          this.#schemableIds.delete(table);
        }
        for (const cte of ctes) {
          this.#ctes.delete(cte);
        }
        return transformed;
      }
      transformSchemableIdentifier(node) {
        const transformed = super.transformSchemableIdentifier(node);
        if (transformed.schema || !this.#schemableIds.has(node.identifier.name)) {
          return transformed;
        }
        return {
          ...transformed,
          schema: IdentifierNode.create(this.#schema)
        };
      }
      transformReferences(node) {
        const transformed = super.transformReferences(node);
        if (transformed.table.table.schema) {
          return transformed;
        }
        return {
          ...transformed,
          table: TableNode.createWithSchema(this.#schema, transformed.table.table.identifier.name)
        };
      }
      transformAggregateFunction(node) {
        return {
          ...super.transformAggregateFunction({ ...node, aggregated: [] }),
          aggregated: this.#transformTableArgsWithoutSchemas(node, "aggregated")
        };
      }
      transformFunction(node) {
        return {
          ...super.transformFunction({ ...node, arguments: [] }),
          arguments: this.#transformTableArgsWithoutSchemas(node, "arguments")
        };
      }
      #transformTableArgsWithoutSchemas(node, argsKey) {
        return SCHEMALESS_FUNCTIONS[node.func] ? node[argsKey].map((arg) => !TableNode.is(arg) || arg.table.schema ? this.transformNode(arg) : {
          ...arg,
          table: this.transformIdentifier(arg.table.identifier)
        }) : this.transformNodeList(node[argsKey]);
      }
      #isRootOperationNode(node) {
        return node.kind in ROOT_OPERATION_NODES;
      }
      #collectSchemableIds(node) {
        const schemableIds = /* @__PURE__ */ new Set();
        if ("name" in node && node.name && SchemableIdentifierNode.is(node.name)) {
          this.#collectSchemableId(node.name, schemableIds);
        }
        if ("from" in node && node.from) {
          for (const from of node.from.froms) {
            this.#collectSchemableIdsFromTableExpr(from, schemableIds);
          }
        }
        if ("into" in node && node.into) {
          this.#collectSchemableIdsFromTableExpr(node.into, schemableIds);
        }
        if ("table" in node && node.table) {
          this.#collectSchemableIdsFromTableExpr(node.table, schemableIds);
        }
        if ("joins" in node && node.joins) {
          for (const join of node.joins) {
            this.#collectSchemableIdsFromTableExpr(join.table, schemableIds);
          }
        }
        if ("using" in node && node.using) {
          this.#collectSchemableIdsFromTableExpr(node.using, schemableIds);
        }
        return schemableIds;
      }
      #collectCTEs(node) {
        const ctes = /* @__PURE__ */ new Set();
        if ("with" in node && node.with) {
          this.#collectCTEIds(node.with, ctes);
        }
        return ctes;
      }
      #collectSchemableIdsFromTableExpr(node, schemableIds) {
        const table = TableNode.is(node) ? node : AliasNode.is(node) && TableNode.is(node.node) ? node.node : null;
        if (table) {
          this.#collectSchemableId(table.table, schemableIds);
        }
      }
      #collectSchemableId(node, schemableIds) {
        const id = node.identifier.name;
        if (!this.#schemableIds.has(id) && !this.#ctes.has(id)) {
          schemableIds.add(id);
        }
      }
      #collectCTEIds(node, ctes) {
        for (const expr of node.expressions) {
          const cteId = expr.name.table.table.identifier.name;
          if (!this.#ctes.has(cteId)) {
            ctes.add(cteId);
          }
        }
      }
    };
  }
});

// node_modules/kysely/dist/esm/plugin/with-schema/with-schema-plugin.js
var WithSchemaPlugin;
var init_with_schema_plugin = __esm({
  "node_modules/kysely/dist/esm/plugin/with-schema/with-schema-plugin.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_with_schema_transformer();
    WithSchemaPlugin = class {
      static {
        __name(this, "WithSchemaPlugin");
      }
      #transformer;
      constructor(schema) {
        this.#transformer = new WithSchemaTransformer(schema);
      }
      transformQuery(args) {
        return this.#transformer.transformNode(args.node);
      }
      async transformResult(args) {
        return args.result;
      }
    };
  }
});

// node_modules/kysely/dist/esm/operation-node/matched-node.js
var MatchedNode;
var init_matched_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/matched-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    MatchedNode = freeze({
      is(node) {
        return node.kind === "MatchedNode";
      },
      create(not, bySource = false) {
        return freeze({
          kind: "MatchedNode",
          not,
          bySource
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/parser/merge-parser.js
function parseMergeWhen(type, args, refRight) {
  return WhenNode.create(parseFilterList([
    MatchedNode.create(!type.isMatched, type.bySource),
    ...args && args.length > 0 ? [
      args.length === 3 && refRight ? parseReferentialBinaryOperation(args[0], args[1], args[2]) : parseValueBinaryOperationOrExpression(args)
    ] : []
  ], "and", false));
}
function parseMergeThen(result) {
  if (isString(result)) {
    return RawNode.create([result], []);
  }
  if (isOperationNodeSource(result)) {
    return result.toOperationNode();
  }
  return result;
}
var init_merge_parser = __esm({
  "node_modules/kysely/dist/esm/parser/merge-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_matched_node();
    init_operation_node_source();
    init_raw_node();
    init_when_node();
    init_object_utils();
    init_binary_operation_parser();
    __name(parseMergeWhen, "parseMergeWhen");
    __name(parseMergeThen, "parseMergeThen");
  }
});

// node_modules/kysely/dist/esm/util/deferred.js
var Deferred;
var init_deferred = __esm({
  "node_modules/kysely/dist/esm/util/deferred.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    Deferred = class {
      static {
        __name(this, "Deferred");
      }
      #promise;
      #resolve;
      #reject;
      constructor() {
        this.#promise = new Promise((resolve, reject) => {
          this.#reject = reject;
          this.#resolve = resolve;
        });
      }
      get promise() {
        return this.#promise;
      }
      resolve = /* @__PURE__ */ __name((value) => {
        if (this.#resolve) {
          this.#resolve(value);
        }
      }, "resolve");
      reject = /* @__PURE__ */ __name((reason) => {
        if (this.#reject) {
          this.#reject(reason);
        }
      }, "reject");
    };
  }
});

// node_modules/kysely/dist/esm/util/log-once.js
function logOnce(message) {
  if (LOGGED_MESSAGES.has(message)) {
    return;
  }
  LOGGED_MESSAGES.add(message);
  console.log(message);
}
var LOGGED_MESSAGES;
var init_log_once = __esm({
  "node_modules/kysely/dist/esm/util/log-once.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    LOGGED_MESSAGES = /* @__PURE__ */ new Set();
    __name(logOnce, "logOnce");
  }
});

// node_modules/kysely/dist/esm/query-executor/query-executor-base.js
function warnOfOutdatedDriverOrPlugins(result, transformedResult) {
  const { numAffectedRows } = result;
  if (numAffectedRows === void 0 && result.numUpdatedOrDeletedRows === void 0 || numAffectedRows !== void 0 && transformedResult.numAffectedRows !== void 0) {
    return;
  }
  logOnce("kysely:warning: outdated driver/plugin detected! QueryResult.numUpdatedOrDeletedRows is deprecated and will be removed in a future release.");
}
var NO_PLUGINS, QueryExecutorBase;
var init_query_executor_base = __esm({
  "node_modules/kysely/dist/esm/query-executor/query-executor-base.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_deferred();
    init_log_once();
    NO_PLUGINS = freeze([]);
    QueryExecutorBase = class {
      static {
        __name(this, "QueryExecutorBase");
      }
      #plugins;
      constructor(plugins = NO_PLUGINS) {
        this.#plugins = plugins;
      }
      get plugins() {
        return this.#plugins;
      }
      transformQuery(node, queryId) {
        for (const plugin of this.#plugins) {
          const transformedNode = plugin.transformQuery({ node, queryId });
          if (transformedNode.kind === node.kind) {
            node = transformedNode;
          } else {
            throw new Error([
              `KyselyPlugin.transformQuery must return a node`,
              `of the same kind that was given to it.`,
              `The plugin was given a ${node.kind}`,
              `but it returned a ${transformedNode.kind}`
            ].join(" "));
          }
        }
        return node;
      }
      async executeQuery(compiledQuery, queryId) {
        return await this.provideConnection(async (connection) => {
          const result = await connection.executeQuery(compiledQuery);
          const transformedResult = await this.#transformResult(result, queryId);
          warnOfOutdatedDriverOrPlugins(result, transformedResult);
          return transformedResult;
        });
      }
      async *stream(compiledQuery, chunkSize, queryId) {
        const connectionDefer = new Deferred();
        const connectionReleaseDefer = new Deferred();
        this.provideConnection(async (connection2) => {
          connectionDefer.resolve(connection2);
          return await connectionReleaseDefer.promise;
        }).catch((ex) => connectionDefer.reject(ex));
        const connection = await connectionDefer.promise;
        try {
          for await (const result of connection.streamQuery(compiledQuery, chunkSize)) {
            yield await this.#transformResult(result, queryId);
          }
        } finally {
          connectionReleaseDefer.resolve();
        }
      }
      async #transformResult(result, queryId) {
        for (const plugin of this.#plugins) {
          result = await plugin.transformResult({ result, queryId });
        }
        return result;
      }
    };
    __name(warnOfOutdatedDriverOrPlugins, "warnOfOutdatedDriverOrPlugins");
  }
});

// node_modules/kysely/dist/esm/query-executor/noop-query-executor.js
var NoopQueryExecutor, NOOP_QUERY_EXECUTOR;
var init_noop_query_executor = __esm({
  "node_modules/kysely/dist/esm/query-executor/noop-query-executor.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_query_executor_base();
    NoopQueryExecutor = class _NoopQueryExecutor extends QueryExecutorBase {
      static {
        __name(this, "NoopQueryExecutor");
      }
      get adapter() {
        throw new Error("this query cannot be compiled to SQL");
      }
      compileQuery() {
        throw new Error("this query cannot be compiled to SQL");
      }
      provideConnection() {
        throw new Error("this query cannot be executed");
      }
      withConnectionProvider() {
        throw new Error("this query cannot have a connection provider");
      }
      withPlugin(plugin) {
        return new _NoopQueryExecutor([...this.plugins, plugin]);
      }
      withPlugins(plugins) {
        return new _NoopQueryExecutor([...this.plugins, ...plugins]);
      }
      withPluginAtFront(plugin) {
        return new _NoopQueryExecutor([plugin, ...this.plugins]);
      }
      withoutPlugins() {
        return new _NoopQueryExecutor([]);
      }
    };
    NOOP_QUERY_EXECUTOR = new NoopQueryExecutor();
  }
});

// node_modules/kysely/dist/esm/query-builder/merge-result.js
var MergeResult;
var init_merge_result = __esm({
  "node_modules/kysely/dist/esm/query-builder/merge-result.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    MergeResult = class {
      static {
        __name(this, "MergeResult");
      }
      numChangedRows;
      constructor(numChangedRows) {
        this.numChangedRows = numChangedRows;
      }
    };
  }
});

// node_modules/kysely/dist/esm/query-builder/merge-query-builder.js
var MergeQueryBuilder, WheneableMergeQueryBuilder, MatchedThenableMergeQueryBuilder, NotMatchedThenableMergeQueryBuilder;
var init_merge_query_builder = __esm({
  "node_modules/kysely/dist/esm/query-builder/merge-query-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_insert_query_node();
    init_merge_query_node();
    init_query_node();
    init_update_query_node();
    init_insert_values_parser();
    init_join_parser();
    init_merge_parser();
    init_select_parser();
    init_top_parser();
    init_noop_query_executor();
    init_object_utils();
    init_prevent_await();
    init_merge_result();
    init_no_result_error();
    init_update_query_builder();
    MergeQueryBuilder = class _MergeQueryBuilder {
      static {
        __name(this, "MergeQueryBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      /**
       * This can be used to add any additional SQL to the end of the query.
       *
       * ### Examples
       *
       * ```ts
       * import { sql } from 'kysely'
       *
       * await db
       *   .mergeInto('person')
       *   .using('pet', 'pet.owner_id', 'person.id')
       *   .whenMatched()
       *   .thenDelete()
       *   .modifyEnd(sql.raw('-- this is a comment'))
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * merge into "person" using "pet" on "pet"."owner_id" = "person"."id" when matched then delete -- this is a comment
       * ```
       */
      modifyEnd(modifier) {
        return new _MergeQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
        });
      }
      /**
       * Changes a `merge into` query to an `merge top into` query.
       *
       * `top` clause is only supported by some dialects like MS SQL Server.
       *
       * ### Examples
       *
       * Affect 5 matched rows at most:
       *
       * ```ts
       * await db.mergeInto('person')
       *   .top(5)
       *   .using('pet', 'person.id', 'pet.owner_id')
       *   .whenMatched()
       *   .thenDelete()
       *   .execute()
       * ```
       *
       * The generated SQL (MS SQL Server):
       *
       * ```sql
       * merge top(5) into "person"
       * using "pet" on "person"."id" = "pet"."owner_id"
       * when matched then
       *   delete
       * ```
       *
       * Affect 50% of matched rows:
       *
       * ```ts
       * await db.mergeInto('person')
       *   .top(50, 'percent')
       *   .using('pet', 'person.id', 'pet.owner_id')
       *   .whenMatched()
       *   .thenDelete()
       *   .execute()
       * ```
       *
       * The generated SQL (MS SQL Server):
       *
       * ```sql
       * merge top(50) percent into "person"
       * using "pet" on "person"."id" = "pet"."owner_id"
       * when matched then
       *   delete
       * ```
       */
      top(expression, modifiers) {
        return new _MergeQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
        });
      }
      using(...args) {
        return new WheneableMergeQueryBuilder({
          ...this.#props,
          queryNode: MergeQueryNode.cloneWithUsing(this.#props.queryNode, parseJoin("Using", args))
        });
      }
      output(args) {
        return new _MergeQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
        });
      }
      outputAll(table) {
        return new _MergeQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
        });
      }
    };
    preventAwait(MergeQueryBuilder, "don't await MergeQueryBuilder instances directly. To execute the query you need to call `execute` when available.");
    WheneableMergeQueryBuilder = class _WheneableMergeQueryBuilder {
      static {
        __name(this, "WheneableMergeQueryBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      /**
       * This can be used to add any additional SQL to the end of the query.
       *
       * ### Examples
       *
       * ```ts
       * import { sql } from 'kysely'
       *
       * await db
       *   .mergeInto('person')
       *   .using('pet', 'pet.owner_id', 'person.id')
       *   .whenMatched()
       *   .thenDelete()
       *   .modifyEnd(sql.raw('-- this is a comment'))
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * merge into "person" using "pet" on "pet"."owner_id" = "person"."id" when matched then delete -- this is a comment
       * ```
       */
      modifyEnd(modifier) {
        return new _WheneableMergeQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, modifier.toOperationNode())
        });
      }
      /**
       * See {@link MergeQueryBuilder.top}.
       */
      top(expression, modifiers) {
        return new _WheneableMergeQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
        });
      }
      /**
       * Adds a simple `when matched` clause to the query.
       *
       * For a `when matched` clause with an `and` condition, see {@link whenMatchedAnd}.
       *
       * For a simple `when not matched` clause, see {@link whenNotMatched}.
       *
       * For a `when not matched` clause with an `and` condition, see {@link whenNotMatchedAnd}.
       *
       * ### Examples
       *
       * ```ts
       * const result = await db.mergeInto('person')
       *   .using('pet', 'person.id', 'pet.owner_id')
       *   .whenMatched()
       *   .thenDelete()
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * merge into "person"
       * using "pet" on "person"."id" = "pet"."owner_id"
       * when matched then
       *   delete
       * ```
       */
      whenMatched() {
        return this.#whenMatched([]);
      }
      whenMatchedAnd(...args) {
        return this.#whenMatched(args);
      }
      /**
       * Adds the `when matched` clause to the query with an `and` condition. But unlike
       * {@link whenMatchedAnd}, this method accepts a column reference as the 3rd argument.
       *
       * This method is similar to {@link SelectQueryBuilder.whereRef}, so see the documentation
       * for that method for more examples.
       */
      whenMatchedAndRef(lhs, op, rhs) {
        return this.#whenMatched([lhs, op, rhs], true);
      }
      #whenMatched(args, refRight) {
        return new MatchedThenableMergeQueryBuilder({
          ...this.#props,
          queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: true }, args, refRight))
        });
      }
      /**
       * Adds a simple `when not matched` clause to the query.
       *
       * For a `when not matched` clause with an `and` condition, see {@link whenNotMatchedAnd}.
       *
       * For a simple `when matched` clause, see {@link whenMatched}.
       *
       * For a `when matched` clause with an `and` condition, see {@link whenMatchedAnd}.
       *
       * ### Examples
       *
       * ```ts
       * const result = await db.mergeInto('person')
       *   .using('pet', 'person.id', 'pet.owner_id')
       *   .whenNotMatched()
       *   .thenInsertValues({
       *     first_name: 'John',
       *     last_name: 'Doe',
       *   })
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * merge into "person"
       * using "pet" on "person"."id" = "pet"."owner_id"
       * when not matched then
       *   insert ("first_name", "last_name") values ($1, $2)
       * ```
       */
      whenNotMatched() {
        return this.#whenNotMatched([]);
      }
      whenNotMatchedAnd(...args) {
        return this.#whenNotMatched(args);
      }
      /**
       * Adds the `when not matched` clause to the query with an `and` condition. But unlike
       * {@link whenNotMatchedAnd}, this method accepts a column reference as the 3rd argument.
       *
       * Unlike {@link whenMatchedAndRef}, you cannot reference columns from the target table.
       *
       * This method is similar to {@link SelectQueryBuilder.whereRef}, so see the documentation
       * for that method for more examples.
       */
      whenNotMatchedAndRef(lhs, op, rhs) {
        return this.#whenNotMatched([lhs, op, rhs], true);
      }
      /**
       * Adds a simple `when not matched by source` clause to the query.
       *
       * Supported in MS SQL Server.
       *
       * Similar to {@link whenNotMatched}, but returns a {@link MatchedThenableMergeQueryBuilder}.
       */
      whenNotMatchedBySource() {
        return this.#whenNotMatched([], false, true);
      }
      whenNotMatchedBySourceAnd(...args) {
        return this.#whenNotMatched(args, false, true);
      }
      /**
       * Adds the `when not matched by source` clause to the query with an `and` condition.
       *
       * Similar to {@link whenNotMatchedAndRef}, but you can reference columns from
       * the target table, and not from source table and returns a {@link MatchedThenableMergeQueryBuilder}.
       */
      whenNotMatchedBySourceAndRef(lhs, op, rhs) {
        return this.#whenNotMatched([lhs, op, rhs], true, true);
      }
      output(args) {
        return new _WheneableMergeQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectArg(args))
        });
      }
      outputAll(table) {
        return new _WheneableMergeQueryBuilder({
          ...this.#props,
          queryNode: QueryNode.cloneWithOutput(this.#props.queryNode, parseSelectAll(table))
        });
      }
      #whenNotMatched(args, refRight = false, bySource = false) {
        const props = {
          ...this.#props,
          queryNode: MergeQueryNode.cloneWithWhen(this.#props.queryNode, parseMergeWhen({ isMatched: false, bySource }, args, refRight))
        };
        const Builder = bySource ? MatchedThenableMergeQueryBuilder : NotMatchedThenableMergeQueryBuilder;
        return new Builder(props);
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       *
       * If you want to conditionally call a method on `this`, see
       * the {@link $if} method.
       *
       * ### Examples
       *
       * The next example uses a helper function `log` to log a query:
       *
       * ```ts
       * import type { Compilable } from 'kysely'
       *
       * function log<T extends Compilable>(qb: T): T {
       *   console.log(qb.compile())
       *   return qb
       * }
       *
       * await db.updateTable('person')
       *   .set({ first_name: 'John' })
       *   .$call(log)
       *   .execute()
       * ```
       */
      $call(func) {
        return func(this);
      }
      /**
       * Call `func(this)` if `condition` is true.
       *
       * This method is especially handy with optional selects. Any `returning` or `returningAll`
       * method calls add columns as optional fields to the output type when called inside
       * the `func` callback. This is because we can't know if those selections were actually
       * made before running the code.
       *
       * You can also call any other methods inside the callback.
       *
       * ### Examples
       *
       * ```ts
       * import type { PersonUpdate } from 'type-editor' // imaginary module
       *
       * async function updatePerson(id: number, updates: PersonUpdate, returnLastName: boolean) {
       *   return await db
       *     .updateTable('person')
       *     .set(updates)
       *     .where('id', '=', id)
       *     .returning(['id', 'first_name'])
       *     .$if(returnLastName, (qb) => qb.returning('last_name'))
       *     .executeTakeFirstOrThrow()
       * }
       * ```
       *
       * Any selections added inside the `if` callback will be added as optional fields to the
       * output type since we can't know if the selections were actually made before running
       * the code. In the example above the return type of the `updatePerson` function is:
       *
       * ```ts
       * Promise<{
       *   id: number
       *   first_name: string
       *   last_name?: string
       * }>
       * ```
       */
      $if(condition, func) {
        if (condition) {
          return func(this);
        }
        return new _WheneableMergeQueryBuilder({
          ...this.#props
        });
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      /**
       * Executes the query and returns an array of rows.
       *
       * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
       */
      async execute() {
        const compiledQuery = this.compile();
        const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
        if (compiledQuery.query.output && this.#props.executor.adapter.supportsOutput) {
          return result.rows;
        }
        return [new MergeResult(result.numAffectedRows)];
      }
      /**
       * Executes the query and returns the first result or undefined if
       * the query returned no result.
       */
      async executeTakeFirst() {
        const [result] = await this.execute();
        return result;
      }
      /**
       * Executes the query and returns the first result or throws if
       * the query returned no result.
       *
       * By default an instance of {@link NoResultError} is thrown, but you can
       * provide a custom error class, or callback as the only argument to throw a different
       * error.
       */
      async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
        const result = await this.executeTakeFirst();
        if (result === void 0) {
          const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
          throw error;
        }
        return result;
      }
    };
    preventAwait(WheneableMergeQueryBuilder, "don't await WheneableMergeQueryBuilder instances directly. To execute the query you need to call `execute`.");
    MatchedThenableMergeQueryBuilder = class {
      static {
        __name(this, "MatchedThenableMergeQueryBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      /**
       * Performs the `delete` action.
       *
       * To perform the `do nothing` action, see {@link thenDoNothing}.
       *
       * To perform the `update` action, see {@link thenUpdate} or {@link thenUpdateSet}.
       *
       * ### Examples
       *
       * ```ts
       * const result = await db.mergeInto('person')
       *   .using('pet', 'person.id', 'pet.owner_id')
       *   .whenMatched()
       *   .thenDelete()
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * merge into "person"
       * using "pet" on "person"."id" = "pet"."owner_id"
       * when matched then
       *   delete
       * ```
       */
      thenDelete() {
        return new WheneableMergeQueryBuilder({
          ...this.#props,
          queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("delete"))
        });
      }
      /**
       * Performs the `do nothing` action.
       *
       * This is supported in PostgreSQL.
       *
       * To perform the `delete` action, see {@link thenDelete}.
       *
       * To perform the `update` action, see {@link thenUpdate} or {@link thenUpdateSet}.
       *
       * ### Examples
       *
       * ```ts
       * const result = await db.mergeInto('person')
       *   .using('pet', 'person.id', 'pet.owner_id')
       *   .whenMatched()
       *   .thenDoNothing()
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * merge into "person"
       * using "pet" on "person"."id" = "pet"."owner_id"
       * when matched then
       *   do nothing
       * ```
       */
      thenDoNothing() {
        return new WheneableMergeQueryBuilder({
          ...this.#props,
          queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("do nothing"))
        });
      }
      /**
       * Perform an `update` operation with a full-fledged {@link UpdateQueryBuilder}.
       * This is handy when multiple `set` invocations are needed.
       *
       * For a shorthand version of this method, see {@link thenUpdateSet}.
       *
       * To perform the `delete` action, see {@link thenDelete}.
       *
       * To perform the `do nothing` action, see {@link thenDoNothing}.
       *
       * ### Examples
       *
       * ```ts
       * import { sql } from 'kysely'
       *
       * const result = await db.mergeInto('person')
       *   .using('pet', 'person.id', 'pet.owner_id')
       *   .whenMatched()
       *   .thenUpdate((ub) => ub
       *     .set(sql`metadata['has_pets']`, 'Y')
       *     .set({
       *       updated_at: new Date().toISOString(),
       *     })
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * merge into "person"
       * using "pet" on "person"."id" = "pet"."owner_id"
       * when matched then
       *   update set metadata['has_pets'] = $1, "updated_at" = $2
       * ```
       */
      thenUpdate(set) {
        return new WheneableMergeQueryBuilder({
          ...this.#props,
          queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(set(new UpdateQueryBuilder({
            queryId: this.#props.queryId,
            executor: NOOP_QUERY_EXECUTOR,
            queryNode: UpdateQueryNode.createWithoutTable()
          }))))
        });
      }
      thenUpdateSet(...args) {
        return this.thenUpdate((ub) => ub.set(...args));
      }
    };
    preventAwait(MatchedThenableMergeQueryBuilder, "don't await MatchedThenableMergeQueryBuilder instances directly. To execute the query you need to call `execute` when available.");
    NotMatchedThenableMergeQueryBuilder = class {
      static {
        __name(this, "NotMatchedThenableMergeQueryBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      /**
       * Performs the `do nothing` action.
       *
       * This is supported in PostgreSQL.
       *
       * To perform the `insert` action, see {@link thenInsertValues}.
       *
       * ### Examples
       *
       * ```ts
       * const result = await db.mergeInto('person')
       *   .using('pet', 'person.id', 'pet.owner_id')
       *   .whenNotMatched()
       *   .thenDoNothing()
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * merge into "person"
       * using "pet" on "person"."id" = "pet"."owner_id"
       * when not matched then
       *   do nothing
       * ```
       */
      thenDoNothing() {
        return new WheneableMergeQueryBuilder({
          ...this.#props,
          queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen("do nothing"))
        });
      }
      thenInsertValues(insert) {
        const [columns, values] = parseInsertExpression(insert);
        return new WheneableMergeQueryBuilder({
          ...this.#props,
          queryNode: MergeQueryNode.cloneWithThen(this.#props.queryNode, parseMergeThen(InsertQueryNode.cloneWith(InsertQueryNode.createWithoutInto(), {
            columns,
            values
          })))
        });
      }
    };
    preventAwait(NotMatchedThenableMergeQueryBuilder, "don't await NotMatchedThenableMergeQueryBuilder instances directly. To execute the query you need to call `execute` when available.");
  }
});

// node_modules/kysely/dist/esm/query-creator.js
var QueryCreator;
var init_query_creator = __esm({
  "node_modules/kysely/dist/esm/query-creator.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_select_query_builder();
    init_insert_query_builder();
    init_delete_query_builder();
    init_update_query_builder();
    init_delete_query_node();
    init_insert_query_node();
    init_select_query_node();
    init_update_query_node();
    init_table_parser();
    init_with_parser();
    init_with_node();
    init_query_id();
    init_with_schema_plugin();
    init_object_utils();
    init_select_parser();
    init_merge_query_builder();
    init_merge_query_node();
    QueryCreator = class _QueryCreator {
      static {
        __name(this, "QueryCreator");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      selectFrom(from) {
        return createSelectQueryBuilder({
          queryId: createQueryId(),
          executor: this.#props.executor,
          queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(from), this.#props.withNode)
        });
      }
      selectNoFrom(selection) {
        return createSelectQueryBuilder({
          queryId: createQueryId(),
          executor: this.#props.executor,
          queryNode: SelectQueryNode.cloneWithSelections(SelectQueryNode.create(this.#props.withNode), parseSelectArg(selection))
        });
      }
      /**
       * Creates an insert query.
       *
       * The return value of this query is an instance of {@link InsertResult}. {@link InsertResult}
       * has the {@link InsertResult.insertId | insertId} field that holds the auto incremented id of
       * the inserted row if the db returned one.
       *
       * See the {@link InsertQueryBuilder.values | values} method for more info and examples. Also see
       * the {@link ReturningInterface.returning | returning} method for a way to return columns
       * on supported databases like PostgreSQL.
       *
       * ### Examples
       *
       * ```ts
       * const result = await db
       *   .insertInto('person')
       *   .values({
       *     first_name: 'Jennifer',
       *     last_name: 'Aniston'
       *   })
       *   .executeTakeFirst()
       *
       * console.log(result.insertId)
       * ```
       *
       * Some databases like PostgreSQL support the `returning` method:
       *
       * ```ts
       * const { id } = await db
       *   .insertInto('person')
       *   .values({
       *     first_name: 'Jennifer',
       *     last_name: 'Aniston'
       *   })
       *   .returning('id')
       *   .executeTakeFirstOrThrow()
       * ```
       */
      insertInto(table) {
        return new InsertQueryBuilder({
          queryId: createQueryId(),
          executor: this.#props.executor,
          queryNode: InsertQueryNode.create(parseTable(table), this.#props.withNode)
        });
      }
      /**
       * Creates a replace query.
       *
       * A MySQL-only statement similar to {@link InsertQueryBuilder.onDuplicateKeyUpdate}
       * that deletes and inserts values on collision instead of updating existing rows.
       *
       * The return value of this query is an instance of {@link InsertResult}. {@link InsertResult}
       * has the {@link InsertResult.insertId | insertId} field that holds the auto incremented id of
       * the inserted row if the db returned one.
       *
       * See the {@link InsertQueryBuilder.values | values} method for more info and examples.
       *
       * ### Examples
       *
       * ```ts
       * const result = await db
       *   .replaceInto('person')
       *   .values({
       *     first_name: 'Jennifer',
       *     last_name: 'Aniston'
       *   })
       *   .executeTakeFirst()
       *
       * console.log(result.insertId)
       * ```
       */
      replaceInto(table) {
        return new InsertQueryBuilder({
          queryId: createQueryId(),
          executor: this.#props.executor,
          queryNode: InsertQueryNode.create(parseTable(table), this.#props.withNode, true)
        });
      }
      deleteFrom(tables) {
        return new DeleteQueryBuilder({
          queryId: createQueryId(),
          executor: this.#props.executor,
          queryNode: DeleteQueryNode.create(parseTableExpressionOrList(tables), this.#props.withNode)
        });
      }
      updateTable(table) {
        return new UpdateQueryBuilder({
          queryId: createQueryId(),
          executor: this.#props.executor,
          queryNode: UpdateQueryNode.create(parseTableExpression(table), this.#props.withNode)
        });
      }
      mergeInto(targetTable) {
        return new MergeQueryBuilder({
          queryId: createQueryId(),
          executor: this.#props.executor,
          queryNode: MergeQueryNode.create(parseAliasedTable(targetTable), this.#props.withNode)
        });
      }
      /**
       * Creates a `with` query (Common Table Expression).
       *
       * ### Examples
       *
       * <!-- siteExample("cte", "Simple selects", 10) -->
       *
       * Common table expressions (CTE) are a great way to modularize complex queries.
       * Essentially they allow you to run multiple separate queries within a
       * single roundtrip to the DB.
       *
       * Since CTEs are a part of the main query, query optimizers inside DB
       * engines are able to optimize the overall query. For example, postgres
       * is able to inline the CTEs inside the using queries if it decides it's
       * faster.
       *
       * ```ts
       * const result = await db
       *   // Create a CTE called `jennifers` that selects all
       *   // persons named 'Jennifer'.
       *   .with('jennifers', (db) => db
       *     .selectFrom('person')
       *     .where('first_name', '=', 'Jennifer')
       *     .select(['id', 'age'])
       *   )
       *   // Select all rows from the `jennifers` CTE and
       *   // further filter it.
       *   .with('adult_jennifers', (db) => db
       *     .selectFrom('jennifers')
       *     .where('age', '>', 18)
       *     .select(['id', 'age'])
       *   )
       *   // Finally select all adult jennifers that are
       *   // also younger than 60.
       *   .selectFrom('adult_jennifers')
       *   .where('age', '<', 60)
       *   .selectAll()
       *   .execute()
       * ```
       *
       * <!-- siteExample("cte", "Inserts, updates and deletions", 20) -->
       *
       * Some databases like postgres also allow you to run other queries than selects
       * in CTEs. On these databases CTEs are extremely powerful:
       *
       * ```ts
       * const result = await db
       *   .with('new_person', (db) => db
       *     .insertInto('person')
       *     .values({
       *       first_name: 'Jennifer',
       *       age: 35,
       *     })
       *     .returning('id')
       *   )
       *   .with('new_pet', (db) => db
       *     .insertInto('pet')
       *     .values({
       *       name: 'Doggo',
       *       species: 'dog',
       *       is_favorite: true,
       *       // Use the id of the person we just inserted.
       *       owner_id: db
       *         .selectFrom('new_person')
       *         .select('id')
       *     })
       *     .returning('id')
       *   )
       *   .selectFrom(['new_person', 'new_pet'])
       *   .select([
       *     'new_person.id as person_id',
       *     'new_pet.id as pet_id'
       *   ])
       *   .execute()
       * ```
       *
       * The CTE name can optionally specify column names in addition to
       * a name. In that case Kysely requires the expression to retun
       * rows with the same columns.
       *
       * ```ts
       * await db
       *   .with('jennifers(id, age)', (db) => db
       *     .selectFrom('person')
       *     .where('first_name', '=', 'Jennifer')
       *     // This is ok since we return columns with the same
       *     // names as specified by `jennifers(id, age)`.
       *     .select(['id', 'age'])
       *   )
       *   .selectFrom('jennifers')
       *   .selectAll()
       *   .execute()
       * ```
       *
       * The first argument can also be a callback. The callback is passed
       * a `CTEBuilder` instance that can be used to configure the CTE:
       *
       * ```ts
       * await db
       *   .with(
       *     (cte) => cte('jennifers').materialized(),
       *     (db) => db
       *       .selectFrom('person')
       *       .where('first_name', '=', 'Jennifer')
       *       .select(['id', 'age'])
       *   )
       *   .selectFrom('jennifers')
       *   .selectAll()
       *   .execute()
       * ```
       */
      with(nameOrBuilder, expression) {
        const cte = parseCommonTableExpression(nameOrBuilder, expression);
        return new _QueryCreator({
          ...this.#props,
          withNode: this.#props.withNode ? WithNode.cloneWithExpression(this.#props.withNode, cte) : WithNode.create(cte)
        });
      }
      /**
       * Creates a recursive `with` query (Common Table Expression).
       *
       * Note that recursiveness is a property of the whole `with` statement.
       * You cannot have recursive and non-recursive CTEs in a same `with` statement.
       * Therefore the recursiveness is determined by the **first** `with` or
       * `withRecusive` call you make.
       *
       * See the {@link with} method for examples and more documentation.
       */
      withRecursive(nameOrBuilder, expression) {
        const cte = parseCommonTableExpression(nameOrBuilder, expression);
        return new _QueryCreator({
          ...this.#props,
          withNode: this.#props.withNode ? WithNode.cloneWithExpression(this.#props.withNode, cte) : WithNode.create(cte, { recursive: true })
        });
      }
      /**
       * Returns a copy of this query creator instance with the given plugin installed.
       */
      withPlugin(plugin) {
        return new _QueryCreator({
          ...this.#props,
          executor: this.#props.executor.withPlugin(plugin)
        });
      }
      /**
       * Returns a copy of this query creator instance without any plugins.
       */
      withoutPlugins() {
        return new _QueryCreator({
          ...this.#props,
          executor: this.#props.executor.withoutPlugins()
        });
      }
      /**
       * Sets the schema to be used for all table references that don't explicitly
       * specify a schema.
       *
       * This only affects the query created through the builder returned from
       * this method and doesn't modify the `db` instance.
       *
       * See [this recipe](https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0007-schemas.md)
       * for a more detailed explanation.
       *
       * ### Examples
       *
       * ```
       * await db
       *   .withSchema('mammals')
       *   .selectFrom('pet')
       *   .selectAll()
       *   .innerJoin('public.person', 'public.person.id', 'pet.owner_id')
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * select * from "mammals"."pet"
       * inner join "public"."person"
       * on "public"."person"."id" = "mammals"."pet"."owner_id"
       * ```
       *
       * `withSchema` is smart enough to not add schema for aliases,
       * common table expressions or other places where the schema
       * doesn't belong to:
       *
       * ```
       * await db
       *   .withSchema('mammals')
       *   .selectFrom('pet as p')
       *   .select('p.name')
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * select "p"."name" from "mammals"."pet" as "p"
       * ```
       */
      withSchema(schema) {
        return new _QueryCreator({
          ...this.#props,
          executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema))
        });
      }
    };
  }
});

// node_modules/kysely/dist/esm/parser/parse-utils.js
function createQueryCreator() {
  return new QueryCreator({
    executor: NOOP_QUERY_EXECUTOR
  });
}
function createJoinBuilder(joinType, table) {
  return new JoinBuilder({
    joinNode: JoinNode.create(joinType, parseTableExpression(table))
  });
}
function createOverBuilder() {
  return new OverBuilder({
    overNode: OverNode.create()
  });
}
var init_parse_utils = __esm({
  "node_modules/kysely/dist/esm/parser/parse-utils.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_join_node();
    init_over_node();
    init_join_builder();
    init_over_builder();
    init_query_creator();
    init_noop_query_executor();
    init_table_parser();
    __name(createQueryCreator, "createQueryCreator");
    __name(createJoinBuilder, "createJoinBuilder");
    __name(createOverBuilder, "createOverBuilder");
  }
});

// node_modules/kysely/dist/esm/parser/join-parser.js
function parseJoin(joinType, args) {
  if (args.length === 3) {
    return parseSingleOnJoin(joinType, args[0], args[1], args[2]);
  } else if (args.length === 2) {
    return parseCallbackJoin(joinType, args[0], args[1]);
  } else {
    throw new Error("not implemented");
  }
}
function parseCallbackJoin(joinType, from, callback) {
  return callback(createJoinBuilder(joinType, from)).toOperationNode();
}
function parseSingleOnJoin(joinType, from, lhsColumn, rhsColumn) {
  return JoinNode.createWithOn(joinType, parseTableExpression(from), parseReferentialBinaryOperation(lhsColumn, "=", rhsColumn));
}
var init_join_parser = __esm({
  "node_modules/kysely/dist/esm/parser/join-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_join_node();
    init_table_parser();
    init_binary_operation_parser();
    init_parse_utils();
    __name(parseJoin, "parseJoin");
    __name(parseCallbackJoin, "parseCallbackJoin");
    __name(parseSingleOnJoin, "parseSingleOnJoin");
  }
});

// node_modules/kysely/dist/esm/operation-node/offset-node.js
var OffsetNode;
var init_offset_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/offset-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    OffsetNode = freeze({
      is(node) {
        return node.kind === "OffsetNode";
      },
      create(offset) {
        return freeze({
          kind: "OffsetNode",
          offset
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/group-by-item-node.js
var GroupByItemNode;
var init_group_by_item_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/group-by-item-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    GroupByItemNode = freeze({
      is(node) {
        return node.kind === "GroupByItemNode";
      },
      create(groupBy) {
        return freeze({
          kind: "GroupByItemNode",
          groupBy
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/parser/group-by-parser.js
function parseGroupBy(groupBy) {
  groupBy = isFunction(groupBy) ? groupBy(expressionBuilder()) : groupBy;
  return parseReferenceExpressionOrList(groupBy).map(GroupByItemNode.create);
}
var init_group_by_parser = __esm({
  "node_modules/kysely/dist/esm/parser/group-by-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_group_by_item_node();
    init_expression_builder();
    init_object_utils();
    init_reference_parser();
    __name(parseGroupBy, "parseGroupBy");
  }
});

// node_modules/kysely/dist/esm/operation-node/set-operation-node.js
var SetOperationNode;
var init_set_operation_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/set-operation-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    SetOperationNode = freeze({
      is(node) {
        return node.kind === "SetOperationNode";
      },
      create(operator, expression, all) {
        return freeze({
          kind: "SetOperationNode",
          operator,
          expression,
          all
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/parser/set-operation-parser.js
function parseSetOperations(operator, expression, all) {
  if (isFunction(expression)) {
    expression = expression(createExpressionBuilder());
  }
  if (!isReadonlyArray(expression)) {
    expression = [expression];
  }
  return expression.map((expr) => SetOperationNode.create(operator, parseExpression(expr), all));
}
var init_set_operation_parser = __esm({
  "node_modules/kysely/dist/esm/parser/set-operation-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_expression_builder();
    init_set_operation_node();
    init_object_utils();
    init_expression_parser();
    __name(parseSetOperations, "parseSetOperations");
  }
});

// node_modules/kysely/dist/esm/expression/expression-wrapper.js
var ExpressionWrapper, AliasedExpressionWrapper, OrWrapper, AndWrapper;
var init_expression_wrapper = __esm({
  "node_modules/kysely/dist/esm/expression/expression-wrapper.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_alias_node();
    init_and_node();
    init_identifier_node();
    init_operation_node_source();
    init_or_node();
    init_parens_node();
    init_binary_operation_parser();
    ExpressionWrapper = class _ExpressionWrapper {
      static {
        __name(this, "ExpressionWrapper");
      }
      #node;
      constructor(node) {
        this.#node = node;
      }
      /** @private */
      get expressionType() {
        return void 0;
      }
      as(alias) {
        return new AliasedExpressionWrapper(this, alias);
      }
      or(...args) {
        return new OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
      }
      and(...args) {
        return new AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
      }
      /**
       * Change the output type of the expression.
       *
       * This method call doesn't change the SQL in any way. This methods simply
       * returns a copy of this `ExpressionWrapper` with a new output type.
       */
      $castTo() {
        return new _ExpressionWrapper(this.#node);
      }
      /**
       * Omit null from the expression's type.
       *
       * This function can be useful in cases where you know an expression can't be
       * null, but Kysely is unable to infer it.
       *
       * This method call doesn't change the SQL in any way. This methods simply
       * returns a copy of `this` with a new output type.
       */
      $notNull() {
        return new _ExpressionWrapper(this.#node);
      }
      toOperationNode() {
        return this.#node;
      }
    };
    AliasedExpressionWrapper = class {
      static {
        __name(this, "AliasedExpressionWrapper");
      }
      #expr;
      #alias;
      constructor(expr, alias) {
        this.#expr = expr;
        this.#alias = alias;
      }
      /** @private */
      get expression() {
        return this.#expr;
      }
      /** @private */
      get alias() {
        return this.#alias;
      }
      toOperationNode() {
        return AliasNode.create(this.#expr.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
      }
    };
    OrWrapper = class _OrWrapper {
      static {
        __name(this, "OrWrapper");
      }
      #node;
      constructor(node) {
        this.#node = node;
      }
      /** @private */
      get expressionType() {
        return void 0;
      }
      as(alias) {
        return new AliasedExpressionWrapper(this, alias);
      }
      or(...args) {
        return new _OrWrapper(OrNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
      }
      /**
       * Change the output type of the expression.
       *
       * This method call doesn't change the SQL in any way. This methods simply
       * returns a copy of this `OrWrapper` with a new output type.
       */
      $castTo() {
        return new _OrWrapper(this.#node);
      }
      toOperationNode() {
        return ParensNode.create(this.#node);
      }
    };
    AndWrapper = class _AndWrapper {
      static {
        __name(this, "AndWrapper");
      }
      #node;
      constructor(node) {
        this.#node = node;
      }
      /** @private */
      get expressionType() {
        return void 0;
      }
      as(alias) {
        return new AliasedExpressionWrapper(this, alias);
      }
      and(...args) {
        return new _AndWrapper(AndNode.create(this.#node, parseValueBinaryOperationOrExpression(args)));
      }
      /**
       * Change the output type of the expression.
       *
       * This method call doesn't change the SQL in any way. This methods simply
       * returns a copy of this `AndWrapper` with a new output type.
       */
      $castTo() {
        return new _AndWrapper(this.#node);
      }
      toOperationNode() {
        return ParensNode.create(this.#node);
      }
    };
  }
});

// node_modules/kysely/dist/esm/operation-node/fetch-node.js
var FetchNode;
var init_fetch_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/fetch-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_value_node();
    FetchNode = {
      is(node) {
        return node.kind === "FetchNode";
      },
      create(rowCount, modifier) {
        return {
          kind: "FetchNode",
          rowCount: ValueNode.create(rowCount),
          modifier
        };
      }
    };
  }
});

// node_modules/kysely/dist/esm/parser/fetch-parser.js
function parseFetch(rowCount, modifier) {
  if (!isNumber(rowCount) && !isBigInt(rowCount)) {
    throw new Error(`Invalid fetch row count: ${rowCount}`);
  }
  if (!isFetchModifier(modifier)) {
    throw new Error(`Invalid fetch modifier: ${modifier}`);
  }
  return FetchNode.create(rowCount, modifier);
}
function isFetchModifier(value) {
  return value === "only" || value === "with ties";
}
var init_fetch_parser = __esm({
  "node_modules/kysely/dist/esm/parser/fetch-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_fetch_node();
    init_object_utils();
    __name(parseFetch, "parseFetch");
    __name(isFetchModifier, "isFetchModifier");
  }
});

// node_modules/kysely/dist/esm/query-builder/select-query-builder.js
function createSelectQueryBuilder(props) {
  return new SelectQueryBuilderImpl(props);
}
var SelectQueryBuilderImpl, AliasedSelectQueryBuilderImpl;
var init_select_query_builder = __esm({
  "node_modules/kysely/dist/esm/query-builder/select-query-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_alias_node();
    init_select_modifier_node();
    init_join_parser();
    init_table_parser();
    init_select_parser();
    init_reference_parser();
    init_select_query_node();
    init_query_node();
    init_order_by_parser();
    init_prevent_await();
    init_limit_node();
    init_offset_node();
    init_object_utils();
    init_group_by_parser();
    init_no_result_error();
    init_identifier_node();
    init_set_operation_parser();
    init_binary_operation_parser();
    init_expression_wrapper();
    init_value_parser();
    init_fetch_parser();
    init_top_parser();
    SelectQueryBuilderImpl = class _SelectQueryBuilderImpl {
      static {
        __name(this, "SelectQueryBuilderImpl");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      get expressionType() {
        return void 0;
      }
      get isSelectQueryBuilder() {
        return true;
      }
      where(...args) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
        });
      }
      whereRef(lhs, op, rhs) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithWhere(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
        });
      }
      having(...args) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseValueBinaryOperationOrExpression(args))
        });
      }
      havingRef(lhs, op, rhs) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithHaving(this.#props.queryNode, parseReferentialBinaryOperation(lhs, op, rhs))
        });
      }
      select(selection) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectArg(selection))
        });
      }
      distinctOn(selection) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithDistinctOn(this.#props.queryNode, parseReferenceExpressionOrList(selection))
        });
      }
      modifyFront(modifier) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))
        });
      }
      modifyEnd(modifier) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.createWithExpression(modifier.toOperationNode()))
        });
      }
      distinct() {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithFrontModifier(this.#props.queryNode, SelectModifierNode.create("Distinct"))
        });
      }
      forUpdate(of) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForUpdate", of ? asArray(of).map(parseTable) : void 0))
        });
      }
      forShare(of) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForShare", of ? asArray(of).map(parseTable) : void 0))
        });
      }
      forKeyShare(of) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForKeyShare", of ? asArray(of).map(parseTable) : void 0))
        });
      }
      forNoKeyUpdate(of) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("ForNoKeyUpdate", of ? asArray(of).map(parseTable) : void 0))
        });
      }
      skipLocked() {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("SkipLocked"))
        });
      }
      noWait() {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithEndModifier(this.#props.queryNode, SelectModifierNode.create("NoWait"))
        });
      }
      selectAll(table) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithSelections(this.#props.queryNode, parseSelectAll(table))
        });
      }
      innerJoin(...args) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("InnerJoin", args))
        });
      }
      leftJoin(...args) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("LeftJoin", args))
        });
      }
      rightJoin(...args) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("RightJoin", args))
        });
      }
      fullJoin(...args) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("FullJoin", args))
        });
      }
      innerJoinLateral(...args) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("LateralInnerJoin", args))
        });
      }
      leftJoinLateral(...args) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithJoin(this.#props.queryNode, parseJoin("LateralLeftJoin", args))
        });
      }
      orderBy(...args) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithOrderByItems(this.#props.queryNode, parseOrderBy(args))
        });
      }
      groupBy(groupBy) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithGroupByItems(this.#props.queryNode, parseGroupBy(groupBy))
        });
      }
      limit(limit) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithLimit(this.#props.queryNode, LimitNode.create(parseValueExpression(limit)))
        });
      }
      offset(offset) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithOffset(this.#props.queryNode, OffsetNode.create(parseValueExpression(offset)))
        });
      }
      fetch(rowCount, modifier = "only") {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithFetch(this.#props.queryNode, parseFetch(rowCount, modifier))
        });
      }
      top(expression, modifiers) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithTop(this.#props.queryNode, parseTop(expression, modifiers))
        });
      }
      union(expression) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("union", expression, false))
        });
      }
      unionAll(expression) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("union", expression, true))
        });
      }
      intersect(expression) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("intersect", expression, false))
        });
      }
      intersectAll(expression) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("intersect", expression, true))
        });
      }
      except(expression) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("except", expression, false))
        });
      }
      exceptAll(expression) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithSetOperations(this.#props.queryNode, parseSetOperations("except", expression, true))
        });
      }
      as(alias) {
        return new AliasedSelectQueryBuilderImpl(this, alias);
      }
      clearSelect() {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithoutSelections(this.#props.queryNode)
        });
      }
      clearWhere() {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithoutWhere(this.#props.queryNode)
        });
      }
      clearLimit() {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithoutLimit(this.#props.queryNode)
        });
      }
      clearOffset() {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithoutOffset(this.#props.queryNode)
        });
      }
      clearOrderBy() {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithoutOrderBy(this.#props.queryNode)
        });
      }
      clearGroupBy() {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: SelectQueryNode.cloneWithoutGroupBy(this.#props.queryNode)
        });
      }
      $call(func) {
        return func(this);
      }
      $if(condition, func) {
        if (condition) {
          return func(this);
        }
        return new _SelectQueryBuilderImpl({
          ...this.#props
        });
      }
      $castTo() {
        return new _SelectQueryBuilderImpl(this.#props);
      }
      $narrowType() {
        return new _SelectQueryBuilderImpl(this.#props);
      }
      $assertType() {
        return new _SelectQueryBuilderImpl(this.#props);
      }
      $asTuple() {
        return new ExpressionWrapper(this.toOperationNode());
      }
      withPlugin(plugin) {
        return new _SelectQueryBuilderImpl({
          ...this.#props,
          executor: this.#props.executor.withPlugin(plugin)
        });
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        const compiledQuery = this.compile();
        const result = await this.#props.executor.executeQuery(compiledQuery, this.#props.queryId);
        return result.rows;
      }
      async executeTakeFirst() {
        const [result] = await this.execute();
        return result;
      }
      async executeTakeFirstOrThrow(errorConstructor = NoResultError) {
        const result = await this.executeTakeFirst();
        if (result === void 0) {
          const error = isNoResultErrorConstructor(errorConstructor) ? new errorConstructor(this.toOperationNode()) : errorConstructor(this.toOperationNode());
          throw error;
        }
        return result;
      }
      async *stream(chunkSize = 100) {
        const compiledQuery = this.compile();
        const stream = this.#props.executor.stream(compiledQuery, chunkSize, this.#props.queryId);
        for await (const item of stream) {
          yield* item.rows;
        }
      }
      async explain(format, options) {
        const builder = new _SelectQueryBuilderImpl({
          ...this.#props,
          queryNode: QueryNode.cloneWithExplain(this.#props.queryNode, format, options)
        });
        return await builder.execute();
      }
    };
    preventAwait(SelectQueryBuilderImpl, "don't await SelectQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");
    __name(createSelectQueryBuilder, "createSelectQueryBuilder");
    AliasedSelectQueryBuilderImpl = class {
      static {
        __name(this, "AliasedSelectQueryBuilderImpl");
      }
      #queryBuilder;
      #alias;
      constructor(queryBuilder, alias) {
        this.#queryBuilder = queryBuilder;
        this.#alias = alias;
      }
      get expression() {
        return this.#queryBuilder;
      }
      get alias() {
        return this.#alias;
      }
      get isAliasedSelectQueryBuilder() {
        return true;
      }
      toOperationNode() {
        return AliasNode.create(this.#queryBuilder.toOperationNode(), IdentifierNode.create(this.#alias));
      }
    };
    preventAwait(AliasedSelectQueryBuilderImpl, "don't await AliasedSelectQueryBuilder instances directly. AliasedSelectQueryBuilder should never be executed directly since it's always a part of another query.");
  }
});

// node_modules/kysely/dist/esm/operation-node/aggregate-function-node.js
var AggregateFunctionNode;
var init_aggregate_function_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/aggregate-function-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_where_node();
    init_order_by_node();
    AggregateFunctionNode = freeze({
      is(node) {
        return node.kind === "AggregateFunctionNode";
      },
      create(aggregateFunction, aggregated = []) {
        return freeze({
          kind: "AggregateFunctionNode",
          func: aggregateFunction,
          aggregated
        });
      },
      cloneWithDistinct(aggregateFunctionNode) {
        return freeze({
          ...aggregateFunctionNode,
          distinct: true
        });
      },
      cloneWithOrderBy(aggregateFunctionNode, orderItems) {
        return freeze({
          ...aggregateFunctionNode,
          orderBy: aggregateFunctionNode.orderBy ? OrderByNode.cloneWithItems(aggregateFunctionNode.orderBy, orderItems) : OrderByNode.create(orderItems)
        });
      },
      cloneWithFilter(aggregateFunctionNode, filter) {
        return freeze({
          ...aggregateFunctionNode,
          filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, "And", filter) : WhereNode.create(filter)
        });
      },
      cloneWithOrFilter(aggregateFunctionNode, filter) {
        return freeze({
          ...aggregateFunctionNode,
          filter: aggregateFunctionNode.filter ? WhereNode.cloneWithOperation(aggregateFunctionNode.filter, "Or", filter) : WhereNode.create(filter)
        });
      },
      cloneWithOver(aggregateFunctionNode, over) {
        return freeze({
          ...aggregateFunctionNode,
          over
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/function-node.js
var FunctionNode;
var init_function_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/function-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    FunctionNode = freeze({
      is(node) {
        return node.kind === "FunctionNode";
      },
      create(func, args) {
        return freeze({
          kind: "FunctionNode",
          func,
          arguments: args
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/query-builder/aggregate-function-builder.js
var AggregateFunctionBuilder, AliasedAggregateFunctionBuilder;
var init_aggregate_function_builder = __esm({
  "node_modules/kysely/dist/esm/query-builder/aggregate-function-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_aggregate_function_node();
    init_alias_node();
    init_identifier_node();
    init_prevent_await();
    init_parse_utils();
    init_binary_operation_parser();
    init_order_by_parser();
    AggregateFunctionBuilder = class _AggregateFunctionBuilder {
      static {
        __name(this, "AggregateFunctionBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      /** @private */
      get expressionType() {
        return void 0;
      }
      /**
       * Returns an aliased version of the function.
       *
       * In addition to slapping `as "the_alias"` to the end of the SQL,
       * this method also provides strict typing:
       *
       * ```ts
       * const result = await db
       *   .selectFrom('person')
       *   .select(
       *     (eb) => eb.fn.count<number>('id').as('person_count')
       *   )
       *   .executeTakeFirstOrThrow()
       *
       * // `person_count: number` field exists in the result type.
       * console.log(result.person_count)
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * select count("id") as "person_count"
       * from "person"
       * ```
       */
      as(alias) {
        return new AliasedAggregateFunctionBuilder(this, alias);
      }
      /**
       * Adds a `distinct` clause inside the function.
       *
       * ### Examples
       *
       * ```ts
       * const result = await db
       *   .selectFrom('person')
       *   .select((eb) =>
       *     eb.fn.count<number>('first_name').distinct().as('first_name_count')
       *   )
       *   .executeTakeFirstOrThrow()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * select count(distinct "first_name") as "first_name_count"
       * from "person"
       * ```
       */
      distinct() {
        return new _AggregateFunctionBuilder({
          ...this.#props,
          aggregateFunctionNode: AggregateFunctionNode.cloneWithDistinct(this.#props.aggregateFunctionNode)
        });
      }
      /**
       * Adds an `order by` clause inside the aggregate function.
       *
       * ### Examples
       *
       * ```ts
       * const result = await db
       *   .selectFrom('person')
       *   .innerJoin('pet', 'pet.owner_id', 'person.id')
       *   .select((eb) =>
       *     eb.fn.jsonAgg('pet').orderBy('pet.name').as('person_pets')
       *   )
       *   .executeTakeFirstOrThrow()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * select json_agg("pet" order by "pet"."name") as "person_pets"
       * from "person"
       * inner join "pet" ON "pet"."owner_id" = "person"."id"
       * ```
       */
      orderBy(orderBy, direction) {
        return new _AggregateFunctionBuilder({
          ...this.#props,
          aggregateFunctionNode: AggregateFunctionNode.cloneWithOrderBy(this.#props.aggregateFunctionNode, parseOrderBy([orderBy, direction]))
        });
      }
      filterWhere(...args) {
        return new _AggregateFunctionBuilder({
          ...this.#props,
          aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseValueBinaryOperationOrExpression(args))
        });
      }
      /**
       * Adds a `filter` clause with a nested `where` clause after the function, where
       * both sides of the operator are references to columns.
       *
       * Similar to {@link WhereInterface}'s `whereRef` method.
       *
       * ### Examples
       *
       * Count people with same first and last names versus general public:
       *
       * ```ts
       * const result = await db
       *   .selectFrom('person')
       *   .select((eb) => [
       *     eb.fn
       *       .count<number>('id')
       *       .filterWhereRef('first_name', '=', 'last_name')
       *       .as('repeat_name_count'),
       *     eb.fn.count<number>('id').as('total_count'),
       *   ])
       *   .executeTakeFirstOrThrow()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * select
       *   count("id") filter(where "first_name" = "last_name") as "repeat_name_count",
       *   count("id") as "total_count"
       * from "person"
       * ```
       */
      filterWhereRef(lhs, op, rhs) {
        return new _AggregateFunctionBuilder({
          ...this.#props,
          aggregateFunctionNode: AggregateFunctionNode.cloneWithFilter(this.#props.aggregateFunctionNode, parseReferentialBinaryOperation(lhs, op, rhs))
        });
      }
      /**
       * Adds an `over` clause (window functions) after the function.
       *
       * ### Examples
       *
       * ```ts
       * const result = await db
       *   .selectFrom('person')
       *   .select(
       *     (eb) => eb.fn.avg<number>('age').over().as('average_age')
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * select avg("age") over() as "average_age"
       * from "person"
       * ```
       *
       * Also supports passing a callback that returns an over builder,
       * allowing to add partition by and sort by clauses inside over.
       *
       * ```ts
       * const result = await db
       *   .selectFrom('person')
       *   .select(
       *     (eb) => eb.fn.avg<number>('age').over(
       *       ob => ob.partitionBy('last_name').orderBy('first_name', 'asc')
       *     ).as('average_age')
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * select avg("age") over(partition by "last_name" order by "first_name" asc) as "average_age"
       * from "person"
       * ```
       */
      over(over) {
        const builder = createOverBuilder();
        return new _AggregateFunctionBuilder({
          ...this.#props,
          aggregateFunctionNode: AggregateFunctionNode.cloneWithOver(this.#props.aggregateFunctionNode, (over ? over(builder) : builder).toOperationNode())
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      /**
       * Casts the expression to the given type.
       *
       * This method call doesn't change the SQL in any way. This methods simply
       * returns a copy of this `AggregateFunctionBuilder` with a new output type.
       */
      $castTo() {
        return new _AggregateFunctionBuilder(this.#props);
      }
      /**
       * Omit null from the expression's type.
       *
       * This function can be useful in cases where you know an expression can't be
       * null, but Kysely is unable to infer it.
       *
       * This method call doesn't change the SQL in any way. This methods simply
       * returns a copy of `this` with a new output type.
       */
      $notNull() {
        return new _AggregateFunctionBuilder(this.#props);
      }
      toOperationNode() {
        return this.#props.aggregateFunctionNode;
      }
    };
    preventAwait(AggregateFunctionBuilder, "don't await AggregateFunctionBuilder instances. They are never executed directly and are always just a part of a query.");
    AliasedAggregateFunctionBuilder = class {
      static {
        __name(this, "AliasedAggregateFunctionBuilder");
      }
      #aggregateFunctionBuilder;
      #alias;
      constructor(aggregateFunctionBuilder, alias) {
        this.#aggregateFunctionBuilder = aggregateFunctionBuilder;
        this.#alias = alias;
      }
      /** @private */
      get expression() {
        return this.#aggregateFunctionBuilder;
      }
      /** @private */
      get alias() {
        return this.#alias;
      }
      toOperationNode() {
        return AliasNode.create(this.#aggregateFunctionBuilder.toOperationNode(), IdentifierNode.create(this.#alias));
      }
    };
  }
});

// node_modules/kysely/dist/esm/query-builder/function-module.js
function createFunctionModule() {
  const fn = /* @__PURE__ */ __name((name, args) => {
    return new ExpressionWrapper(FunctionNode.create(name, parseReferenceExpressionOrList(args ?? [])));
  }, "fn");
  const agg = /* @__PURE__ */ __name((name, args) => {
    return new AggregateFunctionBuilder({
      aggregateFunctionNode: AggregateFunctionNode.create(name, args ? parseReferenceExpressionOrList(args) : void 0)
    });
  }, "agg");
  return Object.assign(fn, {
    agg,
    avg(column) {
      return agg("avg", [column]);
    },
    coalesce(...values) {
      return fn("coalesce", values);
    },
    count(column) {
      return agg("count", [column]);
    },
    countAll(table) {
      return new AggregateFunctionBuilder({
        aggregateFunctionNode: AggregateFunctionNode.create("count", parseSelectAll(table))
      });
    },
    max(column) {
      return agg("max", [column]);
    },
    min(column) {
      return agg("min", [column]);
    },
    sum(column) {
      return agg("sum", [column]);
    },
    any(column) {
      return fn("any", [column]);
    },
    jsonAgg(table) {
      return new AggregateFunctionBuilder({
        aggregateFunctionNode: AggregateFunctionNode.create("json_agg", [
          isString(table) ? parseTable(table) : table.toOperationNode()
        ])
      });
    },
    toJson(table) {
      return new ExpressionWrapper(FunctionNode.create("to_json", [
        isString(table) ? parseTable(table) : table.toOperationNode()
      ]));
    }
  });
}
var init_function_module = __esm({
  "node_modules/kysely/dist/esm/query-builder/function-module.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_expression_wrapper();
    init_aggregate_function_node();
    init_function_node();
    init_reference_parser();
    init_select_parser();
    init_aggregate_function_builder();
    init_object_utils();
    init_table_parser();
    __name(createFunctionModule, "createFunctionModule");
  }
});

// node_modules/kysely/dist/esm/operation-node/unary-operation-node.js
var UnaryOperationNode;
var init_unary_operation_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/unary-operation-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    UnaryOperationNode = freeze({
      is(node) {
        return node.kind === "UnaryOperationNode";
      },
      create(operator, operand) {
        return freeze({
          kind: "UnaryOperationNode",
          operator,
          operand
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/parser/unary-operation-parser.js
function parseUnaryOperation(operator, operand) {
  return UnaryOperationNode.create(OperatorNode.create(operator), parseReferenceExpression(operand));
}
var init_unary_operation_parser = __esm({
  "node_modules/kysely/dist/esm/parser/unary-operation-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_operator_node();
    init_unary_operation_node();
    init_reference_parser();
    __name(parseUnaryOperation, "parseUnaryOperation");
  }
});

// node_modules/kysely/dist/esm/operation-node/case-node.js
var CaseNode;
var init_case_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/case-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_when_node();
    CaseNode = freeze({
      is(node) {
        return node.kind === "CaseNode";
      },
      create(value) {
        return freeze({
          kind: "CaseNode",
          value
        });
      },
      cloneWithWhen(caseNode, when) {
        return freeze({
          ...caseNode,
          when: freeze(caseNode.when ? [...caseNode.when, when] : [when])
        });
      },
      cloneWithThen(caseNode, then) {
        return freeze({
          ...caseNode,
          when: caseNode.when ? freeze([
            ...caseNode.when.slice(0, -1),
            WhenNode.cloneWithResult(caseNode.when[caseNode.when.length - 1], then)
          ]) : void 0
        });
      },
      cloneWith(caseNode, props) {
        return freeze({
          ...caseNode,
          ...props
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/query-builder/case-builder.js
var CaseBuilder, CaseThenBuilder, CaseWhenBuilder, CaseEndBuilder;
var init_case_builder = __esm({
  "node_modules/kysely/dist/esm/query-builder/case-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_expression_wrapper();
    init_object_utils();
    init_case_node();
    init_when_node();
    init_binary_operation_parser();
    init_value_parser();
    CaseBuilder = class {
      static {
        __name(this, "CaseBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      when(...args) {
        return new CaseThenBuilder({
          ...this.#props,
          node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))
        });
      }
    };
    CaseThenBuilder = class {
      static {
        __name(this, "CaseThenBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      then(valueExpression) {
        return new CaseWhenBuilder({
          ...this.#props,
          node: CaseNode.cloneWithThen(this.#props.node, isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression))
        });
      }
    };
    CaseWhenBuilder = class {
      static {
        __name(this, "CaseWhenBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      when(...args) {
        return new CaseThenBuilder({
          ...this.#props,
          node: CaseNode.cloneWithWhen(this.#props.node, WhenNode.create(parseValueBinaryOperationOrExpression(args)))
        });
      }
      else(valueExpression) {
        return new CaseEndBuilder({
          ...this.#props,
          node: CaseNode.cloneWith(this.#props.node, {
            else: isSafeImmediateValue(valueExpression) ? parseSafeImmediateValue(valueExpression) : parseValueExpression(valueExpression)
          })
        });
      }
      end() {
        return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));
      }
      endCase() {
        return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));
      }
    };
    CaseEndBuilder = class {
      static {
        __name(this, "CaseEndBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      end() {
        return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: false }));
      }
      endCase() {
        return new ExpressionWrapper(CaseNode.cloneWith(this.#props.node, { isStatement: true }));
      }
    };
  }
});

// node_modules/kysely/dist/esm/operation-node/json-path-leg-node.js
var JSONPathLegNode;
var init_json_path_leg_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/json-path-leg-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    JSONPathLegNode = freeze({
      is(node) {
        return node.kind === "JSONPathLegNode";
      },
      create(type, value) {
        return freeze({
          kind: "JSONPathLegNode",
          type,
          value
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/query-builder/json-path-builder.js
var JSONPathBuilder, TraversedJSONPathBuilder, AliasedJSONPathBuilder;
var init_json_path_builder = __esm({
  "node_modules/kysely/dist/esm/query-builder/json-path-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_alias_node();
    init_identifier_node();
    init_json_operator_chain_node();
    init_json_path_leg_node();
    init_json_path_node();
    init_json_reference_node();
    init_operation_node_source();
    init_value_node();
    JSONPathBuilder = class {
      static {
        __name(this, "JSONPathBuilder");
      }
      #node;
      constructor(node) {
        this.#node = node;
      }
      /**
       * Access an element of a JSON array in a specific location.
       *
       * Since there's no guarantee an element exists in the given array location, the
       * resulting type is always nullable. If you're sure the element exists, you
       * should use {@link SelectQueryBuilder.$assertType} to narrow the type safely.
       *
       * See also {@link key} to access properties of JSON objects.
       *
       * ### Examples
       *
       * ```ts
       * await db.selectFrom('person')
       *   .select(eb =>
       *     eb.ref('nicknames', '->').at(0).as('primary_nickname')
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * select "nicknames"->0 as "primary_nickname" from "person"
       *```
       *
       * Combined with {@link key}:
       *
       * ```ts
       * db.selectFrom('person').select(eb =>
       *   eb.ref('experience', '->').at(0).key('role').as('first_role')
       * )
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * select "experience"->0->'role' as "first_role" from "person"
       * ```
       *
       * You can use `'last'` to access the last element of the array in MySQL:
       *
       * ```ts
       * db.selectFrom('person').select(eb =>
       *   eb.ref('nicknames', '->$').at('last').as('last_nickname')
       * )
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * select `nicknames`->'$[last]' as `last_nickname` from `person`
       * ```
       *
       * Or `'#-1'` in SQLite:
       *
       * ```ts
       * db.selectFrom('person').select(eb =>
       *   eb.ref('nicknames', '->>$').at('#-1').as('last_nickname')
       * )
       * ```
       *
       * The generated SQL (SQLite):
       *
       * ```sql
       * select "nicknames"->>'$[#-1]' as `last_nickname` from `person`
       * ```
       */
      at(index) {
        return this.#createBuilderWithPathLeg("ArrayLocation", index);
      }
      /**
       * Access a property of a JSON object.
       *
       * If a field is optional, the resulting type will be nullable.
       *
       * See also {@link at} to access elements of JSON arrays.
       *
       * ### Examples
       *
       * ```ts
       * db.selectFrom('person').select(eb =>
       *   eb.ref('address', '->').key('city').as('city')
       * )
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * select "address"->'city' as "city" from "person"
       * ```
       *
       * Going deeper:
       *
       * ```ts
       * db.selectFrom('person').select(eb =>
       *   eb.ref('profile', '->$').key('website').key('url').as('website_url')
       * )
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * select `profile`->'$.website.url' as `website_url` from `person`
       * ```
       *
       * Combined with {@link at}:
       *
       * ```ts
       * db.selectFrom('person').select(eb =>
       *   eb.ref('profile', '->').key('addresses').at(0).key('city').as('city')
       * )
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * select "profile"->'addresses'->0->'city' as "city" from "person"
       * ```
       */
      key(key) {
        return this.#createBuilderWithPathLeg("Member", key);
      }
      #createBuilderWithPathLeg(legType, value) {
        if (JSONReferenceNode.is(this.#node)) {
          return new TraversedJSONPathBuilder(JSONReferenceNode.cloneWithTraversal(this.#node, JSONPathNode.is(this.#node.traversal) ? JSONPathNode.cloneWithLeg(this.#node.traversal, JSONPathLegNode.create(legType, value)) : JSONOperatorChainNode.cloneWithValue(this.#node.traversal, ValueNode.createImmediate(value))));
        }
        return new TraversedJSONPathBuilder(JSONPathNode.cloneWithLeg(this.#node, JSONPathLegNode.create(legType, value)));
      }
    };
    TraversedJSONPathBuilder = class _TraversedJSONPathBuilder extends JSONPathBuilder {
      static {
        __name(this, "TraversedJSONPathBuilder");
      }
      #node;
      constructor(node) {
        super(node);
        this.#node = node;
      }
      /** @private */
      get expressionType() {
        return void 0;
      }
      as(alias) {
        return new AliasedJSONPathBuilder(this, alias);
      }
      /**
       * Change the output type of the json path.
       *
       * This method call doesn't change the SQL in any way. This methods simply
       * returns a copy of this `JSONPathBuilder` with a new output type.
       */
      $castTo() {
        return new _TraversedJSONPathBuilder(this.#node);
      }
      $notNull() {
        return new _TraversedJSONPathBuilder(this.#node);
      }
      toOperationNode() {
        return this.#node;
      }
    };
    AliasedJSONPathBuilder = class {
      static {
        __name(this, "AliasedJSONPathBuilder");
      }
      #jsonPath;
      #alias;
      constructor(jsonPath, alias) {
        this.#jsonPath = jsonPath;
        this.#alias = alias;
      }
      /** @private */
      get expression() {
        return this.#jsonPath;
      }
      /** @private */
      get alias() {
        return this.#alias;
      }
      toOperationNode() {
        return AliasNode.create(this.#jsonPath.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
      }
    };
  }
});

// node_modules/kysely/dist/esm/operation-node/tuple-node.js
var TupleNode;
var init_tuple_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/tuple-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    TupleNode = freeze({
      is(node) {
        return node.kind === "TupleNode";
      },
      create(values) {
        return freeze({
          kind: "TupleNode",
          values: freeze(values)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/data-type-node.js
function isColumnDataType(dataType) {
  if (SIMPLE_COLUMN_DATA_TYPES.includes(dataType)) {
    return true;
  }
  if (COLUMN_DATA_TYPE_REGEX.some((r) => r.test(dataType))) {
    return true;
  }
  return false;
}
var SIMPLE_COLUMN_DATA_TYPES, COLUMN_DATA_TYPE_REGEX, DataTypeNode;
var init_data_type_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/data-type-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    SIMPLE_COLUMN_DATA_TYPES = [
      "varchar",
      "char",
      "text",
      "integer",
      "int2",
      "int4",
      "int8",
      "smallint",
      "bigint",
      "boolean",
      "real",
      "double precision",
      "float4",
      "float8",
      "decimal",
      "numeric",
      "binary",
      "bytea",
      "date",
      "datetime",
      "time",
      "timetz",
      "timestamp",
      "timestamptz",
      "serial",
      "bigserial",
      "uuid",
      "json",
      "jsonb",
      "blob",
      "varbinary",
      "int4range",
      "int4multirange",
      "int8range",
      "int8multirange",
      "numrange",
      "nummultirange",
      "tsrange",
      "tsmultirange",
      "tstzrange",
      "tstzmultirange",
      "daterange",
      "datemultirange"
    ];
    COLUMN_DATA_TYPE_REGEX = [
      /^varchar\(\d+\)$/,
      /^char\(\d+\)$/,
      /^decimal\(\d+, \d+\)$/,
      /^numeric\(\d+, \d+\)$/,
      /^binary\(\d+\)$/,
      /^datetime\(\d+\)$/,
      /^time\(\d+\)$/,
      /^timetz\(\d+\)$/,
      /^timestamp\(\d+\)$/,
      /^timestamptz\(\d+\)$/,
      /^varbinary\(\d+\)$/
    ];
    DataTypeNode = freeze({
      is(node) {
        return node.kind === "DataTypeNode";
      },
      create(dataType) {
        return freeze({
          kind: "DataTypeNode",
          dataType
        });
      }
    });
    __name(isColumnDataType, "isColumnDataType");
  }
});

// node_modules/kysely/dist/esm/parser/data-type-parser.js
function parseDataTypeExpression(dataType) {
  if (isOperationNodeSource(dataType)) {
    return dataType.toOperationNode();
  }
  if (isColumnDataType(dataType)) {
    return DataTypeNode.create(dataType);
  }
  throw new Error(`invalid column data type ${JSON.stringify(dataType)}`);
}
var init_data_type_parser = __esm({
  "node_modules/kysely/dist/esm/parser/data-type-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_data_type_node();
    init_operation_node_source();
    __name(parseDataTypeExpression, "parseDataTypeExpression");
  }
});

// node_modules/kysely/dist/esm/operation-node/cast-node.js
var CastNode;
var init_cast_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/cast-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    CastNode = freeze({
      is(node) {
        return node.kind === "CastNode";
      },
      create(expression, dataType) {
        return freeze({
          kind: "CastNode",
          expression,
          dataType
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/expression/expression-builder.js
function createExpressionBuilder(executor = NOOP_QUERY_EXECUTOR) {
  function binary(lhs, op, rhs) {
    return new ExpressionWrapper(parseValueBinaryOperation(lhs, op, rhs));
  }
  __name(binary, "binary");
  function unary(op, expr) {
    return new ExpressionWrapper(parseUnaryOperation(op, expr));
  }
  __name(unary, "unary");
  const eb = Object.assign(binary, {
    fn: void 0,
    eb: void 0,
    selectFrom(table) {
      return createSelectQueryBuilder({
        queryId: createQueryId(),
        executor,
        queryNode: SelectQueryNode.createFrom(parseTableExpressionOrList(table))
      });
    },
    case(reference) {
      return new CaseBuilder({
        node: CaseNode.create(isUndefined(reference) ? void 0 : parseReferenceExpression(reference))
      });
    },
    ref(reference, op) {
      if (isUndefined(op)) {
        return new ExpressionWrapper(parseStringReference(reference));
      }
      return new JSONPathBuilder(parseJSONReference(reference, op));
    },
    jsonPath() {
      return new JSONPathBuilder(JSONPathNode.create());
    },
    table(table) {
      return new ExpressionWrapper(parseTable(table));
    },
    val(value) {
      return new ExpressionWrapper(parseValueExpression(value));
    },
    refTuple(...values) {
      return new ExpressionWrapper(TupleNode.create(values.map(parseReferenceExpression)));
    },
    tuple(...values) {
      return new ExpressionWrapper(TupleNode.create(values.map(parseValueExpression)));
    },
    lit(value) {
      return new ExpressionWrapper(parseSafeImmediateValue(value));
    },
    unary,
    not(expr) {
      return unary("not", expr);
    },
    exists(expr) {
      return unary("exists", expr);
    },
    neg(expr) {
      return unary("-", expr);
    },
    between(expr, start, end) {
      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create("between"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
    },
    betweenSymmetric(expr, start, end) {
      return new ExpressionWrapper(BinaryOperationNode.create(parseReferenceExpression(expr), OperatorNode.create("between symmetric"), AndNode.create(parseValueExpression(start), parseValueExpression(end))));
    },
    and(exprs) {
      if (isReadonlyArray(exprs)) {
        return new ExpressionWrapper(parseFilterList(exprs, "and"));
      }
      return new ExpressionWrapper(parseFilterObject(exprs, "and"));
    },
    or(exprs) {
      if (isReadonlyArray(exprs)) {
        return new ExpressionWrapper(parseFilterList(exprs, "or"));
      }
      return new ExpressionWrapper(parseFilterObject(exprs, "or"));
    },
    parens(...args) {
      const node = parseValueBinaryOperationOrExpression(args);
      if (ParensNode.is(node)) {
        return new ExpressionWrapper(node);
      } else {
        return new ExpressionWrapper(ParensNode.create(node));
      }
    },
    cast(expr, dataType) {
      return new ExpressionWrapper(CastNode.create(parseReferenceExpression(expr), parseDataTypeExpression(dataType)));
    },
    withSchema(schema) {
      return createExpressionBuilder(executor.withPluginAtFront(new WithSchemaPlugin(schema)));
    }
  });
  eb.fn = createFunctionModule();
  eb.eb = eb;
  return eb;
}
function expressionBuilder(_) {
  return createExpressionBuilder();
}
var init_expression_builder = __esm({
  "node_modules/kysely/dist/esm/expression/expression-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_select_query_builder();
    init_select_query_node();
    init_table_parser();
    init_with_schema_plugin();
    init_query_id();
    init_function_module();
    init_reference_parser();
    init_binary_operation_parser();
    init_parens_node();
    init_expression_wrapper();
    init_operator_node();
    init_unary_operation_parser();
    init_value_parser();
    init_noop_query_executor();
    init_case_builder();
    init_case_node();
    init_object_utils();
    init_json_path_builder();
    init_binary_operation_node();
    init_and_node();
    init_tuple_node();
    init_json_path_node();
    init_data_type_parser();
    init_cast_node();
    __name(createExpressionBuilder, "createExpressionBuilder");
    __name(expressionBuilder, "expressionBuilder");
  }
});

// node_modules/kysely/dist/esm/parser/expression-parser.js
function parseExpression(exp) {
  if (isOperationNodeSource(exp)) {
    return exp.toOperationNode();
  } else if (isFunction(exp)) {
    return exp(expressionBuilder()).toOperationNode();
  }
  throw new Error(`invalid expression: ${JSON.stringify(exp)}`);
}
function parseAliasedExpression(exp) {
  if (isOperationNodeSource(exp)) {
    return exp.toOperationNode();
  } else if (isFunction(exp)) {
    return exp(expressionBuilder()).toOperationNode();
  }
  throw new Error(`invalid aliased expression: ${JSON.stringify(exp)}`);
}
function isExpressionOrFactory(obj) {
  return isExpression(obj) || isAliasedExpression(obj) || isFunction(obj);
}
var init_expression_parser = __esm({
  "node_modules/kysely/dist/esm/parser/expression-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_expression();
    init_operation_node_source();
    init_expression_builder();
    init_object_utils();
    __name(parseExpression, "parseExpression");
    __name(parseAliasedExpression, "parseAliasedExpression");
    __name(isExpressionOrFactory, "isExpressionOrFactory");
  }
});

// node_modules/kysely/dist/esm/parser/table-parser.js
function parseTableExpressionOrList(table) {
  if (isReadonlyArray(table)) {
    return table.map((it) => parseTableExpression(it));
  } else {
    return [parseTableExpression(table)];
  }
}
function parseTableExpression(table) {
  if (isString(table)) {
    return parseAliasedTable(table);
  } else {
    return parseAliasedExpression(table);
  }
}
function parseAliasedTable(from) {
  const ALIAS_SEPARATOR = " as ";
  if (from.includes(ALIAS_SEPARATOR)) {
    const [table, alias] = from.split(ALIAS_SEPARATOR).map(trim2);
    return AliasNode.create(parseTable(table), IdentifierNode.create(alias));
  } else {
    return parseTable(from);
  }
}
function parseTable(from) {
  const SCHEMA_SEPARATOR = ".";
  if (from.includes(SCHEMA_SEPARATOR)) {
    const [schema, table] = from.split(SCHEMA_SEPARATOR).map(trim2);
    return TableNode.createWithSchema(schema, table);
  } else {
    return TableNode.create(from);
  }
}
function trim2(str) {
  return str.trim();
}
var init_table_parser = __esm({
  "node_modules/kysely/dist/esm/parser/table-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_alias_node();
    init_table_node();
    init_expression_parser();
    init_identifier_node();
    __name(parseTableExpressionOrList, "parseTableExpressionOrList");
    __name(parseTableExpression, "parseTableExpression");
    __name(parseAliasedTable, "parseAliasedTable");
    __name(parseTable, "parseTable");
    __name(trim2, "trim");
  }
});

// node_modules/kysely/dist/esm/operation-node/add-column-node.js
var AddColumnNode;
var init_add_column_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/add-column-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    AddColumnNode = freeze({
      is(node) {
        return node.kind === "AddColumnNode";
      },
      create(column) {
        return freeze({
          kind: "AddColumnNode",
          column
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/column-definition-node.js
var ColumnDefinitionNode;
var init_column_definition_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/column-definition-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_column_node();
    ColumnDefinitionNode = freeze({
      is(node) {
        return node.kind === "ColumnDefinitionNode";
      },
      create(column, dataType) {
        return freeze({
          kind: "ColumnDefinitionNode",
          column: ColumnNode.create(column),
          dataType
        });
      },
      cloneWithFrontModifier(node, modifier) {
        return freeze({
          ...node,
          frontModifiers: node.frontModifiers ? freeze([...node.frontModifiers, modifier]) : [modifier]
        });
      },
      cloneWithEndModifier(node, modifier) {
        return freeze({
          ...node,
          endModifiers: node.endModifiers ? freeze([...node.endModifiers, modifier]) : [modifier]
        });
      },
      cloneWith(node, props) {
        return freeze({
          ...node,
          ...props
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/drop-column-node.js
var DropColumnNode;
var init_drop_column_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/drop-column-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_column_node();
    DropColumnNode = freeze({
      is(node) {
        return node.kind === "DropColumnNode";
      },
      create(column) {
        return freeze({
          kind: "DropColumnNode",
          column: ColumnNode.create(column)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/rename-column-node.js
var RenameColumnNode;
var init_rename_column_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/rename-column-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_column_node();
    RenameColumnNode = freeze({
      is(node) {
        return node.kind === "RenameColumnNode";
      },
      create(column, newColumn) {
        return freeze({
          kind: "RenameColumnNode",
          column: ColumnNode.create(column),
          renameTo: ColumnNode.create(newColumn)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/check-constraint-node.js
var CheckConstraintNode;
var init_check_constraint_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/check-constraint-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_identifier_node();
    CheckConstraintNode = freeze({
      is(node) {
        return node.kind === "CheckConstraintNode";
      },
      create(expression, constraintName) {
        return freeze({
          kind: "CheckConstraintNode",
          expression,
          name: constraintName ? IdentifierNode.create(constraintName) : void 0
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/references-node.js
var ON_MODIFY_FOREIGN_ACTIONS, ReferencesNode;
var init_references_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/references-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    ON_MODIFY_FOREIGN_ACTIONS = [
      "no action",
      "restrict",
      "cascade",
      "set null",
      "set default"
    ];
    ReferencesNode = freeze({
      is(node) {
        return node.kind === "ReferencesNode";
      },
      create(table, columns) {
        return freeze({
          kind: "ReferencesNode",
          table,
          columns: freeze([...columns])
        });
      },
      cloneWithOnDelete(references, onDelete) {
        return freeze({
          ...references,
          onDelete
        });
      },
      cloneWithOnUpdate(references, onUpdate) {
        return freeze({
          ...references,
          onUpdate
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/parser/default-value-parser.js
function parseDefaultValueExpression(value) {
  return isOperationNodeSource(value) ? value.toOperationNode() : ValueNode.createImmediate(value);
}
var init_default_value_parser = __esm({
  "node_modules/kysely/dist/esm/parser/default-value-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_operation_node_source();
    init_value_node();
    __name(parseDefaultValueExpression, "parseDefaultValueExpression");
  }
});

// node_modules/kysely/dist/esm/operation-node/generated-node.js
var GeneratedNode;
var init_generated_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/generated-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    GeneratedNode = freeze({
      is(node) {
        return node.kind === "GeneratedNode";
      },
      create(params) {
        return freeze({
          kind: "GeneratedNode",
          ...params
        });
      },
      createWithExpression(expression) {
        return freeze({
          kind: "GeneratedNode",
          always: true,
          expression
        });
      },
      cloneWith(node, params) {
        return freeze({
          ...node,
          ...params
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/default-value-node.js
var DefaultValueNode;
var init_default_value_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/default-value-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    DefaultValueNode = freeze({
      is(node) {
        return node.kind === "DefaultValueNode";
      },
      create(defaultValue) {
        return freeze({
          kind: "DefaultValueNode",
          defaultValue
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/parser/on-modify-action-parser.js
function parseOnModifyForeignAction(action) {
  if (ON_MODIFY_FOREIGN_ACTIONS.includes(action)) {
    return action;
  }
  throw new Error(`invalid OnModifyForeignAction ${action}`);
}
var init_on_modify_action_parser = __esm({
  "node_modules/kysely/dist/esm/parser/on-modify-action-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_references_node();
    __name(parseOnModifyForeignAction, "parseOnModifyForeignAction");
  }
});

// node_modules/kysely/dist/esm/schema/column-definition-builder.js
var ColumnDefinitionBuilder;
var init_column_definition_builder = __esm({
  "node_modules/kysely/dist/esm/schema/column-definition-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_check_constraint_node();
    init_references_node();
    init_select_all_node();
    init_reference_parser();
    init_prevent_await();
    init_column_definition_node();
    init_default_value_parser();
    init_generated_node();
    init_default_value_node();
    init_on_modify_action_parser();
    ColumnDefinitionBuilder = class _ColumnDefinitionBuilder {
      static {
        __name(this, "ColumnDefinitionBuilder");
      }
      #node;
      constructor(node) {
        this.#node = node;
      }
      /**
       * Adds `auto_increment` or `autoincrement` to the column definition
       * depending on the dialect.
       *
       * Some dialects like PostgreSQL don't support this. On PostgreSQL
       * you can use the `serial` or `bigserial` data type instead.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('person')
       *   .addColumn('id', 'integer', col => col.autoIncrement().primaryKey())
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * create table `person` (
       *   `id` integer primary key auto_increment
       * )
       * ```
       */
      autoIncrement() {
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { autoIncrement: true }));
      }
      /**
       * Makes the column an identity column.
       *
       * This only works on some dialects like MS SQL Server (MSSQL).
       *
       * For PostgreSQL's `generated always as identity` use {@link generatedAlwaysAsIdentity}.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('person')
       *   .addColumn('id', 'integer', col => col.identity().primaryKey())
       *   .execute()
       * ```
       *
       * The generated SQL (MSSQL):
       *
       * ```sql
       * create table "person" (
       *   "id" integer identity primary key
       * )
       * ```
       */
      identity() {
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { identity: true }));
      }
      /**
       * Makes the column the primary key.
       *
       * If you want to specify a composite primary key use the
       * {@link CreateTableBuilder.addPrimaryKeyConstraint} method.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('person')
       *   .addColumn('id', 'integer', col => col.primaryKey())
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * create table `person` (
       *   `id` integer primary key
       * )
       */
      primaryKey() {
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { primaryKey: true }));
      }
      /**
       * Adds a foreign key constraint for the column.
       *
       * If your database engine doesn't support foreign key constraints in the
       * column definition (like MySQL 5) you need to call the table level
       * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('pet')
       *   .addColumn('owner_id', 'integer', (col) => col.references('person.id'))
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * create table "pet" (
       *   "owner_id" integer references "person" ("id")
       * )
       * ```
       */
      references(ref) {
        const references = parseStringReference(ref);
        if (!references.table || SelectAllNode.is(references.column)) {
          throw new Error(`invalid call references('${ref}'). The reference must have format table.column or schema.table.column`);
        }
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
          references: ReferencesNode.create(references.table, [
            references.column
          ])
        }));
      }
      /**
       * Adds an `on delete` constraint for the foreign key column.
       *
       * If your database engine doesn't support foreign key constraints in the
       * column definition (like MySQL 5) you need to call the table level
       * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('pet')
       *   .addColumn(
       *     'owner_id',
       *     'integer',
       *     (col) => col.references('person.id').onDelete('cascade')
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * create table "pet" (
       *   "owner_id" integer references "person" ("id") on delete cascade
       * )
       * ```
       */
      onDelete(onDelete) {
        if (!this.#node.references) {
          throw new Error("on delete constraint can only be added for foreign keys");
        }
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
          references: ReferencesNode.cloneWithOnDelete(this.#node.references, parseOnModifyForeignAction(onDelete))
        }));
      }
      /**
       * Adds an `on update` constraint for the foreign key column.
       *
       * If your database engine doesn't support foreign key constraints in the
       * column definition (like MySQL 5) you need to call the table level
       * {@link CreateTableBuilder.addForeignKeyConstraint} method instead.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('pet')
       *   .addColumn(
       *     'owner_id',
       *     'integer',
       *     (col) => col.references('person.id').onUpdate('cascade')
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * create table "pet" (
       *   "owner_id" integer references "person" ("id") on update cascade
       * )
       * ```
       */
      onUpdate(onUpdate) {
        if (!this.#node.references) {
          throw new Error("on update constraint can only be added for foreign keys");
        }
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
          references: ReferencesNode.cloneWithOnUpdate(this.#node.references, parseOnModifyForeignAction(onUpdate))
        }));
      }
      /**
       * Adds a unique constraint for the column.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('person')
       *   .addColumn('email', 'varchar(255)', col => col.unique())
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * create table `person` (
       *   `email` varchar(255) unique
       * )
       * ```
       */
      unique() {
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unique: true }));
      }
      /**
       * Adds a `not null` constraint for the column.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('person')
       *   .addColumn('first_name', 'varchar(255)', col => col.notNull())
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * create table `person` (
       *   `first_name` varchar(255) not null
       * )
       * ```
       */
      notNull() {
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { notNull: true }));
      }
      /**
       * Adds a `unsigned` modifier for the column.
       *
       * This only works on some dialects like MySQL.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('person')
       *   .addColumn('age', 'integer', col => col.unsigned())
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * create table `person` (
       *   `age` integer unsigned
       * )
       * ```
       */
      unsigned() {
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unsigned: true }));
      }
      /**
       * Adds a default value constraint for the column.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('pet')
       *   .addColumn('number_of_legs', 'integer', (col) => col.defaultTo(4))
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * create table `pet` (
       *   `number_of_legs` integer default 4
       * )
       * ```
       *
       * Values passed to `defaultTo` are interpreted as value literals by default. You can define
       * an arbitrary SQL expression using the {@link sql} template tag:
       *
       * ```ts
       * import {sql } from 'kysely'
       *
       * await db.schema
       *   .createTable('pet')
       *   .addColumn(
       *     'created_at',
       *     'timestamp',
       *     (col) => col.defaultTo(sql`CURRENT_TIMESTAMP`)
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * create table `pet` (
       *   `created_at` timestamp default CURRENT_TIMESTAMP
       * )
       * ```
       */
      defaultTo(value) {
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
          defaultTo: DefaultValueNode.create(parseDefaultValueExpression(value))
        }));
      }
      /**
       * Adds a check constraint for the column.
       *
       * ### Examples
       *
       * ```ts
       * import {sql } from 'kysely'
       *
       * await db.schema
       *   .createTable('pet')
       *   .addColumn('number_of_legs', 'integer', (col) =>
       *     col.check(sql`number_of_legs < 5`)
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * create table `pet` (
       *   `number_of_legs` integer check (number_of_legs < 5)
       * )
       * ```
       */
      check(expression) {
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
          check: CheckConstraintNode.create(expression.toOperationNode())
        }));
      }
      /**
       * Makes the column a generated column using a `generated always as` statement.
       *
       * ### Examples
       *
       * ```ts
       * import {sql } from 'kysely'
       *
       * await db.schema
       *   .createTable('person')
       *   .addColumn('full_name', 'varchar(255)',
       *     (col) => col.generatedAlwaysAs(sql`concat(first_name, ' ', last_name)`)
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * create table `person` (
       *   `full_name` varchar(255) generated always as (concat(first_name, ' ', last_name))
       * )
       * ```
       */
      generatedAlwaysAs(expression) {
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
          generated: GeneratedNode.createWithExpression(expression.toOperationNode())
        }));
      }
      /**
       * Adds the `generated always as identity` specifier.
       *
       * This only works on some dialects like PostgreSQL.
       *
       * For MS SQL Server (MSSQL)'s identity column use {@link identity}.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('person')
       *   .addColumn('id', 'integer', col => col.generatedAlwaysAsIdentity().primaryKey())
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * create table "person" (
       *   "id" integer generated always as identity primary key
       * )
       * ```
       */
      generatedAlwaysAsIdentity() {
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
          generated: GeneratedNode.create({ identity: true, always: true })
        }));
      }
      /**
       * Adds the `generated by default as identity` specifier on supported dialects.
       *
       * This only works on some dialects like PostgreSQL.
       *
       * For MS SQL Server (MSSQL)'s identity column use {@link identity}.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('person')
       *   .addColumn('id', 'integer', col => col.generatedByDefaultAsIdentity().primaryKey())
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * create table "person" (
       *   "id" integer generated by default as identity primary key
       * )
       * ```
       */
      generatedByDefaultAsIdentity() {
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
          generated: GeneratedNode.create({ identity: true, byDefault: true })
        }));
      }
      /**
       * Makes a generated column stored instead of virtual. This method can only
       * be used with {@link generatedAlwaysAs}
       *
       * ### Examples
       *
       * ```ts
       * import { sql } from 'kysely'
       *
       * await db.schema
       *   .createTable('person')
       *   .addColumn('full_name', 'varchar(255)', (col) => col
       *     .generatedAlwaysAs(sql`concat(first_name, ' ', last_name)`)
       *     .stored()
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * create table `person` (
       *   `full_name` varchar(255) generated always as (concat(first_name, ' ', last_name)) stored
       * )
       * ```
       */
      stored() {
        if (!this.#node.generated) {
          throw new Error("stored() can only be called after generatedAlwaysAs");
        }
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
          generated: GeneratedNode.cloneWith(this.#node.generated, {
            stored: true
          })
        }));
      }
      /**
       * This can be used to add any additional SQL right after the column's data type.
       *
       * ### Examples
       *
       * ```ts
       * import { sql } from 'kysely'
       *
       * await db.schema
       *   .createTable('person')
       *   .addColumn('id', 'integer', col => col.primaryKey())
       *   .addColumn(
       *     'first_name',
       *     'varchar(36)',
       *     (col) => col.modifyFront(sql`collate utf8mb4_general_ci`).notNull()
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * create table `person` (
       *   `id` integer primary key,
       *   `first_name` varchar(36) collate utf8mb4_general_ci not null
       * )
       * ```
       */
      modifyFront(modifier) {
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithFrontModifier(this.#node, modifier.toOperationNode()));
      }
      /**
       * Adds `nulls not distinct` specifier.
       * Should be used with `unique` constraint.
       *
       * This only works on some dialects like PostgreSQL.
       *
       * ### Examples
       *
       * ```ts
       * db.schema
       *   .createTable('person')
       *   .addColumn('id', 'integer', col => col.primaryKey())
       *   .addColumn('first_name', 'varchar(30)', col => col.unique().nullsNotDistinct())
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * create table "person" (
       *   "id" integer primary key,
       *   "first_name" varchar(30) unique nulls not distinct
       * )
       * ```
       */
      nullsNotDistinct() {
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { nullsNotDistinct: true }));
      }
      /**
       * Adds `if not exists` specifier. This only works for PostgreSQL.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .alterTable('person')
       *   .addColumn('email', 'varchar(255)', col => col.unique().ifNotExists())
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * alter table "person" add column if not exists "email" varchar(255) unique
       * ```
       */
      ifNotExists() {
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { ifNotExists: true }));
      }
      /**
       * This can be used to add any additional SQL to the end of the column definition.
       *
       * ### Examples
       *
       * ```ts
       * import { sql } from 'kysely'
       *
       * await db.schema
       *   .createTable('person')
       *   .addColumn('id', 'integer', col => col.primaryKey())
       *   .addColumn(
       *     'age',
       *     'integer',
       *     col => col.unsigned()
       *       .notNull()
       *       .modifyEnd(sql`comment ${sql.lit('it is not polite to ask a woman her age')}`)
       *   )
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * create table `person` (
       *   `id` integer primary key,
       *   `age` integer unsigned not null comment 'it is not polite to ask a woman her age'
       * )
       * ```
       */
      modifyEnd(modifier) {
        return new _ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWithEndModifier(this.#node, modifier.toOperationNode()));
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#node;
      }
    };
    preventAwait(ColumnDefinitionBuilder, "don't await ColumnDefinitionBuilder instances directly.");
  }
});

// node_modules/kysely/dist/esm/operation-node/modify-column-node.js
var ModifyColumnNode;
var init_modify_column_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/modify-column-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    ModifyColumnNode = freeze({
      is(node) {
        return node.kind === "ModifyColumnNode";
      },
      create(column) {
        return freeze({
          kind: "ModifyColumnNode",
          column
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/foreign-key-constraint-node.js
var ForeignKeyConstraintNode;
var init_foreign_key_constraint_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/foreign-key-constraint-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_identifier_node();
    init_references_node();
    ForeignKeyConstraintNode = freeze({
      is(node) {
        return node.kind === "ForeignKeyConstraintNode";
      },
      create(sourceColumns, targetTable, targetColumns, constraintName) {
        return freeze({
          kind: "ForeignKeyConstraintNode",
          columns: sourceColumns,
          references: ReferencesNode.create(targetTable, targetColumns),
          name: constraintName ? IdentifierNode.create(constraintName) : void 0
        });
      },
      cloneWith(node, props) {
        return freeze({
          ...node,
          ...props
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/schema/foreign-key-constraint-builder.js
var ForeignKeyConstraintBuilder;
var init_foreign_key_constraint_builder = __esm({
  "node_modules/kysely/dist/esm/schema/foreign-key-constraint-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_foreign_key_constraint_node();
    init_on_modify_action_parser();
    init_prevent_await();
    ForeignKeyConstraintBuilder = class _ForeignKeyConstraintBuilder {
      static {
        __name(this, "ForeignKeyConstraintBuilder");
      }
      #node;
      constructor(node) {
        this.#node = node;
      }
      onDelete(onDelete) {
        return new _ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
          onDelete: parseOnModifyForeignAction(onDelete)
        }));
      }
      onUpdate(onUpdate) {
        return new _ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.cloneWith(this.#node, {
          onUpdate: parseOnModifyForeignAction(onUpdate)
        }));
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#node;
      }
    };
    preventAwait(ForeignKeyConstraintBuilder, "don't await ForeignKeyConstraintBuilder instances directly.");
  }
});

// node_modules/kysely/dist/esm/operation-node/add-constraint-node.js
var AddConstraintNode;
var init_add_constraint_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/add-constraint-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    AddConstraintNode = freeze({
      is(node) {
        return node.kind === "AddConstraintNode";
      },
      create(constraint) {
        return freeze({
          kind: "AddConstraintNode",
          constraint
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/unique-constraint-node.js
var UniqueConstraintNode;
var init_unique_constraint_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/unique-constraint-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_column_node();
    init_identifier_node();
    UniqueConstraintNode = freeze({
      is(node) {
        return node.kind === "UniqueConstraintNode";
      },
      create(columns, constraintName, nullsNotDistinct) {
        return freeze({
          kind: "UniqueConstraintNode",
          columns: freeze(columns.map(ColumnNode.create)),
          name: constraintName ? IdentifierNode.create(constraintName) : void 0,
          nullsNotDistinct
        });
      },
      cloneWith(node, props) {
        return freeze({
          ...node,
          ...props
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/drop-constraint-node.js
var DropConstraintNode;
var init_drop_constraint_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/drop-constraint-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_identifier_node();
    DropConstraintNode = freeze({
      is(node) {
        return node.kind === "DropConstraintNode";
      },
      create(constraintName) {
        return freeze({
          kind: "DropConstraintNode",
          constraintName: IdentifierNode.create(constraintName)
        });
      },
      cloneWith(dropConstraint, props) {
        return freeze({
          ...dropConstraint,
          ...props
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/alter-column-node.js
var AlterColumnNode;
var init_alter_column_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/alter-column-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_column_node();
    AlterColumnNode = freeze({
      is(node) {
        return node.kind === "AlterColumnNode";
      },
      create(column, prop, value) {
        return freeze({
          kind: "AlterColumnNode",
          column: ColumnNode.create(column),
          [prop]: value
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/schema/alter-column-builder.js
var AlterColumnBuilder, AlteredColumnBuilder;
var init_alter_column_builder = __esm({
  "node_modules/kysely/dist/esm/schema/alter-column-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_alter_column_node();
    init_data_type_parser();
    init_default_value_parser();
    init_prevent_await();
    AlterColumnBuilder = class {
      static {
        __name(this, "AlterColumnBuilder");
      }
      #column;
      constructor(column) {
        this.#column = column;
      }
      setDataType(dataType) {
        return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dataType", parseDataTypeExpression(dataType)));
      }
      setDefault(value) {
        return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "setDefault", parseDefaultValueExpression(value)));
      }
      dropDefault() {
        return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dropDefault", true));
      }
      setNotNull() {
        return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "setNotNull", true));
      }
      dropNotNull() {
        return new AlteredColumnBuilder(AlterColumnNode.create(this.#column, "dropNotNull", true));
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
    };
    preventAwait(AlterColumnBuilder, "don't await AlterColumnBuilder instances");
    AlteredColumnBuilder = class {
      static {
        __name(this, "AlteredColumnBuilder");
      }
      #alterColumnNode;
      constructor(alterColumnNode) {
        this.#alterColumnNode = alterColumnNode;
      }
      toOperationNode() {
        return this.#alterColumnNode;
      }
    };
    preventAwait(AlteredColumnBuilder, "don't await AlteredColumnBuilder instances");
  }
});

// node_modules/kysely/dist/esm/schema/alter-table-executor.js
var AlterTableExecutor;
var init_alter_table_executor = __esm({
  "node_modules/kysely/dist/esm/schema/alter-table-executor.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_prevent_await();
    AlterTableExecutor = class {
      static {
        __name(this, "AlterTableExecutor");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
      }
    };
    preventAwait(AlterTableExecutor, "don't await AlterTableExecutor instances directly. To execute the query you need to call `execute`");
  }
});

// node_modules/kysely/dist/esm/schema/alter-table-add-foreign-key-constraint-builder.js
var AlterTableAddForeignKeyConstraintBuilder;
var init_alter_table_add_foreign_key_constraint_builder = __esm({
  "node_modules/kysely/dist/esm/schema/alter-table-add-foreign-key-constraint-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_add_constraint_node();
    init_alter_table_node();
    init_object_utils();
    init_prevent_await();
    AlterTableAddForeignKeyConstraintBuilder = class _AlterTableAddForeignKeyConstraintBuilder {
      static {
        __name(this, "AlterTableAddForeignKeyConstraintBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      onDelete(onDelete) {
        return new _AlterTableAddForeignKeyConstraintBuilder({
          ...this.#props,
          constraintBuilder: this.#props.constraintBuilder.onDelete(onDelete)
        });
      }
      onUpdate(onUpdate) {
        return new _AlterTableAddForeignKeyConstraintBuilder({
          ...this.#props,
          constraintBuilder: this.#props.constraintBuilder.onUpdate(onUpdate)
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(AlterTableNode.cloneWithTableProps(this.#props.node, {
          addConstraint: AddConstraintNode.create(this.#props.constraintBuilder.toOperationNode())
        }), this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
      }
    };
    preventAwait(AlterTableAddForeignKeyConstraintBuilder, "don't await AlterTableAddForeignKeyConstraintBuilder instances directly. To execute the query you need to call `execute`");
  }
});

// node_modules/kysely/dist/esm/schema/alter-table-drop-constraint-builder.js
var AlterTableDropConstraintBuilder;
var init_alter_table_drop_constraint_builder = __esm({
  "node_modules/kysely/dist/esm/schema/alter-table-drop-constraint-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_alter_table_node();
    init_drop_constraint_node();
    init_object_utils();
    init_prevent_await();
    AlterTableDropConstraintBuilder = class _AlterTableDropConstraintBuilder {
      static {
        __name(this, "AlterTableDropConstraintBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      ifExists() {
        return new _AlterTableDropConstraintBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
              ifExists: true
            })
          })
        });
      }
      cascade() {
        return new _AlterTableDropConstraintBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
              modifier: "cascade"
            })
          })
        });
      }
      restrict() {
        return new _AlterTableDropConstraintBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            dropConstraint: DropConstraintNode.cloneWith(this.#props.node.dropConstraint, {
              modifier: "restrict"
            })
          })
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
      }
    };
    preventAwait(AlterTableDropConstraintBuilder, "don't await AlterTableDropConstraintBuilder instances directly. To execute the query you need to call `execute`");
  }
});

// node_modules/kysely/dist/esm/operation-node/primary-constraint-node.js
var PrimaryConstraintNode;
var init_primary_constraint_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/primary-constraint-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_column_node();
    init_identifier_node();
    PrimaryConstraintNode = freeze({
      is(node) {
        return node.kind === "PrimaryKeyConstraintNode";
      },
      create(columns, constraintName) {
        return freeze({
          kind: "PrimaryKeyConstraintNode",
          columns: freeze(columns.map(ColumnNode.create)),
          name: constraintName ? IdentifierNode.create(constraintName) : void 0
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/add-index-node.js
var AddIndexNode;
var init_add_index_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/add-index-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_identifier_node();
    AddIndexNode = freeze({
      is(node) {
        return node.kind === "AddIndexNode";
      },
      create(name) {
        return freeze({
          kind: "AddIndexNode",
          name: IdentifierNode.create(name)
        });
      },
      cloneWith(node, props) {
        return freeze({
          ...node,
          ...props
        });
      },
      cloneWithColumns(node, columns) {
        return freeze({
          ...node,
          columns: [...node.columns || [], ...columns]
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/schema/alter-table-add-index-builder.js
var AlterTableAddIndexBuilder;
var init_alter_table_add_index_builder = __esm({
  "node_modules/kysely/dist/esm/schema/alter-table-add-index-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_add_index_node();
    init_alter_table_node();
    init_raw_node();
    init_reference_parser();
    init_object_utils();
    init_prevent_await();
    AlterTableAddIndexBuilder = class _AlterTableAddIndexBuilder {
      static {
        __name(this, "AlterTableAddIndexBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      /**
       * Makes the index unique.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .alterTable('person')
       *   .addIndex('person_first_name_index')
       *   .unique()
       *   .column('email')
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * alter table `person` add unique index `person_first_name_index` (`email`)
       * ```
       */
      unique() {
        return new _AlterTableAddIndexBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {
              unique: true
            })
          })
        });
      }
      /**
       * Adds a column to the index.
       *
       * Also see {@link columns} for adding multiple columns at once or {@link expression}
       * for specifying an arbitrary expression.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .alterTable('person')
       *   .addIndex('person_first_name_and_age_index')
       *   .column('first_name')
       *   .column('age desc')
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * alter table `person` add index `person_first_name_and_age_index` (`first_name`, `age` desc)
       * ```
       */
      column(column) {
        return new _AlterTableAddIndexBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [
              parseOrderedColumnName(column)
            ])
          })
        });
      }
      /**
       * Specifies a list of columns for the index.
       *
       * Also see {@link column} for adding a single column or {@link expression} for
       * specifying an arbitrary expression.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .alterTable('person')
       *   .addIndex('person_first_name_and_age_index')
       *   .columns(['first_name', 'age desc'])
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * alter table `person` add index `person_first_name_and_age_index` (`first_name`, `age` desc)
       * ```
       */
      columns(columns) {
        return new _AlterTableAddIndexBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, columns.map(parseOrderedColumnName))
          })
        });
      }
      /**
       * Specifies an arbitrary expression for the index.
       *
       * ### Examples
       *
       * ```ts
       * import {sql } from 'kysely'
       *
       * await db.schema
       *   .alterTable('person')
       *   .addIndex('person_first_name_index')
       *   .expression(sql<boolean>`(first_name < 'Sami')`)
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * alter table `person` add index `person_first_name_index` ((first_name < 'Sami'))
       * ```
       */
      expression(expression) {
        return new _AlterTableAddIndexBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            addIndex: AddIndexNode.cloneWithColumns(this.#props.node.addIndex, [
              expression.toOperationNode()
            ])
          })
        });
      }
      using(indexType) {
        return new _AlterTableAddIndexBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            addIndex: AddIndexNode.cloneWith(this.#props.node.addIndex, {
              using: RawNode.createWithSql(indexType)
            })
          })
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
      }
    };
    preventAwait(AlterTableAddIndexBuilder, "don't await AlterTableAddIndexBuilder instances directly. To execute the query you need to call `execute`");
  }
});

// node_modules/kysely/dist/esm/schema/unique-constraint-builder.js
var UniqueConstraintNodeBuilder;
var init_unique_constraint_builder = __esm({
  "node_modules/kysely/dist/esm/schema/unique-constraint-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_unique_constraint_node();
    init_prevent_await();
    UniqueConstraintNodeBuilder = class _UniqueConstraintNodeBuilder {
      static {
        __name(this, "UniqueConstraintNodeBuilder");
      }
      #node;
      constructor(node) {
        this.#node = node;
      }
      toOperationNode() {
        return this.#node;
      }
      /**
       * Adds `nulls not distinct` to the unique constraint definition
       *
       * Supported by PostgreSQL dialect only
       */
      nullsNotDistinct() {
        return new _UniqueConstraintNodeBuilder(UniqueConstraintNode.cloneWith(this.#node, { nullsNotDistinct: true }));
      }
    };
    preventAwait(UniqueConstraintNodeBuilder, "don't await UniqueConstraintNodeBuilder instances directly.");
  }
});

// node_modules/kysely/dist/esm/schema/alter-table-builder.js
var AlterTableBuilder, AlterTableColumnAlteringBuilder;
var init_alter_table_builder = __esm({
  "node_modules/kysely/dist/esm/schema/alter-table-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_add_column_node();
    init_alter_table_node();
    init_column_definition_node();
    init_drop_column_node();
    init_identifier_node();
    init_rename_column_node();
    init_object_utils();
    init_prevent_await();
    init_column_definition_builder();
    init_modify_column_node();
    init_data_type_parser();
    init_foreign_key_constraint_builder();
    init_add_constraint_node();
    init_unique_constraint_node();
    init_check_constraint_node();
    init_foreign_key_constraint_node();
    init_column_node();
    init_table_parser();
    init_drop_constraint_node();
    init_alter_column_builder();
    init_alter_table_executor();
    init_alter_table_add_foreign_key_constraint_builder();
    init_alter_table_drop_constraint_builder();
    init_primary_constraint_node();
    init_drop_index_node();
    init_add_index_node();
    init_alter_table_add_index_builder();
    init_unique_constraint_builder();
    AlterTableBuilder = class {
      static {
        __name(this, "AlterTableBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      renameTo(newTableName) {
        return new AlterTableExecutor({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            renameTo: parseTable(newTableName)
          })
        });
      }
      setSchema(newSchema) {
        return new AlterTableExecutor({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            setSchema: IdentifierNode.create(newSchema)
          })
        });
      }
      alterColumn(column, alteration) {
        const builder = alteration(new AlterColumnBuilder(column));
        return new AlterTableColumnAlteringBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode())
        });
      }
      dropColumn(column) {
        return new AlterTableColumnAlteringBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column))
        });
      }
      renameColumn(column, newColumn) {
        return new AlterTableColumnAlteringBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn))
        });
      }
      addColumn(columnName, dataType, build = noop) {
        const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
        return new AlterTableColumnAlteringBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode()))
        });
      }
      modifyColumn(columnName, dataType, build = noop) {
        const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
        return new AlterTableColumnAlteringBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode()))
        });
      }
      /**
       * See {@link CreateTableBuilder.addUniqueConstraint}
       */
      addUniqueConstraint(constraintName, columns, build = noop) {
        const uniqueConstraintBuilder = build(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
        return new AlterTableExecutor({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            addConstraint: AddConstraintNode.create(uniqueConstraintBuilder.toOperationNode())
          })
        });
      }
      /**
       * See {@link CreateTableBuilder.addCheckConstraint}
       */
      addCheckConstraint(constraintName, checkExpression) {
        return new AlterTableExecutor({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            addConstraint: AddConstraintNode.create(CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName))
          })
        });
      }
      /**
       * See {@link CreateTableBuilder.addForeignKeyConstraint}
       *
       * Unlike {@link CreateTableBuilder.addForeignKeyConstraint} this method returns
       * the constraint builder and doesn't take a callback as the last argument. This
       * is because you can only add one column per `ALTER TABLE` query.
       */
      addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns) {
        return new AlterTableAddForeignKeyConstraintBuilder({
          ...this.#props,
          constraintBuilder: new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName))
        });
      }
      /**
       * See {@link CreateTableBuilder.addPrimaryKeyConstraint}
       */
      addPrimaryKeyConstraint(constraintName, columns) {
        return new AlterTableExecutor({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            addConstraint: AddConstraintNode.create(PrimaryConstraintNode.create(columns, constraintName))
          })
        });
      }
      dropConstraint(constraintName) {
        return new AlterTableDropConstraintBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            dropConstraint: DropConstraintNode.create(constraintName)
          })
        });
      }
      /**
       * This can be used to add index to table.
       *
       *  ### Examples
       *
       * ```ts
       * db.schema.alterTable('person')
       *   .addIndex('person_email_index')
       *   .column('email')
       *   .unique()
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * alter table `person` add unique index `person_email_index` (`email`)
       * ```
       */
      addIndex(indexName) {
        return new AlterTableAddIndexBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            addIndex: AddIndexNode.create(indexName)
          })
        });
      }
      /**
       * This can be used to drop index from table.
       *
       * ### Examples
       *
       * ```ts
       * db.schema.alterTable('person')
       *   .dropIndex('person_email_index')
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * alter table `person` drop index `test_first_name_index`
       * ```
       */
      dropIndex(indexName) {
        return new AlterTableExecutor({
          ...this.#props,
          node: AlterTableNode.cloneWithTableProps(this.#props.node, {
            dropIndex: DropIndexNode.create(indexName)
          })
        });
      }
      /**
       * Calls the given function passing `this` as the only argument.
       *
       * See {@link CreateTableBuilder.$call}
       */
      $call(func) {
        return func(this);
      }
    };
    preventAwait(AlterTableBuilder, "don't await AlterTableBuilder instances");
    AlterTableColumnAlteringBuilder = class _AlterTableColumnAlteringBuilder {
      static {
        __name(this, "AlterTableColumnAlteringBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      alterColumn(column, alteration) {
        const builder = alteration(new AlterColumnBuilder(column));
        return new _AlterTableColumnAlteringBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, builder.toOperationNode())
        });
      }
      dropColumn(column) {
        return new _AlterTableColumnAlteringBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, DropColumnNode.create(column))
        });
      }
      renameColumn(column, newColumn) {
        return new _AlterTableColumnAlteringBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, RenameColumnNode.create(column, newColumn))
        });
      }
      addColumn(columnName, dataType, build = noop) {
        const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
        return new _AlterTableColumnAlteringBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, AddColumnNode.create(builder.toOperationNode()))
        });
      }
      modifyColumn(columnName, dataType, build = noop) {
        const builder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
        return new _AlterTableColumnAlteringBuilder({
          ...this.#props,
          node: AlterTableNode.cloneWithColumnAlteration(this.#props.node, ModifyColumnNode.create(builder.toOperationNode()))
        });
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
      }
    };
    preventAwait(AlterTableColumnAlteringBuilder, "don't await AlterTableColumnAlteringBuilder instances directly. To execute the query you need to call `execute`");
  }
});

// node_modules/kysely/dist/esm/plugin/immediate-value/immediate-value-transformer.js
var ImmediateValueTransformer;
var init_immediate_value_transformer = __esm({
  "node_modules/kysely/dist/esm/plugin/immediate-value/immediate-value-transformer.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_operation_node_transformer();
    ImmediateValueTransformer = class extends OperationNodeTransformer {
      static {
        __name(this, "ImmediateValueTransformer");
      }
      transformValue(node) {
        return {
          ...super.transformValue(node),
          immediate: true
        };
      }
    };
  }
});

// node_modules/kysely/dist/esm/schema/create-index-builder.js
var CreateIndexBuilder;
var init_create_index_builder = __esm({
  "node_modules/kysely/dist/esm/schema/create-index-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_create_index_node();
    init_raw_node();
    init_reference_parser();
    init_table_parser();
    init_prevent_await();
    init_object_utils();
    init_binary_operation_parser();
    init_query_node();
    init_immediate_value_transformer();
    CreateIndexBuilder = class _CreateIndexBuilder {
      static {
        __name(this, "CreateIndexBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      /**
       * Adds the "if not exists" modifier.
       *
       * If the index already exists, no error is thrown if this method has been called.
       */
      ifNotExists() {
        return new _CreateIndexBuilder({
          ...this.#props,
          node: CreateIndexNode.cloneWith(this.#props.node, {
            ifNotExists: true
          })
        });
      }
      /**
       * Makes the index unique.
       */
      unique() {
        return new _CreateIndexBuilder({
          ...this.#props,
          node: CreateIndexNode.cloneWith(this.#props.node, {
            unique: true
          })
        });
      }
      /**
       * Adds `nulls not distinct` specifier to index.
       * This only works on some dialects like PostgreSQL.
       *
       * ### Examples
       *
       * ```ts
       * db.schema.createIndex('person_first_name_index')
       *  .on('person')
       *  .column('first_name')
       *  .nullsNotDistinct()
       *  .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * create index "person_first_name_index"
       * on "test" ("first_name")
       * nulls not distinct;
       * ```
       */
      nullsNotDistinct() {
        return new _CreateIndexBuilder({
          ...this.#props,
          node: CreateIndexNode.cloneWith(this.#props.node, {
            nullsNotDistinct: true
          })
        });
      }
      /**
       * Specifies the table for the index.
       */
      on(table) {
        return new _CreateIndexBuilder({
          ...this.#props,
          node: CreateIndexNode.cloneWith(this.#props.node, {
            table: parseTable(table)
          })
        });
      }
      /**
       * Adds a column to the index.
       *
       * Also see {@link columns} for adding multiple columns at once or {@link expression}
       * for specifying an arbitrary expression.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *         .createIndex('person_first_name_and_age_index')
       *         .on('person')
       *         .column('first_name')
       *         .column('age desc')
       *         .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * create index "person_first_name_and_age_index" on "person" ("first_name", "age" desc)
       * ```
       */
      column(column) {
        return new _CreateIndexBuilder({
          ...this.#props,
          node: CreateIndexNode.cloneWithColumns(this.#props.node, [
            parseOrderedColumnName(column)
          ])
        });
      }
      /**
       * Specifies a list of columns for the index.
       *
       * Also see {@link column} for adding a single column or {@link expression} for
       * specifying an arbitrary expression.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *         .createIndex('person_first_name_and_age_index')
       *         .on('person')
       *         .columns(['first_name', 'age desc'])
       *         .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * create index "person_first_name_and_age_index" on "person" ("first_name", "age" desc)
       * ```
       */
      columns(columns) {
        return new _CreateIndexBuilder({
          ...this.#props,
          node: CreateIndexNode.cloneWithColumns(this.#props.node, columns.map(parseOrderedColumnName))
        });
      }
      /**
       * Specifies an arbitrary expression for the index.
       *
       * ### Examples
       *
       * ```ts
       * import {sql } from 'kysely'
       *
       * await db.schema
       *   .createIndex('person_first_name_index')
       *   .on('person')
       *   .expression(sql`first_name COLLATE "fi_FI"`)
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * create index "person_first_name_index" on "person" (first_name COLLATE "fi_FI")
       * ```
       */
      expression(expression) {
        return new _CreateIndexBuilder({
          ...this.#props,
          node: CreateIndexNode.cloneWithColumns(this.#props.node, [
            expression.toOperationNode()
          ])
        });
      }
      using(indexType) {
        return new _CreateIndexBuilder({
          ...this.#props,
          node: CreateIndexNode.cloneWith(this.#props.node, {
            using: RawNode.createWithSql(indexType)
          })
        });
      }
      where(...args) {
        const transformer = new ImmediateValueTransformer();
        return new _CreateIndexBuilder({
          ...this.#props,
          node: QueryNode.cloneWithWhere(this.#props.node, transformer.transformNode(parseValueBinaryOperationOrExpression(args)))
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
      }
    };
    preventAwait(CreateIndexBuilder, "don't await CreateIndexBuilder instances directly. To execute the query you need to call `execute`");
  }
});

// node_modules/kysely/dist/esm/schema/create-schema-builder.js
var CreateSchemaBuilder;
var init_create_schema_builder = __esm({
  "node_modules/kysely/dist/esm/schema/create-schema-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_create_schema_node();
    init_prevent_await();
    init_object_utils();
    CreateSchemaBuilder = class _CreateSchemaBuilder {
      static {
        __name(this, "CreateSchemaBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      ifNotExists() {
        return new _CreateSchemaBuilder({
          ...this.#props,
          node: CreateSchemaNode.cloneWith(this.#props.node, { ifNotExists: true })
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
      }
    };
    preventAwait(CreateSchemaBuilder, "don't await CreateSchemaBuilder instances directly. To execute the query you need to call `execute`");
  }
});

// node_modules/kysely/dist/esm/parser/on-commit-action-parse.js
function parseOnCommitAction(action) {
  if (ON_COMMIT_ACTIONS.includes(action)) {
    return action;
  }
  throw new Error(`invalid OnCommitAction ${action}`);
}
var init_on_commit_action_parse = __esm({
  "node_modules/kysely/dist/esm/parser/on-commit-action-parse.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_create_table_node();
    __name(parseOnCommitAction, "parseOnCommitAction");
  }
});

// node_modules/kysely/dist/esm/schema/create-table-builder.js
var CreateTableBuilder;
var init_create_table_builder = __esm({
  "node_modules/kysely/dist/esm/schema/create-table-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_column_definition_node();
    init_create_table_node();
    init_prevent_await();
    init_column_definition_builder();
    init_object_utils();
    init_foreign_key_constraint_node();
    init_column_node();
    init_foreign_key_constraint_builder();
    init_data_type_parser();
    init_primary_constraint_node();
    init_unique_constraint_node();
    init_check_constraint_node();
    init_table_parser();
    init_on_commit_action_parse();
    init_unique_constraint_builder();
    init_expression_parser();
    CreateTableBuilder = class _CreateTableBuilder {
      static {
        __name(this, "CreateTableBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      /**
       * Adds the "temporary" modifier.
       *
       * Use this to create a temporary table.
       */
      temporary() {
        return new _CreateTableBuilder({
          ...this.#props,
          node: CreateTableNode.cloneWith(this.#props.node, {
            temporary: true
          })
        });
      }
      /**
       * Adds an "on commit" statement.
       *
       * This can be used in conjunction with temporary tables on supported databases
       * like PostgreSQL.
       */
      onCommit(onCommit) {
        return new _CreateTableBuilder({
          ...this.#props,
          node: CreateTableNode.cloneWith(this.#props.node, {
            onCommit: parseOnCommitAction(onCommit)
          })
        });
      }
      /**
       * Adds the "if not exists" modifier.
       *
       * If the table already exists, no error is thrown if this method has been called.
       */
      ifNotExists() {
        return new _CreateTableBuilder({
          ...this.#props,
          node: CreateTableNode.cloneWith(this.#props.node, {
            ifNotExists: true
          })
        });
      }
      /**
       * Adds a column to the table.
       *
       * ### Examples
       *
       * ```ts
       * import {sql } from 'kysely'
       *
       * await db.schema
       *   .createTable('person')
       *   .addColumn('id', 'integer', (col) => col.autoIncrement().primaryKey())
       *   .addColumn('first_name', 'varchar(50)', (col) => col.notNull())
       *   .addColumn('last_name', 'varchar(255)')
       *   .addColumn('bank_balance', 'numeric(8, 2)')
       *   // You can specify any data type using the `sql` tag if the types
       *   // don't include it.
       *   .addColumn('data', sql`any_type_here`)
       *   .addColumn('parent_id', 'integer', (col) =>
       *     col.references('person.id').onDelete('cascade')
       *   )
       * ```
       *
       * With this method, it's once again good to remember that Kysely just builds the
       * query and doesn't provide the same API for all databases. For example, some
       * databases like older MySQL don't support the `references` statement in the
       * column definition. Instead foreign key constraints need to be defined in the
       * `create table` query. See the next example:
       *
       * ```ts
       * await db.schema
       *   .createTable('person')
       *   .addColumn('id', 'integer', (col) => col.primaryKey())
       *   .addColumn('parent_id', 'integer')
       *   .addForeignKeyConstraint(
       *     'person_parent_id_fk',
       *     ['parent_id'],
       *     'person',
       *     ['id'],
       *     (cb) => cb.onDelete('cascade')
       *   )
       *   .execute()
       * ```
       *
       * Another good example is that PostgreSQL doesn't support the `auto_increment`
       * keyword and you need to define an autoincrementing column for example using
       * `serial`:
       *
       * ```ts
       * await db.schema
       *   .createTable('person')
       *   .addColumn('id', 'serial', (col) => col.primaryKey())
       *   .execute()
       * ```
       */
      addColumn(columnName, dataType, build = noop) {
        const columnBuilder = build(new ColumnDefinitionBuilder(ColumnDefinitionNode.create(columnName, parseDataTypeExpression(dataType))));
        return new _CreateTableBuilder({
          ...this.#props,
          node: CreateTableNode.cloneWithColumn(this.#props.node, columnBuilder.toOperationNode())
        });
      }
      /**
       * Adds a primary key constraint for one or more columns.
       *
       * The constraint name can be anything you want, but it must be unique
       * across the whole database.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('person')
       *   .addColumn('first_name', 'varchar(64)')
       *   .addColumn('last_name', 'varchar(64)')
       *   .addPrimaryKeyConstraint('primary_key', ['first_name', 'last_name'])
       *   .execute()
       * ```
       */
      addPrimaryKeyConstraint(constraintName, columns) {
        return new _CreateTableBuilder({
          ...this.#props,
          node: CreateTableNode.cloneWithConstraint(this.#props.node, PrimaryConstraintNode.create(columns, constraintName))
        });
      }
      /**
       * Adds a unique constraint for one or more columns.
       *
       * The constraint name can be anything you want, but it must be unique
       * across the whole database.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('person')
       *   .addColumn('first_name', 'varchar(64)')
       *   .addColumn('last_name', 'varchar(64)')
       *   .addUniqueConstraint(
       *     'first_name_last_name_unique',
       *     ['first_name', 'last_name']
       *   )
       *   .execute()
       * ```
       *
       * In dialects such as PostgreSQL you can specify `nulls not distinct` as follows:
       *
       * ```ts
       * await db.schema
       *   .createTable('person')
       *   .addColumn('first_name', 'varchar(64)')
       *   .addColumn('last_name', 'varchar(64)')
       *   .addUniqueConstraint(
       *     'first_name_last_name_unique',
       *     ['first_name', 'last_name'],
       *     (cb) => cb.nullsNotDistinct()
       *   )
       *   .execute()
       * ```
       */
      addUniqueConstraint(constraintName, columns, build = noop) {
        const uniqueConstraintBuilder = build(new UniqueConstraintNodeBuilder(UniqueConstraintNode.create(columns, constraintName)));
        return new _CreateTableBuilder({
          ...this.#props,
          node: CreateTableNode.cloneWithConstraint(this.#props.node, uniqueConstraintBuilder.toOperationNode())
        });
      }
      /**
       * Adds a check constraint.
       *
       * The constraint name can be anything you want, but it must be unique
       * across the whole database.
       *
       * ### Examples
       *
       * ```ts
       * import {sql } from 'kysely'
       *
       * await db.schema
       *   .createTable('animal')
       *   .addColumn('number_of_legs', 'integer')
       *   .addCheckConstraint('check_legs', sql`number_of_legs < 5`)
       *   .execute()
       * ```
       */
      addCheckConstraint(constraintName, checkExpression) {
        return new _CreateTableBuilder({
          ...this.#props,
          node: CreateTableNode.cloneWithConstraint(this.#props.node, CheckConstraintNode.create(checkExpression.toOperationNode(), constraintName))
        });
      }
      /**
       * Adds a foreign key constraint.
       *
       * The constraint name can be anything you want, but it must be unique
       * across the whole database.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('pet')
       *   .addColumn('owner_id', 'integer')
       *   .addForeignKeyConstraint(
       *     'owner_id_foreign',
       *     ['owner_id'],
       *     'person',
       *     ['id'],
       *   )
       *   .execute()
       * ```
       *
       * Add constraint for multiple columns:
       *
       * ```ts
       * await db.schema
       *   .createTable('pet')
       *   .addColumn('owner_id1', 'integer')
       *   .addColumn('owner_id2', 'integer')
       *   .addForeignKeyConstraint(
       *     'owner_id_foreign',
       *     ['owner_id1', 'owner_id2'],
       *     'person',
       *     ['id1', 'id2'],
       *     (cb) => cb.onDelete('cascade')
       *   )
       *   .execute()
       * ```
       */
      addForeignKeyConstraint(constraintName, columns, targetTable, targetColumns, build = noop) {
        const builder = build(new ForeignKeyConstraintBuilder(ForeignKeyConstraintNode.create(columns.map(ColumnNode.create), parseTable(targetTable), targetColumns.map(ColumnNode.create), constraintName)));
        return new _CreateTableBuilder({
          ...this.#props,
          node: CreateTableNode.cloneWithConstraint(this.#props.node, builder.toOperationNode())
        });
      }
      /**
       * This can be used to add any additional SQL to the front of the query __after__ the `create` keyword.
       *
       * Also see {@link temporary}.
       *
       * ### Examples
       *
       * ```ts
       * import { sql } from 'kysely'
       *
       * await db.schema
       *   .createTable('person')
       *   .modifyFront(sql`global temporary`)
       *   .addColumn('id', 'integer', col => col.primaryKey())
       *   .addColumn('first_name', 'varchar(64)', col => col.notNull())
       *   .addColumn('last_name', 'varchar(64)', col => col.notNull())
       *   .execute()
       * ```
       *
       * The generated SQL (Postgres):
       *
       * ```sql
       * create global temporary table "person" (
       *   "id" integer primary key,
       *   "first_name" varchar(64) not null,
       *   "last_name" varchar(64) not null
       * )
       * ```
       */
      modifyFront(modifier) {
        return new _CreateTableBuilder({
          ...this.#props,
          node: CreateTableNode.cloneWithFrontModifier(this.#props.node, modifier.toOperationNode())
        });
      }
      /**
       * This can be used to add any additional SQL to the end of the query.
       *
       * Also see {@link onCommit}.
       *
       * ### Examples
       *
       * ```ts
       * import { sql } from 'kysely'
       *
       * await db.schema
       *   .createTable('person')
       *   .addColumn('id', 'integer', col => col.primaryKey())
       *   .addColumn('first_name', 'varchar(64)', col => col.notNull())
       *   .addColumn('last_name', 'varchar(64)', col => col.notNull())
       *   .modifyEnd(sql`collate utf8_unicode_ci`)
       *   .execute()
       * ```
       *
       * The generated SQL (MySQL):
       *
       * ```sql
       * create table `person` (
       *   `id` integer primary key,
       *   `first_name` varchar(64) not null,
       *   `last_name` varchar(64) not null
       * ) collate utf8_unicode_ci
       * ```
       */
      modifyEnd(modifier) {
        return new _CreateTableBuilder({
          ...this.#props,
          node: CreateTableNode.cloneWithEndModifier(this.#props.node, modifier.toOperationNode())
        });
      }
      /**
       * Allows to create table from `select` query.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('copy')
       *   .temporary()
       *   .as(db.selectFrom('person').select(['first_name', 'last_name']))
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * create temporary table "copy" as
       * select "first_name", "last_name" from "person"
       * ```
       */
      as(expression) {
        return new _CreateTableBuilder({
          ...this.#props,
          node: CreateTableNode.cloneWith(this.#props.node, {
            selectQuery: parseExpression(expression)
          })
        });
      }
      /**
       * Calls the given function passing `this` as the only argument.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createTable('test')
       *   .$call((builder) => builder.addColumn('id', 'integer'))
       *   .execute()
       * ```
       *
       * This is useful for creating reusable functions that can be called with a builder.
       *
       * ```ts
       * import { type CreateTableBuilder, sql } from 'kysely'
       *
       * const addDefaultColumns = (ctb: CreateTableBuilder<any, any>) => {
       *   return ctb
       *     .addColumn('id', 'integer', (col) => col.notNull())
       *     .addColumn('created_at', 'date', (col) =>
       *       col.notNull().defaultTo(sql`now()`)
       *     )
       *     .addColumn('updated_at', 'date', (col) =>
       *       col.notNull().defaultTo(sql`now()`)
       *     )
       * }
       *
       * await db.schema
       *   .createTable('test')
       *   .$call(addDefaultColumns)
       *   .execute()
       * ```
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
      }
    };
    preventAwait(CreateTableBuilder, "don't await CreateTableBuilder instances directly. To execute the query you need to call `execute`");
  }
});

// node_modules/kysely/dist/esm/schema/drop-index-builder.js
var DropIndexBuilder;
var init_drop_index_builder = __esm({
  "node_modules/kysely/dist/esm/schema/drop-index-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_drop_index_node();
    init_prevent_await();
    init_table_parser();
    init_object_utils();
    DropIndexBuilder = class _DropIndexBuilder {
      static {
        __name(this, "DropIndexBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      /**
       * Specifies the table the index was created for. This is not needed
       * in all dialects.
       */
      on(table) {
        return new _DropIndexBuilder({
          ...this.#props,
          node: DropIndexNode.cloneWith(this.#props.node, {
            table: parseTable(table)
          })
        });
      }
      ifExists() {
        return new _DropIndexBuilder({
          ...this.#props,
          node: DropIndexNode.cloneWith(this.#props.node, {
            ifExists: true
          })
        });
      }
      cascade() {
        return new _DropIndexBuilder({
          ...this.#props,
          node: DropIndexNode.cloneWith(this.#props.node, {
            cascade: true
          })
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
      }
    };
    preventAwait(DropIndexBuilder, "don't await DropIndexBuilder instances directly. To execute the query you need to call `execute`");
  }
});

// node_modules/kysely/dist/esm/schema/drop-schema-builder.js
var DropSchemaBuilder;
var init_drop_schema_builder = __esm({
  "node_modules/kysely/dist/esm/schema/drop-schema-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_drop_schema_node();
    init_prevent_await();
    init_object_utils();
    DropSchemaBuilder = class _DropSchemaBuilder {
      static {
        __name(this, "DropSchemaBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      ifExists() {
        return new _DropSchemaBuilder({
          ...this.#props,
          node: DropSchemaNode.cloneWith(this.#props.node, {
            ifExists: true
          })
        });
      }
      cascade() {
        return new _DropSchemaBuilder({
          ...this.#props,
          node: DropSchemaNode.cloneWith(this.#props.node, {
            cascade: true
          })
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
      }
    };
    preventAwait(DropSchemaBuilder, "don't await DropSchemaBuilder instances directly. To execute the query you need to call `execute`");
  }
});

// node_modules/kysely/dist/esm/schema/drop-table-builder.js
var DropTableBuilder;
var init_drop_table_builder = __esm({
  "node_modules/kysely/dist/esm/schema/drop-table-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_drop_table_node();
    init_prevent_await();
    init_object_utils();
    DropTableBuilder = class _DropTableBuilder {
      static {
        __name(this, "DropTableBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      ifExists() {
        return new _DropTableBuilder({
          ...this.#props,
          node: DropTableNode.cloneWith(this.#props.node, {
            ifExists: true
          })
        });
      }
      cascade() {
        return new _DropTableBuilder({
          ...this.#props,
          node: DropTableNode.cloneWith(this.#props.node, {
            cascade: true
          })
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
      }
    };
    preventAwait(DropTableBuilder, "don't await DropTableBuilder instances directly. To execute the query you need to call `execute`");
  }
});

// node_modules/kysely/dist/esm/operation-node/create-view-node.js
var CreateViewNode;
var init_create_view_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/create-view-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_schemable_identifier_node();
    CreateViewNode = freeze({
      is(node) {
        return node.kind === "CreateViewNode";
      },
      create(name) {
        return freeze({
          kind: "CreateViewNode",
          name: SchemableIdentifierNode.create(name)
        });
      },
      cloneWith(createView, params) {
        return freeze({
          ...createView,
          ...params
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/plugin/immediate-value/immediate-value-plugin.js
var ImmediateValuePlugin;
var init_immediate_value_plugin = __esm({
  "node_modules/kysely/dist/esm/plugin/immediate-value/immediate-value-plugin.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_immediate_value_transformer();
    ImmediateValuePlugin = class {
      static {
        __name(this, "ImmediateValuePlugin");
      }
      #transformer = new ImmediateValueTransformer();
      transformQuery(args) {
        return this.#transformer.transformNode(args.node);
      }
      transformResult(args) {
        return Promise.resolve(args.result);
      }
    };
  }
});

// node_modules/kysely/dist/esm/schema/create-view-builder.js
var CreateViewBuilder;
var init_create_view_builder = __esm({
  "node_modules/kysely/dist/esm/schema/create-view-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_prevent_await();
    init_object_utils();
    init_create_view_node();
    init_reference_parser();
    init_immediate_value_plugin();
    CreateViewBuilder = class _CreateViewBuilder {
      static {
        __name(this, "CreateViewBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      /**
       * Adds the "temporary" modifier.
       *
       * Use this to create a temporary view.
       */
      temporary() {
        return new _CreateViewBuilder({
          ...this.#props,
          node: CreateViewNode.cloneWith(this.#props.node, {
            temporary: true
          })
        });
      }
      materialized() {
        return new _CreateViewBuilder({
          ...this.#props,
          node: CreateViewNode.cloneWith(this.#props.node, {
            materialized: true
          })
        });
      }
      /**
       * Only implemented on some dialects like SQLite. On most dialects, use {@link orReplace}.
       */
      ifNotExists() {
        return new _CreateViewBuilder({
          ...this.#props,
          node: CreateViewNode.cloneWith(this.#props.node, {
            ifNotExists: true
          })
        });
      }
      orReplace() {
        return new _CreateViewBuilder({
          ...this.#props,
          node: CreateViewNode.cloneWith(this.#props.node, {
            orReplace: true
          })
        });
      }
      columns(columns) {
        return new _CreateViewBuilder({
          ...this.#props,
          node: CreateViewNode.cloneWith(this.#props.node, {
            columns: columns.map(parseColumnName)
          })
        });
      }
      /**
       * Sets the select query or a `values` statement that creates the view.
       *
       * WARNING!
       * Some dialects don't support parameterized queries in DDL statements and therefore
       * the query or raw {@link sql } expression passed here is interpolated into a single
       * string opening an SQL injection vulnerability. DO NOT pass unchecked user input
       * into the query or raw expression passed to this method!
       */
      as(query) {
        const queryNode = query.withPlugin(new ImmediateValuePlugin()).toOperationNode();
        return new _CreateViewBuilder({
          ...this.#props,
          node: CreateViewNode.cloneWith(this.#props.node, {
            as: queryNode
          })
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
      }
    };
    preventAwait(CreateViewBuilder, "don't await CreateViewBuilder instances directly. To execute the query you need to call `execute`");
  }
});

// node_modules/kysely/dist/esm/operation-node/drop-view-node.js
var DropViewNode;
var init_drop_view_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/drop-view-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_schemable_identifier_node();
    DropViewNode = freeze({
      is(node) {
        return node.kind === "DropViewNode";
      },
      create(name) {
        return freeze({
          kind: "DropViewNode",
          name: SchemableIdentifierNode.create(name)
        });
      },
      cloneWith(dropView, params) {
        return freeze({
          ...dropView,
          ...params
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/schema/drop-view-builder.js
var DropViewBuilder;
var init_drop_view_builder = __esm({
  "node_modules/kysely/dist/esm/schema/drop-view-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_prevent_await();
    init_object_utils();
    init_drop_view_node();
    DropViewBuilder = class _DropViewBuilder {
      static {
        __name(this, "DropViewBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      materialized() {
        return new _DropViewBuilder({
          ...this.#props,
          node: DropViewNode.cloneWith(this.#props.node, {
            materialized: true
          })
        });
      }
      ifExists() {
        return new _DropViewBuilder({
          ...this.#props,
          node: DropViewNode.cloneWith(this.#props.node, {
            ifExists: true
          })
        });
      }
      cascade() {
        return new _DropViewBuilder({
          ...this.#props,
          node: DropViewNode.cloneWith(this.#props.node, {
            cascade: true
          })
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
      }
    };
    preventAwait(DropViewBuilder, "don't await DropViewBuilder instances directly. To execute the query you need to call `execute`");
  }
});

// node_modules/kysely/dist/esm/operation-node/create-type-node.js
var CreateTypeNode;
var init_create_type_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/create-type-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_value_list_node();
    init_value_node();
    CreateTypeNode = freeze({
      is(node) {
        return node.kind === "CreateTypeNode";
      },
      create(name) {
        return freeze({
          kind: "CreateTypeNode",
          name
        });
      },
      cloneWithEnum(createType, values) {
        return freeze({
          ...createType,
          enum: ValueListNode.create(values.map((value) => ValueNode.createImmediate(value)))
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/schema/create-type-builder.js
var CreateTypeBuilder;
var init_create_type_builder = __esm({
  "node_modules/kysely/dist/esm/schema/create-type-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_prevent_await();
    init_object_utils();
    init_create_type_node();
    CreateTypeBuilder = class _CreateTypeBuilder {
      static {
        __name(this, "CreateTypeBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
      }
      /**
       * Creates an anum type.
       *
       * ### Examples
       *
       * ```ts
       * db.schema.createType('species').asEnum(['cat', 'dog', 'frog'])
       * ```
       */
      asEnum(values) {
        return new _CreateTypeBuilder({
          ...this.#props,
          node: CreateTypeNode.cloneWithEnum(this.#props.node, values)
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
      }
    };
    preventAwait(CreateTypeBuilder, "don't await CreateTypeBuilder instances directly. To execute the query you need to call `execute`");
  }
});

// node_modules/kysely/dist/esm/operation-node/drop-type-node.js
var DropTypeNode;
var init_drop_type_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/drop-type-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    DropTypeNode = freeze({
      is(node) {
        return node.kind === "DropTypeNode";
      },
      create(name) {
        return freeze({
          kind: "DropTypeNode",
          name
        });
      },
      cloneWith(dropType, params) {
        return freeze({
          ...dropType,
          ...params
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/schema/drop-type-builder.js
var DropTypeBuilder;
var init_drop_type_builder = __esm({
  "node_modules/kysely/dist/esm/schema/drop-type-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_drop_type_node();
    init_prevent_await();
    init_object_utils();
    DropTypeBuilder = class _DropTypeBuilder {
      static {
        __name(this, "DropTypeBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      ifExists() {
        return new _DropTypeBuilder({
          ...this.#props,
          node: DropTypeNode.cloneWith(this.#props.node, {
            ifExists: true
          })
        });
      }
      /**
       * Simply calls the provided function passing `this` as the only argument. `$call` returns
       * what the provided function returns.
       */
      $call(func) {
        return func(this);
      }
      toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.node, this.#props.queryId);
      }
      compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
      }
      async execute() {
        await this.#props.executor.executeQuery(this.compile(), this.#props.queryId);
      }
    };
    preventAwait(DropTypeBuilder, "don't await DropTypeBuilder instances directly. To execute the query you need to call `execute`");
  }
});

// node_modules/kysely/dist/esm/parser/identifier-parser.js
function parseSchemableIdentifier(id) {
  const SCHEMA_SEPARATOR = ".";
  if (id.includes(SCHEMA_SEPARATOR)) {
    const parts = id.split(SCHEMA_SEPARATOR).map(trim3);
    if (parts.length === 2) {
      return SchemableIdentifierNode.createWithSchema(parts[0], parts[1]);
    } else {
      throw new Error(`invalid schemable identifier ${id}`);
    }
  } else {
    return SchemableIdentifierNode.create(id);
  }
}
function trim3(str) {
  return str.trim();
}
var init_identifier_parser = __esm({
  "node_modules/kysely/dist/esm/parser/identifier-parser.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_schemable_identifier_node();
    __name(parseSchemableIdentifier, "parseSchemableIdentifier");
    __name(trim3, "trim");
  }
});

// node_modules/kysely/dist/esm/schema/schema.js
var SchemaModule;
var init_schema2 = __esm({
  "node_modules/kysely/dist/esm/schema/schema.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_alter_table_node();
    init_create_index_node();
    init_create_schema_node();
    init_create_table_node();
    init_drop_index_node();
    init_drop_schema_node();
    init_drop_table_node();
    init_table_parser();
    init_alter_table_builder();
    init_create_index_builder();
    init_create_schema_builder();
    init_create_table_builder();
    init_drop_index_builder();
    init_drop_schema_builder();
    init_drop_table_builder();
    init_query_id();
    init_with_schema_plugin();
    init_create_view_builder();
    init_create_view_node();
    init_drop_view_builder();
    init_drop_view_node();
    init_create_type_builder();
    init_drop_type_builder();
    init_create_type_node();
    init_drop_type_node();
    init_identifier_parser();
    SchemaModule = class _SchemaModule {
      static {
        __name(this, "SchemaModule");
      }
      #executor;
      constructor(executor) {
        this.#executor = executor;
      }
      /**
       * Create a new table.
       *
       * ### Examples
       *
       * This example creates a new table with columns `id`, `first_name`,
       * `last_name` and `gender`:
       *
       * ```ts
       * await db.schema
       *   .createTable('person')
       *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
       *   .addColumn('first_name', 'varchar', col => col.notNull())
       *   .addColumn('last_name', 'varchar', col => col.notNull())
       *   .addColumn('gender', 'varchar')
       *   .execute()
       * ```
       *
       * This example creates a table with a foreign key. Not all database
       * engines support column-level foreign key constraint definitions.
       * For example if you are using MySQL 5.X see the next example after
       * this one.
       *
       * ```ts
       * await db.schema
       *   .createTable('pet')
       *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
       *   .addColumn('owner_id', 'integer', col => col
       *     .references('person.id')
       *     .onDelete('cascade')
       *   )
       *   .execute()
       * ```
       *
       * This example adds a foreign key constraint for a columns just
       * like the previous example, but using a table-level statement.
       * On MySQL 5.X you need to define foreign key constraints like
       * this:
       *
       * ```ts
       * await db.schema
       *   .createTable('pet')
       *   .addColumn('id', 'integer', col => col.primaryKey().autoIncrement())
       *   .addColumn('owner_id', 'integer')
       *   .addForeignKeyConstraint(
       *     'pet_owner_id_foreign', ['owner_id'], 'person', ['id'],
       *     (constraint) => constraint.onDelete('cascade')
       *   )
       *   .execute()
       * ```
       */
      createTable(table) {
        return new CreateTableBuilder({
          queryId: createQueryId(),
          executor: this.#executor,
          node: CreateTableNode.create(parseTable(table))
        });
      }
      /**
       * Drop a table.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .dropTable('person')
       *   .execute()
       * ```
       */
      dropTable(table) {
        return new DropTableBuilder({
          queryId: createQueryId(),
          executor: this.#executor,
          node: DropTableNode.create(parseTable(table))
        });
      }
      /**
       * Create a new index.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createIndex('person_full_name_unique_index')
       *   .on('person')
       *   .columns(['first_name', 'last_name'])
       *   .execute()
       * ```
       */
      createIndex(indexName) {
        return new CreateIndexBuilder({
          queryId: createQueryId(),
          executor: this.#executor,
          node: CreateIndexNode.create(indexName)
        });
      }
      /**
       * Drop an index.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .dropIndex('person_full_name_unique_index')
       *   .execute()
       * ```
       */
      dropIndex(indexName) {
        return new DropIndexBuilder({
          queryId: createQueryId(),
          executor: this.#executor,
          node: DropIndexNode.create(indexName)
        });
      }
      /**
       * Create a new schema.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createSchema('some_schema')
       *   .execute()
       * ```
       */
      createSchema(schema) {
        return new CreateSchemaBuilder({
          queryId: createQueryId(),
          executor: this.#executor,
          node: CreateSchemaNode.create(schema)
        });
      }
      /**
       * Drop a schema.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .dropSchema('some_schema')
       *   .execute()
       * ```
       */
      dropSchema(schema) {
        return new DropSchemaBuilder({
          queryId: createQueryId(),
          executor: this.#executor,
          node: DropSchemaNode.create(schema)
        });
      }
      /**
       * Alter a table.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .alterTable('person')
       *   .alterColumn('first_name', (ac) => ac.setDataType('text'))
       *   .execute()
       * ```
       */
      alterTable(table) {
        return new AlterTableBuilder({
          queryId: createQueryId(),
          executor: this.#executor,
          node: AlterTableNode.create(parseTable(table))
        });
      }
      /**
       * Create a new view.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createView('dogs')
       *   .orReplace()
       *   .as(db.selectFrom('pet').selectAll().where('species', '=', 'dog'))
       *   .execute()
       * ```
       */
      createView(viewName) {
        return new CreateViewBuilder({
          queryId: createQueryId(),
          executor: this.#executor,
          node: CreateViewNode.create(viewName)
        });
      }
      /**
       * Drop a view.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .dropView('dogs')
       *   .ifExists()
       *   .execute()
       * ```
       */
      dropView(viewName) {
        return new DropViewBuilder({
          queryId: createQueryId(),
          executor: this.#executor,
          node: DropViewNode.create(viewName)
        });
      }
      /**
       * Create a new type.
       *
       * Only some dialects like PostgreSQL have user-defined types.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .createType('species')
       *   .asEnum(['dog', 'cat', 'frog'])
       *   .execute()
       * ```
       */
      createType(typeName) {
        return new CreateTypeBuilder({
          queryId: createQueryId(),
          executor: this.#executor,
          node: CreateTypeNode.create(parseSchemableIdentifier(typeName))
        });
      }
      /**
       * Drop a type.
       *
       * Only some dialects like PostgreSQL have user-defined types.
       *
       * ### Examples
       *
       * ```ts
       * await db.schema
       *   .dropType('species')
       *   .ifExists()
       *   .execute()
       * ```
       */
      dropType(typeName) {
        return new DropTypeBuilder({
          queryId: createQueryId(),
          executor: this.#executor,
          node: DropTypeNode.create(parseSchemableIdentifier(typeName))
        });
      }
      /**
       * Returns a copy of this schema module with the given plugin installed.
       */
      withPlugin(plugin) {
        return new _SchemaModule(this.#executor.withPlugin(plugin));
      }
      /**
       * Returns a copy of this schema module  without any plugins.
       */
      withoutPlugins() {
        return new _SchemaModule(this.#executor.withoutPlugins());
      }
      /**
       * See {@link QueryCreator.withSchema}
       */
      withSchema(schema) {
        return new _SchemaModule(this.#executor.withPluginAtFront(new WithSchemaPlugin(schema)));
      }
    };
  }
});

// node_modules/kysely/dist/esm/dynamic/dynamic.js
var DynamicModule;
var init_dynamic = __esm({
  "node_modules/kysely/dist/esm/dynamic/dynamic.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_dynamic_reference_builder();
    DynamicModule = class {
      static {
        __name(this, "DynamicModule");
      }
      /**
       * Creates a dynamic reference to a column that is not know at compile time.
       *
       * Kysely is built in a way that by default you can't refer to tables or columns
       * that are not actually visible in the current query and context. This is all
       * done by TypeScript at compile time, which means that you need to know the
       * columns and tables at compile time. This is not always the case of course.
       *
       * This method is meant to be used in those cases where the column names
       * come from the user input or are not otherwise known at compile time.
       *
       * WARNING! Unlike values, column names are not escaped by the database engine
       * or Kysely and if you pass in unchecked column names using this method, you
       * create an SQL injection vulnerability. Always __always__ validate the user
       * input before passing it to this method.
       *
       * There are couple of examples below for some use cases, but you can pass
       * `ref` to other methods as well. If the types allow you to pass a `ref`
       * value to some place, it should work.
       *
       * ### Examples
       *
       * Filter by a column not know at compile time:
       *
       * ```ts
       * async function someQuery(filterColumn: string, filterValue: string) {
       *   const { ref } = db.dynamic
       *
       *   return await db
       *     .selectFrom('person')
       *     .selectAll()
       *     .where(ref(filterColumn), '=', filterValue)
       *     .execute()
       * }
       *
       * someQuery('first_name', 'Arnold')
       * someQuery('person.last_name', 'Aniston')
       * ```
       *
       * Order by a column not know at compile time:
       *
       * ```ts
       * async function someQuery(orderBy: string) {
       *   const { ref } = db.dynamic
       *
       *   return await db
       *     .selectFrom('person')
       *     .select('person.first_name as fn')
       *     .orderBy(ref(orderBy))
       *     .execute()
       * }
       *
       * someQuery('fn')
       * ```
       *
       * In this example we add selections dynamically:
       *
       * ```ts
       * const { ref } = db.dynamic
       *
       * // Some column name provided by the user. Value not known at compile time.
       * const columnFromUserInput: PossibleColumns = 'birthdate';
       *
       * // A type that lists all possible values `columnFromUserInput` can have.
       * // You can use `keyof Person` if any column of an interface is allowed.
       * type PossibleColumns = 'last_name' | 'first_name' | 'birthdate'
       *
       * const [person] = await db.selectFrom('person')
       *   .select([
       *     ref<PossibleColumns>(columnFromUserInput),
       *     'id'
       *   ])
       *   .execute()
       *
       * // The resulting type contains all `PossibleColumns` as optional fields
       * // because we cannot know which field was actually selected before
       * // running the code.
       * const lastName: string | null | undefined = person?.last_name
       * const firstName: string | undefined = person?.first_name
       * const birthDate: Date | null | undefined = person?.birthdate
       *
       * // The result type also contains the compile time selection `id`.
       * person?.id
       * ```
       */
      ref(reference) {
        return new DynamicReferenceBuilder(reference);
      }
    };
  }
});

// node_modules/kysely/dist/esm/driver/default-connection-provider.js
var DefaultConnectionProvider;
var init_default_connection_provider = __esm({
  "node_modules/kysely/dist/esm/driver/default-connection-provider.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    DefaultConnectionProvider = class {
      static {
        __name(this, "DefaultConnectionProvider");
      }
      #driver;
      constructor(driver) {
        this.#driver = driver;
      }
      async provideConnection(consumer) {
        const connection = await this.#driver.acquireConnection();
        try {
          return await consumer(connection);
        } finally {
          await this.#driver.releaseConnection(connection);
        }
      }
    };
  }
});

// node_modules/kysely/dist/esm/query-executor/default-query-executor.js
var DefaultQueryExecutor;
var init_default_query_executor = __esm({
  "node_modules/kysely/dist/esm/query-executor/default-query-executor.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_query_executor_base();
    DefaultQueryExecutor = class _DefaultQueryExecutor extends QueryExecutorBase {
      static {
        __name(this, "DefaultQueryExecutor");
      }
      #compiler;
      #adapter;
      #connectionProvider;
      constructor(compiler, adapter, connectionProvider, plugins = []) {
        super(plugins);
        this.#compiler = compiler;
        this.#adapter = adapter;
        this.#connectionProvider = connectionProvider;
      }
      get adapter() {
        return this.#adapter;
      }
      compileQuery(node) {
        return this.#compiler.compileQuery(node);
      }
      provideConnection(consumer) {
        return this.#connectionProvider.provideConnection(consumer);
      }
      withPlugins(plugins) {
        return new _DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, ...plugins]);
      }
      withPlugin(plugin) {
        return new _DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [...this.plugins, plugin]);
      }
      withPluginAtFront(plugin) {
        return new _DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, [plugin, ...this.plugins]);
      }
      withConnectionProvider(connectionProvider) {
        return new _DefaultQueryExecutor(this.#compiler, this.#adapter, connectionProvider, [...this.plugins]);
      }
      withoutPlugins() {
        return new _DefaultQueryExecutor(this.#compiler, this.#adapter, this.#connectionProvider, []);
      }
    };
  }
});

// node_modules/kysely/dist/esm/util/performance-now.js
function performanceNow() {
  if (typeof performance !== "undefined" && isFunction(performance.now)) {
    return performance.now();
  } else {
    return Date.now();
  }
}
var init_performance_now = __esm({
  "node_modules/kysely/dist/esm/util/performance-now.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    __name(performanceNow, "performanceNow");
  }
});

// node_modules/kysely/dist/esm/driver/runtime-driver.js
var RuntimeDriver;
var init_runtime_driver = __esm({
  "node_modules/kysely/dist/esm/driver/runtime-driver.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_performance_now();
    RuntimeDriver = class {
      static {
        __name(this, "RuntimeDriver");
      }
      #driver;
      #log;
      #initPromise;
      #initDone;
      #destroyPromise;
      #connections = /* @__PURE__ */ new WeakSet();
      constructor(driver, log) {
        this.#initDone = false;
        this.#driver = driver;
        this.#log = log;
      }
      async init() {
        if (this.#destroyPromise) {
          throw new Error("driver has already been destroyed");
        }
        if (!this.#initPromise) {
          this.#initPromise = this.#driver.init().then(() => {
            this.#initDone = true;
          }).catch((err) => {
            this.#initPromise = void 0;
            return Promise.reject(err);
          });
        }
        await this.#initPromise;
      }
      async acquireConnection() {
        if (this.#destroyPromise) {
          throw new Error("driver has already been destroyed");
        }
        if (!this.#initDone) {
          await this.init();
        }
        const connection = await this.#driver.acquireConnection();
        if (!this.#connections.has(connection)) {
          if (this.#needsLogging()) {
            this.#addLogging(connection);
          }
          this.#connections.add(connection);
        }
        return connection;
      }
      async releaseConnection(connection) {
        await this.#driver.releaseConnection(connection);
      }
      beginTransaction(connection, settings) {
        return this.#driver.beginTransaction(connection, settings);
      }
      commitTransaction(connection) {
        return this.#driver.commitTransaction(connection);
      }
      rollbackTransaction(connection) {
        return this.#driver.rollbackTransaction(connection);
      }
      async destroy() {
        if (!this.#initPromise) {
          return;
        }
        await this.#initPromise;
        if (!this.#destroyPromise) {
          this.#destroyPromise = this.#driver.destroy().catch((err) => {
            this.#destroyPromise = void 0;
            return Promise.reject(err);
          });
        }
        await this.#destroyPromise;
      }
      #needsLogging() {
        return this.#log.isLevelEnabled("query") || this.#log.isLevelEnabled("error");
      }
      // This method monkey patches the database connection's executeQuery method
      // by adding logging code around it. Monkey patching is not pretty, but it's
      // the best option in this case.
      #addLogging(connection) {
        const executeQuery = connection.executeQuery;
        connection.executeQuery = async (compiledQuery) => {
          let caughtError;
          const startTime = performanceNow();
          try {
            return await executeQuery.call(connection, compiledQuery);
          } catch (error) {
            caughtError = error;
            await this.#logError(error, compiledQuery, startTime);
            throw error;
          } finally {
            if (!caughtError) {
              await this.#logQuery(compiledQuery, startTime);
            }
          }
        };
      }
      async #logError(error, compiledQuery, startTime) {
        await this.#log.error(() => ({
          level: "error",
          error,
          query: compiledQuery,
          queryDurationMillis: this.#calculateDurationMillis(startTime)
        }));
      }
      async #logQuery(compiledQuery, startTime) {
        await this.#log.query(() => ({
          level: "query",
          query: compiledQuery,
          queryDurationMillis: this.#calculateDurationMillis(startTime)
        }));
      }
      #calculateDurationMillis(startTime) {
        return performanceNow() - startTime;
      }
    };
  }
});

// node_modules/kysely/dist/esm/driver/single-connection-provider.js
var ignoreError, SingleConnectionProvider;
var init_single_connection_provider = __esm({
  "node_modules/kysely/dist/esm/driver/single-connection-provider.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    ignoreError = /* @__PURE__ */ __name(() => {
    }, "ignoreError");
    SingleConnectionProvider = class {
      static {
        __name(this, "SingleConnectionProvider");
      }
      #connection;
      #runningPromise;
      constructor(connection) {
        this.#connection = connection;
      }
      async provideConnection(consumer) {
        while (this.#runningPromise) {
          await this.#runningPromise.catch(ignoreError);
        }
        this.#runningPromise = this.#run(consumer).finally(() => {
          this.#runningPromise = void 0;
        });
        return this.#runningPromise;
      }
      // Run the runner in an async function to make sure it doesn't
      // throw synchronous errors.
      async #run(runner) {
        return await runner(this.#connection);
      }
    };
  }
});

// node_modules/kysely/dist/esm/driver/driver.js
var TRANSACTION_ISOLATION_LEVELS;
var init_driver = __esm({
  "node_modules/kysely/dist/esm/driver/driver.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    TRANSACTION_ISOLATION_LEVELS = [
      "read uncommitted",
      "read committed",
      "repeatable read",
      "serializable",
      "snapshot"
    ];
  }
});

// node_modules/kysely/dist/esm/util/log.js
function defaultLogger(event) {
  if (event.level === "query") {
    console.log(`kysely:query: ${event.query.sql}`);
    console.log(`kysely:query: duration: ${event.queryDurationMillis.toFixed(1)}ms`);
  } else if (event.level === "error") {
    if (event.error instanceof Error) {
      console.error(`kysely:error: ${event.error.stack ?? event.error.message}`);
    } else {
      console.error(`kysely:error: ${JSON.stringify({
        error: event.error,
        query: event.query.sql,
        queryDurationMillis: event.queryDurationMillis
      })}`);
    }
  }
}
var LOG_LEVELS, Log;
var init_log = __esm({
  "node_modules/kysely/dist/esm/util/log.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    LOG_LEVELS = freeze(["query", "error"]);
    Log = class {
      static {
        __name(this, "Log");
      }
      #levels;
      #logger;
      constructor(config) {
        if (isFunction(config)) {
          this.#logger = config;
          this.#levels = freeze({
            query: true,
            error: true
          });
        } else {
          this.#logger = defaultLogger;
          this.#levels = freeze({
            query: config.includes("query"),
            error: config.includes("error")
          });
        }
      }
      isLevelEnabled(level) {
        return this.#levels[level];
      }
      async query(getEvent) {
        if (this.#levels.query) {
          await this.#logger(getEvent());
        }
      }
      async error(getEvent) {
        if (this.#levels.error) {
          await this.#logger(getEvent());
        }
      }
    };
    __name(defaultLogger, "defaultLogger");
  }
});

// node_modules/kysely/dist/esm/util/compilable.js
function isCompilable(value) {
  return isObject(value) && isFunction(value.compile);
}
var init_compilable = __esm({
  "node_modules/kysely/dist/esm/util/compilable.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    __name(isCompilable, "isCompilable");
  }
});

// node_modules/kysely/dist/esm/kysely.js
function isKyselyProps(obj) {
  return isObject(obj) && isObject(obj.config) && isObject(obj.driver) && isObject(obj.executor) && isObject(obj.dialect);
}
function validateTransactionSettings(settings) {
  if (settings.isolationLevel && !TRANSACTION_ISOLATION_LEVELS.includes(settings.isolationLevel)) {
    throw new Error(`invalid transaction isolation level ${settings.isolationLevel}`);
  }
}
var Kysely, Transaction, ConnectionBuilder, TransactionBuilder;
var init_kysely = __esm({
  "node_modules/kysely/dist/esm/kysely.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_schema2();
    init_dynamic();
    init_default_connection_provider();
    init_query_creator();
    init_default_query_executor();
    init_object_utils();
    init_runtime_driver();
    init_single_connection_provider();
    init_driver();
    init_prevent_await();
    init_function_module();
    init_log();
    init_query_id();
    init_compilable();
    init_case_builder();
    init_case_node();
    init_expression_parser();
    init_with_schema_plugin();
    Kysely = class _Kysely extends QueryCreator {
      static {
        __name(this, "Kysely");
      }
      #props;
      constructor(args) {
        let superProps;
        let props;
        if (isKyselyProps(args)) {
          superProps = { executor: args.executor };
          props = { ...args };
        } else {
          const dialect = args.dialect;
          const driver = dialect.createDriver();
          const compiler = dialect.createQueryCompiler();
          const adapter = dialect.createAdapter();
          const log = new Log(args.log ?? []);
          const runtimeDriver = new RuntimeDriver(driver, log);
          const connectionProvider = new DefaultConnectionProvider(runtimeDriver);
          const executor = new DefaultQueryExecutor(compiler, adapter, connectionProvider, args.plugins ?? []);
          superProps = { executor };
          props = {
            config: args,
            executor,
            dialect,
            driver: runtimeDriver
          };
        }
        super(superProps);
        this.#props = freeze(props);
      }
      /**
       * Returns the {@link SchemaModule} module for building database schema.
       */
      get schema() {
        return new SchemaModule(this.#props.executor);
      }
      /**
       * Returns a the {@link DynamicModule} module.
       *
       * The {@link DynamicModule} module can be used to bypass strict typing and
       * passing in dynamic values for the queries.
       */
      get dynamic() {
        return new DynamicModule();
      }
      /**
       * Returns a {@link DatabaseIntrospector | database introspector}.
       */
      get introspection() {
        return this.#props.dialect.createIntrospector(this.withoutPlugins());
      }
      case(value) {
        return new CaseBuilder({
          node: CaseNode.create(isUndefined(value) ? void 0 : parseExpression(value))
        });
      }
      /**
       * Returns a {@link FunctionModule} that can be used to write somewhat type-safe function
       * calls.
       *
       * ```ts
       * const { count } = db.fn
       *
       * await db.selectFrom('person')
       *   .innerJoin('pet', 'pet.owner_id', 'person.id')
       *   .select([
       *     'id',
       *     count('pet.id').as('person_count'),
       *   ])
       *   .groupBy('person.id')
       *   .having(count('pet.id'), '>', 10)
       *   .execute()
       * ```
       *
       * The generated SQL (PostgreSQL):
       *
       * ```sql
       * select "person"."id", count("pet"."id") as "person_count"
       * from "person"
       * inner join "pet" on "pet"."owner_id" = "person"."id"
       * group by "person"."id"
       * having count("pet"."id") > $1
       * ```
       *
       * Why "somewhat" type-safe? Because the function calls are not bound to the
       * current query context. They allow you to reference columns and tables that
       * are not in the current query. E.g. remove the `innerJoin` from the previous
       * query and TypeScript won't even complain.
       *
       * If you want to make the function calls fully type-safe, you can use the
       * {@link ExpressionBuilder.fn} getter for a query context-aware, stricter {@link FunctionModule}.
       *
       * ```ts
       * await db.selectFrom('person')
       *   .innerJoin('pet', 'pet.owner_id', 'person.id')
       *   .select((eb) => [
       *     'person.id',
       *     eb.fn.count('pet.id').as('pet_count')
       *   ])
       *   .groupBy('person.id')
       *   .having((eb) => eb.fn.count('pet.id'), '>', 10)
       *   .execute()
       * ```
       */
      get fn() {
        return createFunctionModule();
      }
      /**
       * Creates a {@link TransactionBuilder} that can be used to run queries inside a transaction.
       *
       * The returned {@link TransactionBuilder} can be used to configure the transaction. The
       * {@link TransactionBuilder.execute} method can then be called to run the transaction.
       * {@link TransactionBuilder.execute} takes a function that is run inside the
       * transaction. If the function throws an exception,
       * 1. the exception is caught,
       * 2. the transaction is rolled back, and
       * 3. the exception is thrown again.
       * Otherwise the transaction is committed.
       *
       * The callback function passed to the {@link TransactionBuilder.execute | execute}
       * method gets the transaction object as its only argument. The transaction is
       * of type {@link Transaction} which inherits {@link Kysely}. Any query
       * started through the transaction object is executed inside the transaction.
       *
       * ### Examples
       *
       * <!-- siteExample("transactions", "Simple transaction", 10) -->
       *
       * This example inserts two rows in a transaction. If an exception is thrown inside
       * the callback passed to the `execute` method,
       * 1. the exception is caught,
       * 2. the transaction is rolled back, and
       * 3. the exception is thrown again.
       * Otherwise the transaction is committed.
       *
       * ```ts
       * const catto = await db.transaction().execute(async (trx) => {
       *   const jennifer = await trx.insertInto('person')
       *     .values({
       *       first_name: 'Jennifer',
       *       last_name: 'Aniston',
       *       age: 40,
       *     })
       *     .returning('id')
       *     .executeTakeFirstOrThrow()
       *
       *   return await trx.insertInto('pet')
       *     .values({
       *       owner_id: jennifer.id,
       *       name: 'Catto',
       *       species: 'cat',
       *       is_favorite: false,
       *     })
       *     .returningAll()
       *     .executeTakeFirst()
       * })
       * ```
       *
       * Setting the isolation level:
       *
       * ```ts
       * import type { Kysely } from 'kysely'
       *
       * await db
       *   .transaction()
       *   .setIsolationLevel('serializable')
       *   .execute(async (trx) => {
       *     await doStuff(trx)
       *   })
       *
       * async function doStuff(kysely: typeof db) {
       *   // ...
       * }
       * ```
       */
      transaction() {
        return new TransactionBuilder({ ...this.#props });
      }
      /**
       * Provides a kysely instance bound to a single database connection.
       *
       * ### Examples
       *
       * ```ts
       * await db
       *   .connection()
       *   .execute(async (db) => {
       *     // `db` is an instance of `Kysely` that's bound to a single
       *     // database connection. All queries executed through `db` use
       *     // the same connection.
       *     await doStuff(db)
       *   })
       *
       * async function doStuff(kysely: typeof db) {
       *   // ...
       * }
       * ```
       */
      connection() {
        return new ConnectionBuilder({ ...this.#props });
      }
      /**
       * Returns a copy of this Kysely instance with the given plugin installed.
       */
      withPlugin(plugin) {
        return new _Kysely({
          ...this.#props,
          executor: this.#props.executor.withPlugin(plugin)
        });
      }
      /**
       * Returns a copy of this Kysely instance without any plugins.
       */
      withoutPlugins() {
        return new _Kysely({
          ...this.#props,
          executor: this.#props.executor.withoutPlugins()
        });
      }
      /**
       * @override
       */
      withSchema(schema) {
        return new _Kysely({
          ...this.#props,
          executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema))
        });
      }
      /**
       * Returns a copy of this Kysely instance with tables added to its
       * database type.
       *
       * This method only modifies the types and doesn't affect any of the
       * executed queries in any way.
       *
       * ### Examples
       *
       * The following example adds and uses a temporary table:
       *
       * ```ts
       * await db.schema
       *   .createTable('temp_table')
       *   .temporary()
       *   .addColumn('some_column', 'integer')
       *   .execute()
       *
       * const tempDb = db.withTables<{
       *   temp_table: {
       *     some_column: number
       *   }
       * }>()
       *
       * await tempDb
       *   .insertInto('temp_table')
       *   .values({ some_column: 100 })
       *   .execute()
       * ```
       */
      withTables() {
        return new _Kysely({ ...this.#props });
      }
      /**
       * Releases all resources and disconnects from the database.
       *
       * You need to call this when you are done using the `Kysely` instance.
       */
      async destroy() {
        await this.#props.driver.destroy();
      }
      /**
       * Returns true if this `Kysely` instance is a transaction.
       *
       * You can also use `db instanceof Transaction`.
       */
      get isTransaction() {
        return false;
      }
      /**
       * @internal
       * @private
       */
      getExecutor() {
        return this.#props.executor;
      }
      /**
       * Executes a given compiled query or query builder.
       *
       * See {@link https://github.com/kysely-org/kysely/blob/master/site/docs/recipes/0004-splitting-query-building-and-execution.md#execute-compiled-queries splitting build, compile and execute code recipe} for more information.
       */
      executeQuery(query, queryId = createQueryId()) {
        const compiledQuery = isCompilable(query) ? query.compile() : query;
        return this.getExecutor().executeQuery(compiledQuery, queryId);
      }
    };
    Transaction = class _Transaction extends Kysely {
      static {
        __name(this, "Transaction");
      }
      #props;
      constructor(props) {
        super(props);
        this.#props = props;
      }
      // The return type is `true` instead of `boolean` to make Kysely<DB>
      // unassignable to Transaction<DB> while allowing assignment the
      // other way around.
      get isTransaction() {
        return true;
      }
      transaction() {
        throw new Error("calling the transaction method for a Transaction is not supported");
      }
      connection() {
        throw new Error("calling the connection method for a Transaction is not supported");
      }
      async destroy() {
        throw new Error("calling the destroy method for a Transaction is not supported");
      }
      withPlugin(plugin) {
        return new _Transaction({
          ...this.#props,
          executor: this.#props.executor.withPlugin(plugin)
        });
      }
      withoutPlugins() {
        return new _Transaction({
          ...this.#props,
          executor: this.#props.executor.withoutPlugins()
        });
      }
      withSchema(schema) {
        return new _Transaction({
          ...this.#props,
          executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema))
        });
      }
      withTables() {
        return new _Transaction({ ...this.#props });
      }
    };
    __name(isKyselyProps, "isKyselyProps");
    ConnectionBuilder = class {
      static {
        __name(this, "ConnectionBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      async execute(callback) {
        return this.#props.executor.provideConnection(async (connection) => {
          const executor = this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection));
          const db = new Kysely({
            ...this.#props,
            executor
          });
          return await callback(db);
        });
      }
    };
    preventAwait(ConnectionBuilder, "don't await ConnectionBuilder instances directly. To execute the query you need to call the `execute` method");
    TransactionBuilder = class _TransactionBuilder {
      static {
        __name(this, "TransactionBuilder");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      setIsolationLevel(isolationLevel) {
        return new _TransactionBuilder({
          ...this.#props,
          isolationLevel
        });
      }
      async execute(callback) {
        const { isolationLevel, ...kyselyProps } = this.#props;
        const settings = { isolationLevel };
        validateTransactionSettings(settings);
        return this.#props.executor.provideConnection(async (connection) => {
          const executor = this.#props.executor.withConnectionProvider(new SingleConnectionProvider(connection));
          const transaction = new Transaction({
            ...kyselyProps,
            executor
          });
          try {
            await this.#props.driver.beginTransaction(connection, settings);
            const result = await callback(transaction);
            await this.#props.driver.commitTransaction(connection);
            return result;
          } catch (error) {
            await this.#props.driver.rollbackTransaction(connection);
            throw error;
          }
        });
      }
    };
    preventAwait(TransactionBuilder, "don't await TransactionBuilder instances directly. To execute the transaction you need to call the `execute` method");
    __name(validateTransactionSettings, "validateTransactionSettings");
  }
});

// node_modules/kysely/dist/esm/query-builder/where-interface.js
var init_where_interface = __esm({
  "node_modules/kysely/dist/esm/query-builder/where-interface.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/query-builder/returning-interface.js
var init_returning_interface = __esm({
  "node_modules/kysely/dist/esm/query-builder/returning-interface.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/query-builder/output-interface.js
var init_output_interface = __esm({
  "node_modules/kysely/dist/esm/query-builder/output-interface.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/query-builder/having-interface.js
var init_having_interface = __esm({
  "node_modules/kysely/dist/esm/query-builder/having-interface.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/raw-builder/raw-builder.js
function createRawBuilder(props) {
  return new RawBuilderImpl(props);
}
var RawBuilderImpl, AliasedRawBuilderImpl;
var init_raw_builder = __esm({
  "node_modules/kysely/dist/esm/raw-builder/raw-builder.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_alias_node();
    init_prevent_await();
    init_object_utils();
    init_noop_query_executor();
    init_identifier_node();
    init_operation_node_source();
    RawBuilderImpl = class _RawBuilderImpl {
      static {
        __name(this, "RawBuilderImpl");
      }
      #props;
      constructor(props) {
        this.#props = freeze(props);
      }
      get expressionType() {
        return void 0;
      }
      get isRawBuilder() {
        return true;
      }
      as(alias) {
        return new AliasedRawBuilderImpl(this, alias);
      }
      $castTo() {
        return new _RawBuilderImpl({ ...this.#props });
      }
      $notNull() {
        return new _RawBuilderImpl(this.#props);
      }
      withPlugin(plugin) {
        return new _RawBuilderImpl({
          ...this.#props,
          plugins: this.#props.plugins !== void 0 ? freeze([...this.#props.plugins, plugin]) : freeze([plugin])
        });
      }
      toOperationNode() {
        return this.#toOperationNode(this.#getExecutor());
      }
      compile(executorProvider) {
        return this.#compile(this.#getExecutor(executorProvider));
      }
      async execute(executorProvider) {
        const executor = this.#getExecutor(executorProvider);
        return executor.executeQuery(this.#compile(executor), this.#props.queryId);
      }
      #getExecutor(executorProvider) {
        const executor = executorProvider !== void 0 ? executorProvider.getExecutor() : NOOP_QUERY_EXECUTOR;
        return this.#props.plugins !== void 0 ? executor.withPlugins(this.#props.plugins) : executor;
      }
      #toOperationNode(executor) {
        return executor.transformQuery(this.#props.rawNode, this.#props.queryId);
      }
      #compile(executor) {
        return executor.compileQuery(this.#toOperationNode(executor), this.#props.queryId);
      }
    };
    __name(createRawBuilder, "createRawBuilder");
    preventAwait(RawBuilderImpl, "don't await RawBuilder instances directly. To execute the query you need to call `execute`");
    AliasedRawBuilderImpl = class {
      static {
        __name(this, "AliasedRawBuilderImpl");
      }
      #rawBuilder;
      #alias;
      constructor(rawBuilder, alias) {
        this.#rawBuilder = rawBuilder;
        this.#alias = alias;
      }
      get expression() {
        return this.#rawBuilder;
      }
      get alias() {
        return this.#alias;
      }
      get rawBuilder() {
        return this.#rawBuilder;
      }
      toOperationNode() {
        return AliasNode.create(this.#rawBuilder.toOperationNode(), isOperationNodeSource(this.#alias) ? this.#alias.toOperationNode() : IdentifierNode.create(this.#alias));
      }
    };
    preventAwait(AliasedRawBuilderImpl, "don't await AliasedRawBuilder instances directly. AliasedRawBuilder should never be executed directly since it's always a part of another query.");
  }
});

// node_modules/kysely/dist/esm/raw-builder/sql.js
function parseParameter(param) {
  if (isOperationNodeSource(param)) {
    return param.toOperationNode();
  }
  return parseValueExpression(param);
}
var sql;
var init_sql = __esm({
  "node_modules/kysely/dist/esm/raw-builder/sql.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_identifier_node();
    init_operation_node_source();
    init_raw_node();
    init_value_node();
    init_reference_parser();
    init_table_parser();
    init_value_parser();
    init_query_id();
    init_raw_builder();
    sql = Object.assign((sqlFragments, ...parameters) => {
      return createRawBuilder({
        queryId: createQueryId(),
        rawNode: RawNode.create(sqlFragments, parameters?.map(parseParameter) ?? [])
      });
    }, {
      ref(columnReference) {
        return createRawBuilder({
          queryId: createQueryId(),
          rawNode: RawNode.createWithChild(parseStringReference(columnReference))
        });
      },
      val(value) {
        return createRawBuilder({
          queryId: createQueryId(),
          rawNode: RawNode.createWithChild(parseValueExpression(value))
        });
      },
      value(value) {
        return this.val(value);
      },
      table(tableReference) {
        return createRawBuilder({
          queryId: createQueryId(),
          rawNode: RawNode.createWithChild(parseTable(tableReference))
        });
      },
      id(...ids) {
        const fragments = new Array(ids.length + 1).fill(".");
        fragments[0] = "";
        fragments[fragments.length - 1] = "";
        return createRawBuilder({
          queryId: createQueryId(),
          rawNode: RawNode.create(fragments, ids.map(IdentifierNode.create))
        });
      },
      lit(value) {
        return createRawBuilder({
          queryId: createQueryId(),
          rawNode: RawNode.createWithChild(ValueNode.createImmediate(value))
        });
      },
      literal(value) {
        return this.lit(value);
      },
      raw(sql2) {
        return createRawBuilder({
          queryId: createQueryId(),
          rawNode: RawNode.createWithSql(sql2)
        });
      },
      join(array, separator = sql`, `) {
        const nodes = new Array(2 * array.length - 1);
        const sep = separator.toOperationNode();
        for (let i = 0; i < array.length; ++i) {
          nodes[2 * i] = parseParameter(array[i]);
          if (i !== array.length - 1) {
            nodes[2 * i + 1] = sep;
          }
        }
        return createRawBuilder({
          queryId: createQueryId(),
          rawNode: RawNode.createWithChildren(nodes)
        });
      }
    });
    __name(parseParameter, "parseParameter");
  }
});

// node_modules/kysely/dist/esm/query-executor/query-executor.js
var init_query_executor = __esm({
  "node_modules/kysely/dist/esm/query-executor/query-executor.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/query-executor/query-executor-provider.js
var init_query_executor_provider = __esm({
  "node_modules/kysely/dist/esm/query-executor/query-executor-provider.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/operation-node/operation-node-visitor.js
var OperationNodeVisitor;
var init_operation_node_visitor = __esm({
  "node_modules/kysely/dist/esm/operation-node/operation-node-visitor.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    OperationNodeVisitor = class {
      static {
        __name(this, "OperationNodeVisitor");
      }
      nodeStack = [];
      get parentNode() {
        return this.nodeStack[this.nodeStack.length - 2];
      }
      #visitors = freeze({
        AliasNode: this.visitAlias.bind(this),
        ColumnNode: this.visitColumn.bind(this),
        IdentifierNode: this.visitIdentifier.bind(this),
        SchemableIdentifierNode: this.visitSchemableIdentifier.bind(this),
        RawNode: this.visitRaw.bind(this),
        ReferenceNode: this.visitReference.bind(this),
        SelectQueryNode: this.visitSelectQuery.bind(this),
        SelectionNode: this.visitSelection.bind(this),
        TableNode: this.visitTable.bind(this),
        FromNode: this.visitFrom.bind(this),
        SelectAllNode: this.visitSelectAll.bind(this),
        AndNode: this.visitAnd.bind(this),
        OrNode: this.visitOr.bind(this),
        ValueNode: this.visitValue.bind(this),
        ValueListNode: this.visitValueList.bind(this),
        PrimitiveValueListNode: this.visitPrimitiveValueList.bind(this),
        ParensNode: this.visitParens.bind(this),
        JoinNode: this.visitJoin.bind(this),
        OperatorNode: this.visitOperator.bind(this),
        WhereNode: this.visitWhere.bind(this),
        InsertQueryNode: this.visitInsertQuery.bind(this),
        DeleteQueryNode: this.visitDeleteQuery.bind(this),
        ReturningNode: this.visitReturning.bind(this),
        CreateTableNode: this.visitCreateTable.bind(this),
        AddColumnNode: this.visitAddColumn.bind(this),
        ColumnDefinitionNode: this.visitColumnDefinition.bind(this),
        DropTableNode: this.visitDropTable.bind(this),
        DataTypeNode: this.visitDataType.bind(this),
        OrderByNode: this.visitOrderBy.bind(this),
        OrderByItemNode: this.visitOrderByItem.bind(this),
        GroupByNode: this.visitGroupBy.bind(this),
        GroupByItemNode: this.visitGroupByItem.bind(this),
        UpdateQueryNode: this.visitUpdateQuery.bind(this),
        ColumnUpdateNode: this.visitColumnUpdate.bind(this),
        LimitNode: this.visitLimit.bind(this),
        OffsetNode: this.visitOffset.bind(this),
        OnConflictNode: this.visitOnConflict.bind(this),
        OnDuplicateKeyNode: this.visitOnDuplicateKey.bind(this),
        CreateIndexNode: this.visitCreateIndex.bind(this),
        DropIndexNode: this.visitDropIndex.bind(this),
        ListNode: this.visitList.bind(this),
        PrimaryKeyConstraintNode: this.visitPrimaryKeyConstraint.bind(this),
        UniqueConstraintNode: this.visitUniqueConstraint.bind(this),
        ReferencesNode: this.visitReferences.bind(this),
        CheckConstraintNode: this.visitCheckConstraint.bind(this),
        WithNode: this.visitWith.bind(this),
        CommonTableExpressionNode: this.visitCommonTableExpression.bind(this),
        CommonTableExpressionNameNode: this.visitCommonTableExpressionName.bind(this),
        HavingNode: this.visitHaving.bind(this),
        CreateSchemaNode: this.visitCreateSchema.bind(this),
        DropSchemaNode: this.visitDropSchema.bind(this),
        AlterTableNode: this.visitAlterTable.bind(this),
        DropColumnNode: this.visitDropColumn.bind(this),
        RenameColumnNode: this.visitRenameColumn.bind(this),
        AlterColumnNode: this.visitAlterColumn.bind(this),
        ModifyColumnNode: this.visitModifyColumn.bind(this),
        AddConstraintNode: this.visitAddConstraint.bind(this),
        DropConstraintNode: this.visitDropConstraint.bind(this),
        ForeignKeyConstraintNode: this.visitForeignKeyConstraint.bind(this),
        CreateViewNode: this.visitCreateView.bind(this),
        DropViewNode: this.visitDropView.bind(this),
        GeneratedNode: this.visitGenerated.bind(this),
        DefaultValueNode: this.visitDefaultValue.bind(this),
        OnNode: this.visitOn.bind(this),
        ValuesNode: this.visitValues.bind(this),
        SelectModifierNode: this.visitSelectModifier.bind(this),
        CreateTypeNode: this.visitCreateType.bind(this),
        DropTypeNode: this.visitDropType.bind(this),
        ExplainNode: this.visitExplain.bind(this),
        DefaultInsertValueNode: this.visitDefaultInsertValue.bind(this),
        AggregateFunctionNode: this.visitAggregateFunction.bind(this),
        OverNode: this.visitOver.bind(this),
        PartitionByNode: this.visitPartitionBy.bind(this),
        PartitionByItemNode: this.visitPartitionByItem.bind(this),
        SetOperationNode: this.visitSetOperation.bind(this),
        BinaryOperationNode: this.visitBinaryOperation.bind(this),
        UnaryOperationNode: this.visitUnaryOperation.bind(this),
        UsingNode: this.visitUsing.bind(this),
        FunctionNode: this.visitFunction.bind(this),
        CaseNode: this.visitCase.bind(this),
        WhenNode: this.visitWhen.bind(this),
        JSONReferenceNode: this.visitJSONReference.bind(this),
        JSONPathNode: this.visitJSONPath.bind(this),
        JSONPathLegNode: this.visitJSONPathLeg.bind(this),
        JSONOperatorChainNode: this.visitJSONOperatorChain.bind(this),
        TupleNode: this.visitTuple.bind(this),
        MergeQueryNode: this.visitMergeQuery.bind(this),
        MatchedNode: this.visitMatched.bind(this),
        AddIndexNode: this.visitAddIndex.bind(this),
        CastNode: this.visitCast.bind(this),
        FetchNode: this.visitFetch.bind(this),
        TopNode: this.visitTop.bind(this),
        OutputNode: this.visitOutput.bind(this)
      });
      visitNode = /* @__PURE__ */ __name((node) => {
        this.nodeStack.push(node);
        this.#visitors[node.kind](node);
        this.nodeStack.pop();
      }, "visitNode");
    };
  }
});

// node_modules/kysely/dist/esm/query-compiler/default-query-compiler.js
var DefaultQueryCompiler, SELECT_MODIFIER_SQL, SELECT_MODIFIER_PRIORITY, JOIN_TYPE_SQL;
var init_default_query_compiler = __esm({
  "node_modules/kysely/dist/esm/query-compiler/default-query-compiler.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_create_table_node();
    init_insert_query_node();
    init_operation_node_visitor();
    init_operator_node();
    init_parens_node();
    init_query_node();
    init_object_utils();
    init_create_view_node();
    init_set_operation_node();
    init_merge_query_node();
    DefaultQueryCompiler = class extends OperationNodeVisitor {
      static {
        __name(this, "DefaultQueryCompiler");
      }
      #sql = "";
      #parameters = [];
      get numParameters() {
        return this.#parameters.length;
      }
      compileQuery(node) {
        this.#sql = "";
        this.#parameters = [];
        this.nodeStack.splice(0, this.nodeStack.length);
        this.visitNode(node);
        return freeze({
          query: node,
          sql: this.getSql(),
          parameters: [...this.#parameters]
        });
      }
      getSql() {
        return this.#sql;
      }
      visitSelectQuery(node) {
        const wrapInParens = this.parentNode !== void 0 && !ParensNode.is(this.parentNode) && !InsertQueryNode.is(this.parentNode) && !CreateTableNode.is(this.parentNode) && !CreateViewNode.is(this.parentNode) && !SetOperationNode.is(this.parentNode);
        if (this.parentNode === void 0 && node.explain) {
          this.visitNode(node.explain);
          this.append(" ");
        }
        if (wrapInParens) {
          this.append("(");
        }
        if (node.with) {
          this.visitNode(node.with);
          this.append(" ");
        }
        this.append("select");
        if (node.distinctOn) {
          this.append(" ");
          this.compileDistinctOn(node.distinctOn);
        }
        if (node.frontModifiers?.length) {
          this.append(" ");
          this.compileList(node.frontModifiers, " ");
        }
        if (node.top) {
          this.append(" ");
          this.visitNode(node.top);
        }
        if (node.selections) {
          this.append(" ");
          this.compileList(node.selections);
        }
        if (node.from) {
          this.append(" ");
          this.visitNode(node.from);
        }
        if (node.joins) {
          this.append(" ");
          this.compileList(node.joins, " ");
        }
        if (node.where) {
          this.append(" ");
          this.visitNode(node.where);
        }
        if (node.groupBy) {
          this.append(" ");
          this.visitNode(node.groupBy);
        }
        if (node.having) {
          this.append(" ");
          this.visitNode(node.having);
        }
        if (node.setOperations) {
          this.append(" ");
          this.compileList(node.setOperations, " ");
        }
        if (node.orderBy) {
          this.append(" ");
          this.visitNode(node.orderBy);
        }
        if (node.limit) {
          this.append(" ");
          this.visitNode(node.limit);
        }
        if (node.offset) {
          this.append(" ");
          this.visitNode(node.offset);
        }
        if (node.fetch) {
          this.append(" ");
          this.visitNode(node.fetch);
        }
        if (node.endModifiers?.length) {
          this.append(" ");
          this.compileList(this.sortSelectModifiers([...node.endModifiers]), " ");
        }
        if (wrapInParens) {
          this.append(")");
        }
      }
      visitFrom(node) {
        this.append("from ");
        this.compileList(node.froms);
      }
      visitSelection(node) {
        this.visitNode(node.selection);
      }
      visitColumn(node) {
        this.visitNode(node.column);
      }
      compileDistinctOn(expressions) {
        this.append("distinct on (");
        this.compileList(expressions);
        this.append(")");
      }
      compileList(nodes, separator = ", ") {
        const lastIndex = nodes.length - 1;
        for (let i = 0; i <= lastIndex; i++) {
          this.visitNode(nodes[i]);
          if (i < lastIndex) {
            this.append(separator);
          }
        }
      }
      visitWhere(node) {
        this.append("where ");
        this.visitNode(node.where);
      }
      visitHaving(node) {
        this.append("having ");
        this.visitNode(node.having);
      }
      visitInsertQuery(node) {
        const rootQueryNode = this.nodeStack.find(QueryNode.is);
        const isSubQuery = rootQueryNode !== node;
        if (!isSubQuery && node.explain) {
          this.visitNode(node.explain);
          this.append(" ");
        }
        if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
          this.append("(");
        }
        if (node.with) {
          this.visitNode(node.with);
          this.append(" ");
        }
        this.append(node.replace ? "replace" : "insert");
        if (node.ignore) {
          this.append(" ignore");
        }
        if (node.top) {
          this.append(" ");
          this.visitNode(node.top);
        }
        if (node.into) {
          this.append(" into ");
          this.visitNode(node.into);
        }
        if (node.columns) {
          this.append(" (");
          this.compileList(node.columns);
          this.append(")");
        }
        if (node.output) {
          this.append(" ");
          this.visitNode(node.output);
        }
        if (node.values) {
          this.append(" ");
          this.visitNode(node.values);
        }
        if (node.defaultValues) {
          this.append(" ");
          this.append("default values");
        }
        if (node.onConflict) {
          this.append(" ");
          this.visitNode(node.onConflict);
        }
        if (node.onDuplicateKey) {
          this.append(" ");
          this.visitNode(node.onDuplicateKey);
        }
        if (node.returning) {
          this.append(" ");
          this.visitNode(node.returning);
        }
        if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
          this.append(")");
        }
        if (node.endModifiers?.length) {
          this.append(" ");
          this.compileList(node.endModifiers, " ");
        }
      }
      visitValues(node) {
        this.append("values ");
        this.compileList(node.values);
      }
      visitDeleteQuery(node) {
        const isSubQuery = this.nodeStack.find(QueryNode.is) !== node;
        if (!isSubQuery && node.explain) {
          this.visitNode(node.explain);
          this.append(" ");
        }
        if (isSubQuery) {
          this.append("(");
        }
        if (node.with) {
          this.visitNode(node.with);
          this.append(" ");
        }
        this.append("delete ");
        if (node.top) {
          this.visitNode(node.top);
          this.append(" ");
        }
        this.visitNode(node.from);
        if (node.output) {
          this.append(" ");
          this.visitNode(node.output);
        }
        if (node.using) {
          this.append(" ");
          this.visitNode(node.using);
        }
        if (node.joins) {
          this.append(" ");
          this.compileList(node.joins, " ");
        }
        if (node.where) {
          this.append(" ");
          this.visitNode(node.where);
        }
        if (node.orderBy) {
          this.append(" ");
          this.visitNode(node.orderBy);
        }
        if (node.limit) {
          this.append(" ");
          this.visitNode(node.limit);
        }
        if (node.returning) {
          this.append(" ");
          this.visitNode(node.returning);
        }
        if (isSubQuery) {
          this.append(")");
        }
        if (node.endModifiers?.length) {
          this.append(" ");
          this.compileList(node.endModifiers, " ");
        }
      }
      visitReturning(node) {
        this.append("returning ");
        this.compileList(node.selections);
      }
      visitAlias(node) {
        this.visitNode(node.node);
        this.append(" as ");
        this.visitNode(node.alias);
      }
      visitReference(node) {
        if (node.table) {
          this.visitNode(node.table);
          this.append(".");
        }
        this.visitNode(node.column);
      }
      visitSelectAll(_) {
        this.append("*");
      }
      visitIdentifier(node) {
        this.append(this.getLeftIdentifierWrapper());
        this.compileUnwrappedIdentifier(node);
        this.append(this.getRightIdentifierWrapper());
      }
      compileUnwrappedIdentifier(node) {
        if (!isString(node.name)) {
          throw new Error("a non-string identifier was passed to compileUnwrappedIdentifier.");
        }
        this.append(this.sanitizeIdentifier(node.name));
      }
      visitAnd(node) {
        this.visitNode(node.left);
        this.append(" and ");
        this.visitNode(node.right);
      }
      visitOr(node) {
        this.visitNode(node.left);
        this.append(" or ");
        this.visitNode(node.right);
      }
      visitValue(node) {
        if (node.immediate) {
          this.appendImmediateValue(node.value);
        } else {
          this.appendValue(node.value);
        }
      }
      visitValueList(node) {
        this.append("(");
        this.compileList(node.values);
        this.append(")");
      }
      visitTuple(node) {
        this.append("(");
        this.compileList(node.values);
        this.append(")");
      }
      visitPrimitiveValueList(node) {
        this.append("(");
        const { values } = node;
        for (let i = 0; i < values.length; ++i) {
          this.appendValue(values[i]);
          if (i !== values.length - 1) {
            this.append(", ");
          }
        }
        this.append(")");
      }
      visitParens(node) {
        this.append("(");
        this.visitNode(node.node);
        this.append(")");
      }
      visitJoin(node) {
        this.append(JOIN_TYPE_SQL[node.joinType]);
        this.append(" ");
        this.visitNode(node.table);
        if (node.on) {
          this.append(" ");
          this.visitNode(node.on);
        }
      }
      visitOn(node) {
        this.append("on ");
        this.visitNode(node.on);
      }
      visitRaw(node) {
        const { sqlFragments, parameters: params } = node;
        for (let i = 0; i < sqlFragments.length; ++i) {
          this.append(sqlFragments[i]);
          if (params.length > i) {
            this.visitNode(params[i]);
          }
        }
      }
      visitOperator(node) {
        this.append(node.operator);
      }
      visitTable(node) {
        this.visitNode(node.table);
      }
      visitSchemableIdentifier(node) {
        if (node.schema) {
          this.visitNode(node.schema);
          this.append(".");
        }
        this.visitNode(node.identifier);
      }
      visitCreateTable(node) {
        this.append("create ");
        if (node.frontModifiers && node.frontModifiers.length > 0) {
          this.compileList(node.frontModifiers, " ");
          this.append(" ");
        }
        if (node.temporary) {
          this.append("temporary ");
        }
        this.append("table ");
        if (node.ifNotExists) {
          this.append("if not exists ");
        }
        this.visitNode(node.table);
        if (node.selectQuery) {
          this.append(" as ");
          this.visitNode(node.selectQuery);
        } else {
          this.append(" (");
          this.compileList([...node.columns, ...node.constraints ?? []]);
          this.append(")");
          if (node.onCommit) {
            this.append(" on commit ");
            this.append(node.onCommit);
          }
          if (node.endModifiers && node.endModifiers.length > 0) {
            this.append(" ");
            this.compileList(node.endModifiers, " ");
          }
        }
      }
      visitColumnDefinition(node) {
        if (node.ifNotExists) {
          this.append("if not exists ");
        }
        this.visitNode(node.column);
        this.append(" ");
        this.visitNode(node.dataType);
        if (node.unsigned) {
          this.append(" unsigned");
        }
        if (node.frontModifiers && node.frontModifiers.length > 0) {
          this.append(" ");
          this.compileList(node.frontModifiers, " ");
        }
        if (node.generated) {
          this.append(" ");
          this.visitNode(node.generated);
        }
        if (node.identity) {
          this.append(" identity");
        }
        if (node.defaultTo) {
          this.append(" ");
          this.visitNode(node.defaultTo);
        }
        if (node.notNull) {
          this.append(" not null");
        }
        if (node.unique) {
          this.append(" unique");
        }
        if (node.nullsNotDistinct) {
          this.append(" nulls not distinct");
        }
        if (node.primaryKey) {
          this.append(" primary key");
        }
        if (node.autoIncrement) {
          this.append(" ");
          this.append(this.getAutoIncrement());
        }
        if (node.references) {
          this.append(" ");
          this.visitNode(node.references);
        }
        if (node.check) {
          this.append(" ");
          this.visitNode(node.check);
        }
        if (node.endModifiers && node.endModifiers.length > 0) {
          this.append(" ");
          this.compileList(node.endModifiers, " ");
        }
      }
      getAutoIncrement() {
        return "auto_increment";
      }
      visitReferences(node) {
        this.append("references ");
        this.visitNode(node.table);
        this.append(" (");
        this.compileList(node.columns);
        this.append(")");
        if (node.onDelete) {
          this.append(" on delete ");
          this.append(node.onDelete);
        }
        if (node.onUpdate) {
          this.append(" on update ");
          this.append(node.onUpdate);
        }
      }
      visitDropTable(node) {
        this.append("drop table ");
        if (node.ifExists) {
          this.append("if exists ");
        }
        this.visitNode(node.table);
        if (node.cascade) {
          this.append(" cascade");
        }
      }
      visitDataType(node) {
        this.append(node.dataType);
      }
      visitOrderBy(node) {
        this.append("order by ");
        this.compileList(node.items);
      }
      visitOrderByItem(node) {
        this.visitNode(node.orderBy);
        if (node.direction) {
          this.append(" ");
          this.visitNode(node.direction);
        }
      }
      visitGroupBy(node) {
        this.append("group by ");
        this.compileList(node.items);
      }
      visitGroupByItem(node) {
        this.visitNode(node.groupBy);
      }
      visitUpdateQuery(node) {
        const rootQueryNode = this.nodeStack.find(QueryNode.is);
        const isSubQuery = rootQueryNode !== node;
        if (!isSubQuery && node.explain) {
          this.visitNode(node.explain);
          this.append(" ");
        }
        if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
          this.append("(");
        }
        if (node.with) {
          this.visitNode(node.with);
          this.append(" ");
        }
        this.append("update ");
        if (node.top) {
          this.visitNode(node.top);
          this.append(" ");
        }
        if (node.table) {
          this.visitNode(node.table);
          this.append(" ");
        }
        this.append("set ");
        if (node.updates) {
          this.compileList(node.updates);
        }
        if (node.output) {
          this.append(" ");
          this.visitNode(node.output);
        }
        if (node.from) {
          this.append(" ");
          this.visitNode(node.from);
        }
        if (node.joins) {
          this.append(" ");
          this.compileList(node.joins, " ");
        }
        if (node.where) {
          this.append(" ");
          this.visitNode(node.where);
        }
        if (node.limit) {
          this.append(" ");
          this.visitNode(node.limit);
        }
        if (node.returning) {
          this.append(" ");
          this.visitNode(node.returning);
        }
        if (isSubQuery && !MergeQueryNode.is(rootQueryNode)) {
          this.append(")");
        }
        if (node.endModifiers?.length) {
          this.append(" ");
          this.compileList(node.endModifiers, " ");
        }
      }
      visitColumnUpdate(node) {
        this.visitNode(node.column);
        this.append(" = ");
        this.visitNode(node.value);
      }
      visitLimit(node) {
        this.append("limit ");
        this.visitNode(node.limit);
      }
      visitOffset(node) {
        this.append("offset ");
        this.visitNode(node.offset);
      }
      visitOnConflict(node) {
        this.append("on conflict");
        if (node.columns) {
          this.append(" (");
          this.compileList(node.columns);
          this.append(")");
        } else if (node.constraint) {
          this.append(" on constraint ");
          this.visitNode(node.constraint);
        } else if (node.indexExpression) {
          this.append(" (");
          this.visitNode(node.indexExpression);
          this.append(")");
        }
        if (node.indexWhere) {
          this.append(" ");
          this.visitNode(node.indexWhere);
        }
        if (node.doNothing === true) {
          this.append(" do nothing");
        } else if (node.updates) {
          this.append(" do update set ");
          this.compileList(node.updates);
          if (node.updateWhere) {
            this.append(" ");
            this.visitNode(node.updateWhere);
          }
        }
      }
      visitOnDuplicateKey(node) {
        this.append("on duplicate key update ");
        this.compileList(node.updates);
      }
      visitCreateIndex(node) {
        this.append("create ");
        if (node.unique) {
          this.append("unique ");
        }
        this.append("index ");
        if (node.ifNotExists) {
          this.append("if not exists ");
        }
        this.visitNode(node.name);
        if (node.table) {
          this.append(" on ");
          this.visitNode(node.table);
        }
        if (node.using) {
          this.append(" using ");
          this.visitNode(node.using);
        }
        if (node.columns) {
          this.append(" (");
          this.compileList(node.columns);
          this.append(")");
        }
        if (node.nullsNotDistinct) {
          this.append(" nulls not distinct");
        }
        if (node.where) {
          this.append(" ");
          this.visitNode(node.where);
        }
      }
      visitDropIndex(node) {
        this.append("drop index ");
        if (node.ifExists) {
          this.append("if exists ");
        }
        this.visitNode(node.name);
        if (node.table) {
          this.append(" on ");
          this.visitNode(node.table);
        }
        if (node.cascade) {
          this.append(" cascade");
        }
      }
      visitCreateSchema(node) {
        this.append("create schema ");
        if (node.ifNotExists) {
          this.append("if not exists ");
        }
        this.visitNode(node.schema);
      }
      visitDropSchema(node) {
        this.append("drop schema ");
        if (node.ifExists) {
          this.append("if exists ");
        }
        this.visitNode(node.schema);
        if (node.cascade) {
          this.append(" cascade");
        }
      }
      visitPrimaryKeyConstraint(node) {
        if (node.name) {
          this.append("constraint ");
          this.visitNode(node.name);
          this.append(" ");
        }
        this.append("primary key (");
        this.compileList(node.columns);
        this.append(")");
      }
      visitUniqueConstraint(node) {
        if (node.name) {
          this.append("constraint ");
          this.visitNode(node.name);
          this.append(" ");
        }
        this.append("unique");
        if (node.nullsNotDistinct) {
          this.append(" nulls not distinct");
        }
        this.append(" (");
        this.compileList(node.columns);
        this.append(")");
      }
      visitCheckConstraint(node) {
        if (node.name) {
          this.append("constraint ");
          this.visitNode(node.name);
          this.append(" ");
        }
        this.append("check (");
        this.visitNode(node.expression);
        this.append(")");
      }
      visitForeignKeyConstraint(node) {
        if (node.name) {
          this.append("constraint ");
          this.visitNode(node.name);
          this.append(" ");
        }
        this.append("foreign key (");
        this.compileList(node.columns);
        this.append(") ");
        this.visitNode(node.references);
        if (node.onDelete) {
          this.append(" on delete ");
          this.append(node.onDelete);
        }
        if (node.onUpdate) {
          this.append(" on update ");
          this.append(node.onUpdate);
        }
      }
      visitList(node) {
        this.compileList(node.items);
      }
      visitWith(node) {
        this.append("with ");
        if (node.recursive) {
          this.append("recursive ");
        }
        this.compileList(node.expressions);
      }
      visitCommonTableExpression(node) {
        this.visitNode(node.name);
        this.append(" as ");
        if (isBoolean(node.materialized)) {
          if (!node.materialized) {
            this.append("not ");
          }
          this.append("materialized ");
        }
        this.visitNode(node.expression);
      }
      visitCommonTableExpressionName(node) {
        this.visitNode(node.table);
        if (node.columns) {
          this.append("(");
          this.compileList(node.columns);
          this.append(")");
        }
      }
      visitAlterTable(node) {
        this.append("alter table ");
        this.visitNode(node.table);
        this.append(" ");
        if (node.renameTo) {
          this.append("rename to ");
          this.visitNode(node.renameTo);
        }
        if (node.setSchema) {
          this.append("set schema ");
          this.visitNode(node.setSchema);
        }
        if (node.addConstraint) {
          this.visitNode(node.addConstraint);
        }
        if (node.dropConstraint) {
          this.visitNode(node.dropConstraint);
        }
        if (node.columnAlterations) {
          this.compileColumnAlterations(node.columnAlterations);
        }
        if (node.addIndex) {
          this.visitNode(node.addIndex);
        }
        if (node.dropIndex) {
          this.visitNode(node.dropIndex);
        }
      }
      visitAddColumn(node) {
        this.append("add column ");
        this.visitNode(node.column);
      }
      visitRenameColumn(node) {
        this.append("rename column ");
        this.visitNode(node.column);
        this.append(" to ");
        this.visitNode(node.renameTo);
      }
      visitDropColumn(node) {
        this.append("drop column ");
        this.visitNode(node.column);
      }
      visitAlterColumn(node) {
        this.append("alter column ");
        this.visitNode(node.column);
        this.append(" ");
        if (node.dataType) {
          if (this.announcesNewColumnDataType()) {
            this.append("type ");
          }
          this.visitNode(node.dataType);
          if (node.dataTypeExpression) {
            this.append("using ");
            this.visitNode(node.dataTypeExpression);
          }
        }
        if (node.setDefault) {
          this.append("set default ");
          this.visitNode(node.setDefault);
        }
        if (node.dropDefault) {
          this.append("drop default");
        }
        if (node.setNotNull) {
          this.append("set not null");
        }
        if (node.dropNotNull) {
          this.append("drop not null");
        }
      }
      visitModifyColumn(node) {
        this.append("modify column ");
        this.visitNode(node.column);
      }
      visitAddConstraint(node) {
        this.append("add ");
        this.visitNode(node.constraint);
      }
      visitDropConstraint(node) {
        this.append("drop constraint ");
        if (node.ifExists) {
          this.append("if exists ");
        }
        this.visitNode(node.constraintName);
        if (node.modifier === "cascade") {
          this.append(" cascade");
        } else if (node.modifier === "restrict") {
          this.append(" restrict");
        }
      }
      visitSetOperation(node) {
        this.append(node.operator);
        this.append(" ");
        if (node.all) {
          this.append("all ");
        }
        this.visitNode(node.expression);
      }
      visitCreateView(node) {
        this.append("create ");
        if (node.orReplace) {
          this.append("or replace ");
        }
        if (node.materialized) {
          this.append("materialized ");
        }
        if (node.temporary) {
          this.append("temporary ");
        }
        this.append("view ");
        if (node.ifNotExists) {
          this.append("if not exists ");
        }
        this.visitNode(node.name);
        this.append(" ");
        if (node.columns) {
          this.append("(");
          this.compileList(node.columns);
          this.append(") ");
        }
        if (node.as) {
          this.append("as ");
          this.visitNode(node.as);
        }
      }
      visitDropView(node) {
        this.append("drop ");
        if (node.materialized) {
          this.append("materialized ");
        }
        this.append("view ");
        if (node.ifExists) {
          this.append("if exists ");
        }
        this.visitNode(node.name);
        if (node.cascade) {
          this.append(" cascade");
        }
      }
      visitGenerated(node) {
        this.append("generated ");
        if (node.always) {
          this.append("always ");
        }
        if (node.byDefault) {
          this.append("by default ");
        }
        this.append("as ");
        if (node.identity) {
          this.append("identity");
        }
        if (node.expression) {
          this.append("(");
          this.visitNode(node.expression);
          this.append(")");
        }
        if (node.stored) {
          this.append(" stored");
        }
      }
      visitDefaultValue(node) {
        this.append("default ");
        this.visitNode(node.defaultValue);
      }
      visitSelectModifier(node) {
        if (node.rawModifier) {
          this.visitNode(node.rawModifier);
        } else {
          this.append(SELECT_MODIFIER_SQL[node.modifier]);
        }
        if (node.of) {
          this.append(" of ");
          this.compileList(node.of, ", ");
        }
      }
      visitCreateType(node) {
        this.append("create type ");
        this.visitNode(node.name);
        if (node.enum) {
          this.append(" as enum ");
          this.visitNode(node.enum);
        }
      }
      visitDropType(node) {
        this.append("drop type ");
        if (node.ifExists) {
          this.append("if exists ");
        }
        this.visitNode(node.name);
      }
      visitExplain(node) {
        this.append("explain");
        if (node.options || node.format) {
          this.append(" ");
          this.append(this.getLeftExplainOptionsWrapper());
          if (node.options) {
            this.visitNode(node.options);
            if (node.format) {
              this.append(this.getExplainOptionsDelimiter());
            }
          }
          if (node.format) {
            this.append("format");
            this.append(this.getExplainOptionAssignment());
            this.append(node.format);
          }
          this.append(this.getRightExplainOptionsWrapper());
        }
      }
      visitDefaultInsertValue(_) {
        this.append("default");
      }
      visitAggregateFunction(node) {
        this.append(node.func);
        this.append("(");
        if (node.distinct) {
          this.append("distinct ");
        }
        this.compileList(node.aggregated);
        if (node.orderBy) {
          this.append(" ");
          this.visitNode(node.orderBy);
        }
        this.append(")");
        if (node.filter) {
          this.append(" filter(");
          this.visitNode(node.filter);
          this.append(")");
        }
        if (node.over) {
          this.append(" ");
          this.visitNode(node.over);
        }
      }
      visitOver(node) {
        this.append("over(");
        if (node.partitionBy) {
          this.visitNode(node.partitionBy);
          if (node.orderBy) {
            this.append(" ");
          }
        }
        if (node.orderBy) {
          this.visitNode(node.orderBy);
        }
        this.append(")");
      }
      visitPartitionBy(node) {
        this.append("partition by ");
        this.compileList(node.items);
      }
      visitPartitionByItem(node) {
        this.visitNode(node.partitionBy);
      }
      visitBinaryOperation(node) {
        this.visitNode(node.leftOperand);
        this.append(" ");
        this.visitNode(node.operator);
        this.append(" ");
        this.visitNode(node.rightOperand);
      }
      visitUnaryOperation(node) {
        this.visitNode(node.operator);
        if (!this.isMinusOperator(node.operator)) {
          this.append(" ");
        }
        this.visitNode(node.operand);
      }
      isMinusOperator(node) {
        return OperatorNode.is(node) && node.operator === "-";
      }
      visitUsing(node) {
        this.append("using ");
        this.compileList(node.tables);
      }
      visitFunction(node) {
        this.append(node.func);
        this.append("(");
        this.compileList(node.arguments);
        this.append(")");
      }
      visitCase(node) {
        this.append("case");
        if (node.value) {
          this.append(" ");
          this.visitNode(node.value);
        }
        if (node.when) {
          this.append(" ");
          this.compileList(node.when, " ");
        }
        if (node.else) {
          this.append(" else ");
          this.visitNode(node.else);
        }
        this.append(" end");
        if (node.isStatement) {
          this.append(" case");
        }
      }
      visitWhen(node) {
        this.append("when ");
        this.visitNode(node.condition);
        if (node.result) {
          this.append(" then ");
          this.visitNode(node.result);
        }
      }
      visitJSONReference(node) {
        this.visitNode(node.reference);
        this.visitNode(node.traversal);
      }
      visitJSONPath(node) {
        if (node.inOperator) {
          this.visitNode(node.inOperator);
        }
        this.append("'$");
        for (const pathLeg of node.pathLegs) {
          this.visitNode(pathLeg);
        }
        this.append("'");
      }
      visitJSONPathLeg(node) {
        const isArrayLocation = node.type === "ArrayLocation";
        this.append(isArrayLocation ? "[" : ".");
        this.append(String(node.value));
        if (isArrayLocation) {
          this.append("]");
        }
      }
      visitJSONOperatorChain(node) {
        for (let i = 0, len = node.values.length; i < len; i++) {
          if (i === len - 1) {
            this.visitNode(node.operator);
          } else {
            this.append("->");
          }
          this.visitNode(node.values[i]);
        }
      }
      visitMergeQuery(node) {
        if (node.with) {
          this.visitNode(node.with);
          this.append(" ");
        }
        this.append("merge ");
        if (node.top) {
          this.visitNode(node.top);
          this.append(" ");
        }
        this.append("into ");
        this.visitNode(node.into);
        if (node.using) {
          this.append(" ");
          this.visitNode(node.using);
        }
        if (node.whens) {
          this.append(" ");
          this.compileList(node.whens, " ");
        }
        if (node.output) {
          this.append(" ");
          this.visitNode(node.output);
        }
        if (node.endModifiers?.length) {
          this.append(" ");
          this.compileList(node.endModifiers, " ");
        }
      }
      visitMatched(node) {
        if (node.not) {
          this.append("not ");
        }
        this.append("matched");
        if (node.bySource) {
          this.append(" by source");
        }
      }
      visitAddIndex(node) {
        this.append("add ");
        if (node.unique) {
          this.append("unique ");
        }
        this.append("index ");
        this.visitNode(node.name);
        if (node.columns) {
          this.append(" (");
          this.compileList(node.columns);
          this.append(")");
        }
        if (node.using) {
          this.append(" using ");
          this.visitNode(node.using);
        }
      }
      visitCast(node) {
        this.append("cast(");
        this.visitNode(node.expression);
        this.append(" as ");
        this.visitNode(node.dataType);
        this.append(")");
      }
      visitFetch(node) {
        this.append("fetch next ");
        this.visitNode(node.rowCount);
        this.append(` rows ${node.modifier}`);
      }
      visitOutput(node) {
        this.append("output ");
        this.compileList(node.selections);
      }
      visitTop(node) {
        this.append(`top(${node.expression})`);
        if (node.modifiers) {
          this.append(` ${node.modifiers}`);
        }
      }
      append(str) {
        this.#sql += str;
      }
      appendValue(parameter) {
        this.addParameter(parameter);
        this.append(this.getCurrentParameterPlaceholder());
      }
      getLeftIdentifierWrapper() {
        return '"';
      }
      getRightIdentifierWrapper() {
        return '"';
      }
      getCurrentParameterPlaceholder() {
        return "$" + this.numParameters;
      }
      getLeftExplainOptionsWrapper() {
        return "(";
      }
      getExplainOptionAssignment() {
        return " ";
      }
      getExplainOptionsDelimiter() {
        return ", ";
      }
      getRightExplainOptionsWrapper() {
        return ")";
      }
      sanitizeIdentifier(identifier) {
        const leftWrap = this.getLeftIdentifierWrapper();
        const rightWrap = this.getRightIdentifierWrapper();
        let sanitized = "";
        for (const c of identifier) {
          sanitized += c;
          if (c === leftWrap) {
            sanitized += leftWrap;
          } else if (c === rightWrap) {
            sanitized += rightWrap;
          }
        }
        return sanitized;
      }
      addParameter(parameter) {
        this.#parameters.push(parameter);
      }
      appendImmediateValue(value) {
        if (isString(value)) {
          this.append(`'${value}'`);
        } else if (isNumber(value) || isBoolean(value)) {
          this.append(value.toString());
        } else if (isNull(value)) {
          this.append("null");
        } else if (isDate(value)) {
          this.appendImmediateValue(value.toISOString());
        } else if (isBigInt(value)) {
          this.appendImmediateValue(value.toString());
        } else {
          throw new Error(`invalid immediate value ${value}`);
        }
      }
      sortSelectModifiers(arr) {
        arr.sort((left, right) => left.modifier && right.modifier ? SELECT_MODIFIER_PRIORITY[left.modifier] - SELECT_MODIFIER_PRIORITY[right.modifier] : 1);
        return freeze(arr);
      }
      compileColumnAlterations(columnAlterations) {
        this.compileList(columnAlterations);
      }
      /**
       * controls whether the dialect adds a "type" keyword before a column's new data
       * type in an ALTER TABLE statement.
       */
      announcesNewColumnDataType() {
        return true;
      }
    };
    SELECT_MODIFIER_SQL = freeze({
      ForKeyShare: "for key share",
      ForNoKeyUpdate: "for no key update",
      ForUpdate: "for update",
      ForShare: "for share",
      NoWait: "nowait",
      SkipLocked: "skip locked",
      Distinct: "distinct"
    });
    SELECT_MODIFIER_PRIORITY = freeze({
      ForKeyShare: 1,
      ForNoKeyUpdate: 1,
      ForUpdate: 1,
      ForShare: 1,
      NoWait: 2,
      SkipLocked: 2,
      Distinct: 0
    });
    JOIN_TYPE_SQL = freeze({
      InnerJoin: "inner join",
      LeftJoin: "left join",
      RightJoin: "right join",
      FullJoin: "full join",
      LateralInnerJoin: "inner join lateral",
      LateralLeftJoin: "left join lateral",
      Using: "using"
    });
  }
});

// node_modules/kysely/dist/esm/query-compiler/compiled-query.js
var CompiledQuery;
var init_compiled_query = __esm({
  "node_modules/kysely/dist/esm/query-compiler/compiled-query.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_raw_node();
    init_object_utils();
    CompiledQuery = freeze({
      raw(sql2, parameters = []) {
        return freeze({
          sql: sql2,
          query: RawNode.createWithSql(sql2),
          parameters: freeze(parameters)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/driver/database-connection.js
var init_database_connection = __esm({
  "node_modules/kysely/dist/esm/driver/database-connection.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/driver/connection-provider.js
var init_connection_provider = __esm({
  "node_modules/kysely/dist/esm/driver/connection-provider.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/driver/dummy-driver.js
var init_dummy_driver = __esm({
  "node_modules/kysely/dist/esm/driver/dummy-driver.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/dialect.js
var init_dialect = __esm({
  "node_modules/kysely/dist/esm/dialect/dialect.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/dialect-adapter.js
var init_dialect_adapter = __esm({
  "node_modules/kysely/dist/esm/dialect/dialect-adapter.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/dialect-adapter-base.js
var DialectAdapterBase;
var init_dialect_adapter_base = __esm({
  "node_modules/kysely/dist/esm/dialect/dialect-adapter-base.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    DialectAdapterBase = class {
      static {
        __name(this, "DialectAdapterBase");
      }
      get supportsCreateIfNotExists() {
        return true;
      }
      get supportsTransactionalDdl() {
        return false;
      }
      get supportsReturning() {
        return false;
      }
      get supportsOutput() {
        return false;
      }
    };
  }
});

// node_modules/kysely/dist/esm/dialect/database-introspector.js
var init_database_introspector = __esm({
  "node_modules/kysely/dist/esm/dialect/database-introspector.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/sqlite/sqlite-driver.js
var init_sqlite_driver = __esm({
  "node_modules/kysely/dist/esm/dialect/sqlite/sqlite-driver.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/sqlite/sqlite-query-compiler.js
var ID_WRAP_REGEX, SqliteQueryCompiler;
var init_sqlite_query_compiler = __esm({
  "node_modules/kysely/dist/esm/dialect/sqlite/sqlite-query-compiler.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_default_query_compiler();
    ID_WRAP_REGEX = /"/g;
    SqliteQueryCompiler = class extends DefaultQueryCompiler {
      static {
        __name(this, "SqliteQueryCompiler");
      }
      getCurrentParameterPlaceholder() {
        return "?";
      }
      getLeftExplainOptionsWrapper() {
        return "";
      }
      getRightExplainOptionsWrapper() {
        return "";
      }
      getLeftIdentifierWrapper() {
        return '"';
      }
      getRightIdentifierWrapper() {
        return '"';
      }
      getAutoIncrement() {
        return "autoincrement";
      }
      sanitizeIdentifier(identifier) {
        return identifier.replace(ID_WRAP_REGEX, '""');
      }
      visitDefaultInsertValue(_) {
        this.append("null");
      }
    };
  }
});

// node_modules/kysely/dist/esm/migration/migrator.js
var DEFAULT_MIGRATION_TABLE, DEFAULT_MIGRATION_LOCK_TABLE, NO_MIGRATIONS;
var init_migrator = __esm({
  "node_modules/kysely/dist/esm/migration/migrator.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    DEFAULT_MIGRATION_TABLE = "kysely_migration";
    DEFAULT_MIGRATION_LOCK_TABLE = "kysely_migration_lock";
    NO_MIGRATIONS = freeze({ __noMigrations__: true });
  }
});

// node_modules/kysely/dist/esm/dialect/sqlite/sqlite-introspector.js
var SqliteIntrospector;
var init_sqlite_introspector = __esm({
  "node_modules/kysely/dist/esm/dialect/sqlite/sqlite-introspector.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_migrator();
    init_sql();
    SqliteIntrospector = class {
      static {
        __name(this, "SqliteIntrospector");
      }
      #db;
      constructor(db) {
        this.#db = db;
      }
      async getSchemas() {
        return [];
      }
      async getTables(options = { withInternalKyselyTables: false }) {
        return await this.#getTableMetadata(options);
      }
      async getMetadata(options) {
        return {
          tables: await this.getTables(options)
        };
      }
      #tablesQuery(qb, options) {
        let tablesQuery = qb.selectFrom("sqlite_master").where("type", "in", ["table", "view"]).where("name", "not like", "sqlite_%").select(["name", "sql", "type"]).orderBy("name");
        if (!options.withInternalKyselyTables) {
          tablesQuery = tablesQuery.where("name", "!=", DEFAULT_MIGRATION_TABLE).where("name", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
        }
        return tablesQuery;
      }
      async #getTableMetadata(options) {
        const tablesResult = await this.#tablesQuery(this.#db, options).execute();
        const tableMetadata = await this.#db.with("table_list", (qb) => this.#tablesQuery(qb, options)).selectFrom([
          "table_list as tl",
          sql`pragma_table_info(tl.name)`.as("p")
        ]).select([
          "tl.name as table",
          "p.cid",
          "p.name",
          "p.type",
          "p.notnull",
          "p.dflt_value",
          "p.pk"
        ]).orderBy(["tl.name", "p.cid"]).execute();
        const columnsByTable = {};
        for (const row of tableMetadata) {
          columnsByTable[row.table] ??= [];
          columnsByTable[row.table].push(row);
        }
        return tablesResult.map(({ name, sql: sql2, type }) => {
          let autoIncrementCol = sql2?.split(/[\(\),]/)?.find((it) => it.toLowerCase().includes("autoincrement"))?.trimStart()?.split(/\s+/)?.[0]?.replace(/["`]/g, "");
          const columns = columnsByTable[name] ?? [];
          if (!autoIncrementCol) {
            const pkCols = columns.filter((r) => r.pk > 0);
            if (pkCols.length === 1 && pkCols[0].type.toLowerCase() === "integer") {
              autoIncrementCol = pkCols[0].name;
            }
          }
          return {
            name,
            isView: type === "view",
            columns: columns.map((col) => ({
              name: col.name,
              dataType: col.type,
              isNullable: !col.notnull,
              isAutoIncrementing: col.name === autoIncrementCol,
              hasDefaultValue: col.dflt_value != null,
              comment: void 0
            }))
          };
        });
      }
    };
  }
});

// node_modules/kysely/dist/esm/dialect/sqlite/sqlite-adapter.js
var SqliteAdapter;
var init_sqlite_adapter = __esm({
  "node_modules/kysely/dist/esm/dialect/sqlite/sqlite-adapter.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_dialect_adapter_base();
    SqliteAdapter = class extends DialectAdapterBase {
      static {
        __name(this, "SqliteAdapter");
      }
      get supportsTransactionalDdl() {
        return false;
      }
      get supportsReturning() {
        return true;
      }
      async acquireMigrationLock(_db, _opt) {
      }
      async releaseMigrationLock(_db, _opt) {
      }
    };
  }
});

// node_modules/kysely/dist/esm/dialect/sqlite/sqlite-dialect.js
var init_sqlite_dialect = __esm({
  "node_modules/kysely/dist/esm/dialect/sqlite/sqlite-dialect.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/sqlite/sqlite-dialect-config.js
var init_sqlite_dialect_config = __esm({
  "node_modules/kysely/dist/esm/dialect/sqlite/sqlite-dialect-config.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/postgres/postgres-query-compiler.js
var init_postgres_query_compiler = __esm({
  "node_modules/kysely/dist/esm/dialect/postgres/postgres-query-compiler.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/postgres/postgres-introspector.js
var init_postgres_introspector = __esm({
  "node_modules/kysely/dist/esm/dialect/postgres/postgres-introspector.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/postgres/postgres-adapter.js
var LOCK_ID;
var init_postgres_adapter = __esm({
  "node_modules/kysely/dist/esm/dialect/postgres/postgres-adapter.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    LOCK_ID = BigInt("3853314791062309107");
  }
});

// node_modules/kysely/dist/esm/util/stack-trace-utils.js
function extendStackTrace(err, stackError) {
  if (isStackHolder(err) && stackError.stack) {
    const stackExtension = stackError.stack.split("\n").slice(1).join("\n");
    err.stack += `
${stackExtension}`;
    return err;
  }
  return err;
}
function isStackHolder(obj) {
  return isObject(obj) && isString(obj.stack);
}
var init_stack_trace_utils = __esm({
  "node_modules/kysely/dist/esm/util/stack-trace-utils.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    __name(extendStackTrace, "extendStackTrace");
    __name(isStackHolder, "isStackHolder");
  }
});

// node_modules/kysely/dist/esm/dialect/mysql/mysql-driver.js
function isOkPacket(obj) {
  return isObject(obj) && "insertId" in obj && "affectedRows" in obj;
}
var PRIVATE_RELEASE_METHOD, MysqlConnection;
var init_mysql_driver = __esm({
  "node_modules/kysely/dist/esm/dialect/mysql/mysql-driver.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_stack_trace_utils();
    PRIVATE_RELEASE_METHOD = Symbol();
    __name(isOkPacket, "isOkPacket");
    MysqlConnection = class {
      static {
        __name(this, "MysqlConnection");
      }
      #rawConnection;
      constructor(rawConnection) {
        this.#rawConnection = rawConnection;
      }
      async executeQuery(compiledQuery) {
        try {
          const result = await this.#executeQuery(compiledQuery);
          if (isOkPacket(result)) {
            const { insertId, affectedRows, changedRows } = result;
            const numAffectedRows = affectedRows !== void 0 && affectedRows !== null ? BigInt(affectedRows) : void 0;
            const numChangedRows = changedRows !== void 0 && changedRows !== null ? BigInt(changedRows) : void 0;
            return {
              insertId: insertId !== void 0 && insertId !== null && insertId.toString() !== "0" ? BigInt(insertId) : void 0,
              // TODO: remove.
              numUpdatedOrDeletedRows: numAffectedRows,
              numAffectedRows,
              numChangedRows,
              rows: []
            };
          } else if (Array.isArray(result)) {
            return {
              rows: result
            };
          }
          return {
            rows: []
          };
        } catch (err) {
          throw extendStackTrace(err, new Error());
        }
      }
      #executeQuery(compiledQuery) {
        return new Promise((resolve, reject) => {
          this.#rawConnection.query(compiledQuery.sql, compiledQuery.parameters, (err, result) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          });
        });
      }
      async *streamQuery(compiledQuery, _chunkSize) {
        const stream = this.#rawConnection.query(compiledQuery.sql, compiledQuery.parameters).stream({
          objectMode: true
        });
        try {
          for await (const row of stream) {
            yield {
              rows: [row]
            };
          }
        } catch (ex) {
          if (ex && typeof ex === "object" && "code" in ex && // @ts-ignore
          ex.code === "ERR_STREAM_PREMATURE_CLOSE") {
            return;
          }
          throw ex;
        }
      }
      [PRIVATE_RELEASE_METHOD]() {
        this.#rawConnection.release();
      }
    };
  }
});

// node_modules/kysely/dist/esm/dialect/mysql/mysql-query-compiler.js
var init_mysql_query_compiler = __esm({
  "node_modules/kysely/dist/esm/dialect/mysql/mysql-query-compiler.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/mysql/mysql-introspector.js
var init_mysql_introspector = __esm({
  "node_modules/kysely/dist/esm/dialect/mysql/mysql-introspector.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/mysql/mysql-adapter.js
var LOCK_TIMEOUT_SECONDS;
var init_mysql_adapter = __esm({
  "node_modules/kysely/dist/esm/dialect/mysql/mysql-adapter.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    LOCK_TIMEOUT_SECONDS = 60 * 60;
  }
});

// node_modules/kysely/dist/esm/dialect/mysql/mysql-dialect.js
var init_mysql_dialect = __esm({
  "node_modules/kysely/dist/esm/dialect/mysql/mysql-dialect.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/mysql/mysql-dialect-config.js
var init_mysql_dialect_config = __esm({
  "node_modules/kysely/dist/esm/dialect/mysql/mysql-dialect-config.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/postgres/postgres-driver.js
var PRIVATE_RELEASE_METHOD2, PostgresConnection;
var init_postgres_driver = __esm({
  "node_modules/kysely/dist/esm/dialect/postgres/postgres-driver.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_stack_trace_utils();
    PRIVATE_RELEASE_METHOD2 = Symbol();
    PostgresConnection = class {
      static {
        __name(this, "PostgresConnection");
      }
      #client;
      #options;
      constructor(client, options) {
        this.#client = client;
        this.#options = options;
      }
      async executeQuery(compiledQuery) {
        try {
          const result = await this.#client.query(compiledQuery.sql, [
            ...compiledQuery.parameters
          ]);
          if (result.command === "INSERT" || result.command === "UPDATE" || result.command === "DELETE" || result.command === "MERGE") {
            const numAffectedRows = BigInt(result.rowCount);
            return {
              // TODO: remove.
              numUpdatedOrDeletedRows: numAffectedRows,
              numAffectedRows,
              rows: result.rows ?? []
            };
          }
          return {
            rows: result.rows ?? []
          };
        } catch (err) {
          throw extendStackTrace(err, new Error());
        }
      }
      async *streamQuery(compiledQuery, chunkSize) {
        if (!this.#options.cursor) {
          throw new Error("'cursor' is not present in your postgres dialect config. It's required to make streaming work in postgres.");
        }
        if (!Number.isInteger(chunkSize) || chunkSize <= 0) {
          throw new Error("chunkSize must be a positive integer");
        }
        const cursor = this.#client.query(new this.#options.cursor(compiledQuery.sql, compiledQuery.parameters.slice()));
        try {
          while (true) {
            const rows = await cursor.read(chunkSize);
            if (rows.length === 0) {
              break;
            }
            yield {
              rows
            };
          }
        } finally {
          await cursor.close();
        }
      }
      [PRIVATE_RELEASE_METHOD2]() {
        this.#client.release();
      }
    };
  }
});

// node_modules/kysely/dist/esm/dialect/postgres/postgres-dialect-config.js
var init_postgres_dialect_config = __esm({
  "node_modules/kysely/dist/esm/dialect/postgres/postgres-dialect-config.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/postgres/postgres-dialect.js
var init_postgres_dialect = __esm({
  "node_modules/kysely/dist/esm/dialect/postgres/postgres-dialect.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/mssql/mssql-adapter.js
var init_mssql_adapter = __esm({
  "node_modules/kysely/dist/esm/dialect/mssql/mssql-adapter.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/mssql/mssql-dialect-config.js
var init_mssql_dialect_config = __esm({
  "node_modules/kysely/dist/esm/dialect/mssql/mssql-dialect-config.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/mssql/mssql-driver.js
var PRIVATE_RELEASE_METHOD3, PRIVATE_DESTROY_METHOD, MssqlConnection, MssqlRequest;
var init_mssql_driver = __esm({
  "node_modules/kysely/dist/esm/dialect/mssql/mssql-driver.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    init_compiled_query();
    init_stack_trace_utils();
    init_random_string();
    init_deferred();
    PRIVATE_RELEASE_METHOD3 = Symbol();
    PRIVATE_DESTROY_METHOD = Symbol();
    MssqlConnection = class {
      static {
        __name(this, "MssqlConnection");
      }
      #connection;
      #tedious;
      constructor(connection, tedious) {
        this.#connection = connection;
        this.#tedious = tedious;
        this.#connection.on("error", console.error);
        this.#connection.once("end", () => {
          this.#connection.off("error", console.error);
        });
      }
      async beginTransaction(settings) {
        const { isolationLevel } = settings;
        await new Promise((resolve, reject) => this.#connection.beginTransaction((error) => {
          if (error)
            reject(error);
          else
            resolve(void 0);
        }, isolationLevel ? randomString(8) : void 0, isolationLevel ? this.#getTediousIsolationLevel(isolationLevel) : void 0));
      }
      async commitTransaction() {
        await new Promise((resolve, reject) => this.#connection.commitTransaction((error) => {
          if (error)
            reject(error);
          else
            resolve(void 0);
        }));
      }
      async connect() {
        await new Promise((resolve, reject) => {
          this.#connection.connect((error) => {
            if (error) {
              console.error(error);
              reject(error);
            } else {
              resolve(void 0);
            }
          });
        });
        return this;
      }
      async executeQuery(compiledQuery) {
        try {
          const deferred = new Deferred();
          const request = new MssqlRequest({
            compiledQuery,
            tedious: this.#tedious,
            onDone: deferred
          });
          this.#connection.execSql(request.request);
          const { rowCount, rows } = await deferred.promise;
          return {
            numAffectedRows: rowCount !== void 0 ? BigInt(rowCount) : void 0,
            rows
          };
        } catch (err) {
          throw extendStackTrace(err, new Error());
        }
      }
      async rollbackTransaction() {
        await new Promise((resolve, reject) => this.#connection.rollbackTransaction((error) => {
          if (error)
            reject(error);
          else
            resolve(void 0);
        }));
      }
      async *streamQuery(compiledQuery, chunkSize) {
        if (!Number.isInteger(chunkSize) || chunkSize <= 0) {
          throw new Error("chunkSize must be a positive integer");
        }
        const request = new MssqlRequest({
          compiledQuery,
          streamChunkSize: chunkSize,
          tedious: this.#tedious
        });
        this.#connection.execSql(request.request);
        try {
          while (true) {
            const rows = await request.readChunk();
            if (rows.length === 0) {
              break;
            }
            yield { rows };
            if (rows.length < chunkSize) {
              break;
            }
          }
        } finally {
          await this.#cancelRequest(request);
        }
      }
      async validate() {
        try {
          const deferred = new Deferred();
          const request = new MssqlRequest({
            compiledQuery: CompiledQuery.raw("select 1"),
            onDone: deferred,
            tedious: this.#tedious
          });
          this.#connection.execSql(request.request);
          await deferred.promise;
          return true;
        } catch {
          return false;
        }
      }
      #getTediousIsolationLevel(isolationLevel) {
        const { ISOLATION_LEVEL } = this.#tedious;
        const mapper = {
          "read committed": ISOLATION_LEVEL.READ_COMMITTED,
          "read uncommitted": ISOLATION_LEVEL.READ_UNCOMMITTED,
          "repeatable read": ISOLATION_LEVEL.REPEATABLE_READ,
          serializable: ISOLATION_LEVEL.SERIALIZABLE,
          snapshot: ISOLATION_LEVEL.SNAPSHOT
        };
        const tediousIsolationLevel = mapper[isolationLevel];
        if (tediousIsolationLevel === void 0) {
          throw new Error(`Unknown isolation level: ${isolationLevel}`);
        }
        return tediousIsolationLevel;
      }
      #cancelRequest(request) {
        return new Promise((resolve) => {
          request.request.once("requestCompleted", resolve);
          const wasCanceled = this.#connection.cancel();
          if (!wasCanceled) {
            request.request.off("requestCompleted", resolve);
            resolve(void 0);
          }
        });
      }
      async [PRIVATE_RELEASE_METHOD3]() {
        if (this.#tedious.resetConnectionOnRelease !== false) {
          await new Promise((resolve, reject) => {
            this.#connection.reset((error) => {
              if (error)
                reject(error);
              else
                resolve(void 0);
            });
          });
        }
      }
      [PRIVATE_DESTROY_METHOD]() {
        return new Promise((resolve) => {
          this.#connection.once("end", () => {
            resolve(void 0);
          });
          this.#connection.close();
        });
      }
    };
    MssqlRequest = class {
      static {
        __name(this, "MssqlRequest");
      }
      #request;
      #rows;
      #streamChunkSize;
      #subscribers;
      #tedious;
      #error;
      #rowCount;
      constructor(props) {
        const { compiledQuery, onDone, streamChunkSize, tedious } = props;
        this.#rows = [];
        this.#streamChunkSize = streamChunkSize;
        this.#subscribers = {};
        this.#tedious = tedious;
        if (onDone) {
          const subscriptionKey = "onDone";
          this.#subscribers[subscriptionKey] = (event, error) => {
            if (event === "chunkReady") {
              return;
            }
            delete this.#subscribers[subscriptionKey];
            if (event === "error") {
              onDone.reject(error);
            } else {
              onDone.resolve({
                rowCount: this.#rowCount,
                rows: this.#rows
              });
            }
          };
        }
        this.#request = new this.#tedious.Request(compiledQuery.sql, (err, rowCount) => {
          if (err) {
            Object.values(this.#subscribers).forEach((subscriber) => subscriber("error", err instanceof AggregateError ? err.errors : err));
          } else {
            this.#rowCount = rowCount;
          }
        });
        this.#addParametersToRequest(compiledQuery.parameters);
        this.#attachListeners();
      }
      get request() {
        return this.#request;
      }
      readChunk() {
        const subscriptionKey = this.readChunk.name;
        return new Promise((resolve, reject) => {
          this.#subscribers[subscriptionKey] = (event, error) => {
            delete this.#subscribers[subscriptionKey];
            if (event === "error") {
              reject(error);
            } else {
              resolve(this.#rows.splice(0, this.#streamChunkSize));
            }
          };
          this.#request.resume();
        });
      }
      #addParametersToRequest(parameters) {
        for (let i = 0; i < parameters.length; i++) {
          const parameter = parameters[i];
          this.#request.addParameter(String(i + 1), this.#getTediousDataType(parameter), parameter);
        }
      }
      #attachListeners() {
        const pauseAndEmitChunkReady = this.#streamChunkSize ? () => {
          if (this.#streamChunkSize <= this.#rows.length) {
            this.#request.pause();
            Object.values(this.#subscribers).forEach((subscriber) => subscriber("chunkReady"));
          }
        } : () => {
        };
        const rowListener = /* @__PURE__ */ __name((columns) => {
          const row = {};
          for (const column of columns) {
            row[column.metadata.colName] = column.value;
          }
          this.#rows.push(row);
          pauseAndEmitChunkReady();
        }, "rowListener");
        this.#request.on("row", rowListener);
        this.#request.once("requestCompleted", () => {
          Object.values(this.#subscribers).forEach((subscriber) => subscriber("completed"));
          this.#request.off("row", rowListener);
        });
      }
      #getTediousDataType(value) {
        if (isNull(value) || isUndefined(value) || isString(value)) {
          return this.#tedious.TYPES.NVarChar;
        }
        if (isBigInt(value) || isNumber(value) && value % 1 === 0) {
          if (value < -2147483648 || value > 2147483647) {
            return this.#tedious.TYPES.BigInt;
          } else {
            return this.#tedious.TYPES.Int;
          }
        }
        if (isNumber(value)) {
          return this.#tedious.TYPES.Float;
        }
        if (isBoolean(value)) {
          return this.#tedious.TYPES.Bit;
        }
        if (isDate(value)) {
          return this.#tedious.TYPES.DateTime;
        }
        if (isBuffer(value)) {
          return this.#tedious.TYPES.VarBinary;
        }
        return this.#tedious.TYPES.NVarChar;
      }
    };
  }
});

// node_modules/kysely/dist/esm/dialect/mssql/mssql-introspector.js
var init_mssql_introspector = __esm({
  "node_modules/kysely/dist/esm/dialect/mssql/mssql-introspector.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/mssql/mssql-query-compiler.js
var init_mssql_query_compiler = __esm({
  "node_modules/kysely/dist/esm/dialect/mssql/mssql-query-compiler.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/dialect/mssql/mssql-dialect.js
var init_mssql_dialect = __esm({
  "node_modules/kysely/dist/esm/dialect/mssql/mssql-dialect.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/query-compiler/query-compiler.js
var init_query_compiler = __esm({
  "node_modules/kysely/dist/esm/query-compiler/query-compiler.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/migration/file-migration-provider.js
var init_file_migration_provider = __esm({
  "node_modules/kysely/dist/esm/migration/file-migration-provider.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/plugin/kysely-plugin.js
var init_kysely_plugin = __esm({
  "node_modules/kysely/dist/esm/plugin/kysely-plugin.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/plugin/camel-case/camel-case-plugin.js
var init_camel_case_plugin = __esm({
  "node_modules/kysely/dist/esm/plugin/camel-case/camel-case-plugin.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/plugin/deduplicate-joins/deduplicate-joins-plugin.js
var init_deduplicate_joins_plugin = __esm({
  "node_modules/kysely/dist/esm/plugin/deduplicate-joins/deduplicate-joins-plugin.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/plugin/parse-json-results/parse-json-results-plugin.js
var init_parse_json_results_plugin = __esm({
  "node_modules/kysely/dist/esm/plugin/parse-json-results/parse-json-results-plugin.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/operation-node/constraint-node.js
var init_constraint_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/constraint-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/operation-node/list-node.js
var ListNode;
var init_list_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/list-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_object_utils();
    ListNode = freeze({
      is(node) {
        return node.kind === "ListNode";
      },
      create(items) {
        return freeze({
          kind: "ListNode",
          items: freeze(items)
        });
      }
    });
  }
});

// node_modules/kysely/dist/esm/operation-node/operation-node.js
var init_operation_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/operation-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/operation-node/simple-reference-expression-node.js
var init_simple_reference_expression_node = __esm({
  "node_modules/kysely/dist/esm/operation-node/simple-reference-expression-node.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/util/column-type.js
var init_column_type = __esm({
  "node_modules/kysely/dist/esm/util/column-type.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/util/explainable.js
var init_explainable = __esm({
  "node_modules/kysely/dist/esm/util/explainable.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/util/streamable.js
var init_streamable = __esm({
  "node_modules/kysely/dist/esm/util/streamable.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/util/infer-result.js
var init_infer_result = __esm({
  "node_modules/kysely/dist/esm/util/infer-result.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/kysely/dist/esm/index.js
var init_esm = __esm({
  "node_modules/kysely/dist/esm/index.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_kysely();
    init_query_creator();
    init_expression();
    init_expression_wrapper();
    init_where_interface();
    init_returning_interface();
    init_output_interface();
    init_having_interface();
    init_select_query_builder();
    init_insert_query_builder();
    init_update_query_builder();
    init_delete_query_builder();
    init_no_result_error();
    init_join_builder();
    init_function_module();
    init_insert_result();
    init_delete_result();
    init_update_result();
    init_on_conflict_builder();
    init_aggregate_function_builder();
    init_case_builder();
    init_json_path_builder();
    init_merge_query_builder();
    init_merge_result();
    init_raw_builder();
    init_sql();
    init_query_executor();
    init_default_query_executor();
    init_noop_query_executor();
    init_query_executor_provider();
    init_default_query_compiler();
    init_compiled_query();
    init_schema2();
    init_create_table_builder();
    init_create_type_builder();
    init_drop_table_builder();
    init_drop_type_builder();
    init_create_index_builder();
    init_drop_index_builder();
    init_create_schema_builder();
    init_drop_schema_builder();
    init_column_definition_builder();
    init_foreign_key_constraint_builder();
    init_alter_table_builder();
    init_create_view_builder();
    init_drop_view_builder();
    init_alter_column_builder();
    init_dynamic();
    init_driver();
    init_database_connection();
    init_connection_provider();
    init_default_connection_provider();
    init_single_connection_provider();
    init_dummy_driver();
    init_dialect();
    init_dialect_adapter();
    init_dialect_adapter_base();
    init_database_introspector();
    init_sqlite_dialect();
    init_sqlite_dialect_config();
    init_sqlite_driver();
    init_postgres_query_compiler();
    init_postgres_introspector();
    init_postgres_adapter();
    init_mysql_dialect();
    init_mysql_dialect_config();
    init_mysql_driver();
    init_mysql_query_compiler();
    init_mysql_introspector();
    init_mysql_adapter();
    init_postgres_driver();
    init_postgres_dialect_config();
    init_postgres_dialect();
    init_sqlite_query_compiler();
    init_sqlite_introspector();
    init_sqlite_adapter();
    init_mssql_adapter();
    init_mssql_dialect_config();
    init_mssql_dialect();
    init_mssql_driver();
    init_mssql_introspector();
    init_mssql_query_compiler();
    init_default_query_compiler();
    init_query_compiler();
    init_migrator();
    init_file_migration_provider();
    init_kysely_plugin();
    init_camel_case_plugin();
    init_deduplicate_joins_plugin();
    init_with_schema_plugin();
    init_parse_json_results_plugin();
    init_add_column_node();
    init_add_constraint_node();
    init_add_index_node();
    init_aggregate_function_node();
    init_alias_node();
    init_alter_column_node();
    init_alter_table_node();
    init_and_node();
    init_binary_operation_node();
    init_case_node();
    init_cast_node();
    init_check_constraint_node();
    init_column_definition_node();
    init_column_node();
    init_column_update_node();
    init_common_table_expression_name_node();
    init_common_table_expression_node();
    init_constraint_node();
    init_create_index_node();
    init_create_schema_node();
    init_create_table_node();
    init_create_type_node();
    init_create_view_node();
    init_data_type_node();
    init_default_insert_value_node();
    init_default_value_node();
    init_delete_query_node();
    init_drop_column_node();
    init_drop_constraint_node();
    init_drop_index_node();
    init_drop_schema_node();
    init_drop_table_node();
    init_drop_type_node();
    init_drop_view_node();
    init_explain_node();
    init_fetch_node();
    init_foreign_key_constraint_node();
    init_from_node();
    init_function_node();
    init_generated_node();
    init_group_by_item_node();
    init_group_by_node();
    init_having_node();
    init_identifier_node();
    init_insert_query_node();
    init_join_node();
    init_json_operator_chain_node();
    init_json_path_leg_node();
    init_json_path_node();
    init_json_reference_node();
    init_limit_node();
    init_list_node();
    init_matched_node();
    init_merge_query_node();
    init_modify_column_node();
    init_offset_node();
    init_on_conflict_node();
    init_on_duplicate_key_node();
    init_on_node();
    init_operation_node_source();
    init_operation_node_transformer();
    init_operation_node_visitor();
    init_operation_node();
    init_operator_node();
    init_or_node();
    init_order_by_item_node();
    init_order_by_node();
    init_output_node();
    init_over_node();
    init_parens_node();
    init_partition_by_item_node();
    init_partition_by_node();
    init_primary_constraint_node();
    init_primitive_value_list_node();
    init_query_node();
    init_raw_node();
    init_reference_node();
    init_references_node();
    init_rename_column_node();
    init_returning_node();
    init_schemable_identifier_node();
    init_select_all_node();
    init_select_modifier_node();
    init_select_query_node();
    init_selection_node();
    init_set_operation_node();
    init_simple_reference_expression_node();
    init_table_node();
    init_top_node();
    init_tuple_node();
    init_unary_operation_node();
    init_unique_constraint_node();
    init_update_query_node();
    init_using_node();
    init_value_list_node();
    init_value_node();
    init_values_node();
    init_when_node();
    init_where_node();
    init_with_node();
    init_column_type();
    init_compilable();
    init_explainable();
    init_streamable();
    init_log();
    init_infer_result();
  }
});

// node_modules/kysely-d1/dist/index.js
var __classPrivateFieldSet2, __classPrivateFieldGet2, _D1Dialect_config, _D1Driver_config, _D1Connection_config, D1Dialect, D1Driver, D1Connection;
var init_dist2 = __esm({
  "node_modules/kysely-d1/dist/index.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_esm();
    __classPrivateFieldSet2 = function(receiver, state, value, kind2, f) {
      if (kind2 === "m") throw new TypeError("Private method is not writable");
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet2 = function(receiver, state, kind2, f) {
      if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    D1Dialect = class {
      static {
        __name(this, "D1Dialect");
      }
      constructor(config) {
        _D1Dialect_config.set(this, void 0);
        __classPrivateFieldSet2(this, _D1Dialect_config, config, "f");
      }
      createAdapter() {
        return new SqliteAdapter();
      }
      createDriver() {
        return new D1Driver(__classPrivateFieldGet2(this, _D1Dialect_config, "f"));
      }
      createQueryCompiler() {
        return new SqliteQueryCompiler();
      }
      createIntrospector(db) {
        return new SqliteIntrospector(db);
      }
    };
    _D1Dialect_config = /* @__PURE__ */ new WeakMap();
    D1Driver = class {
      static {
        __name(this, "D1Driver");
      }
      constructor(config) {
        _D1Driver_config.set(this, void 0);
        __classPrivateFieldSet2(this, _D1Driver_config, config, "f");
      }
      async init() {
      }
      async acquireConnection() {
        return new D1Connection(__classPrivateFieldGet2(this, _D1Driver_config, "f"));
      }
      async beginTransaction(conn) {
        return await conn.beginTransaction();
      }
      async commitTransaction(conn) {
        return await conn.commitTransaction();
      }
      async rollbackTransaction(conn) {
        return await conn.rollbackTransaction();
      }
      async releaseConnection(_conn) {
      }
      async destroy() {
      }
    };
    _D1Driver_config = /* @__PURE__ */ new WeakMap();
    D1Connection = class {
      static {
        __name(this, "D1Connection");
      }
      //   #transactionClient?: D1Connection
      constructor(config) {
        _D1Connection_config.set(this, void 0);
        __classPrivateFieldSet2(this, _D1Connection_config, config, "f");
      }
      async executeQuery(compiledQuery) {
        const results = await __classPrivateFieldGet2(this, _D1Connection_config, "f").database.prepare(compiledQuery.sql).bind(...compiledQuery.parameters).all();
        if (results.error) {
          throw new Error(results.error);
        }
        const numAffectedRows = results.meta.changes > 0 ? BigInt(results.meta.changes) : void 0;
        return {
          insertId: results.meta.last_row_id === void 0 || results.meta.last_row_id === null ? void 0 : BigInt(results.meta.last_row_id),
          rows: results?.results || [],
          numAffectedRows,
          // @ts-ignore deprecated in kysely >= 0.23, keep for backward compatibility.
          numUpdatedOrDeletedRows: numAffectedRows
        };
      }
      async beginTransaction() {
        throw new Error("Transactions are not supported yet.");
      }
      async commitTransaction() {
        throw new Error("Transactions are not supported yet.");
      }
      async rollbackTransaction() {
        throw new Error("Transactions are not supported yet.");
      }
      async *streamQuery(_compiledQuery, _chunkSize) {
        throw new Error("D1 Driver does not support streaming");
      }
    };
    _D1Connection_config = /* @__PURE__ */ new WeakMap();
  }
});

// src/db/client.ts
function initDb(env) {
  return new Kysely({
    dialect: new D1Dialect({ database: env.DB })
  });
}
var init_client = __esm({
  "src/db/client.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_esm();
    init_dist2();
    __name(initDb, "initDb");
  }
});

// src/services/health-check.ts
var HealthCheckService;
var init_health_check = __esm({
  "src/services/health-check.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_types();
    init_client();
    HealthCheckService = class {
      static {
        __name(this, "HealthCheckService");
      }
      env;
      db;
      baseUrl;
      authToken;
      appFetch;
      loggingService;
      constructor(env, baseUrl, authToken, appFetch, loggingService) {
        this.env = env;
        this.db = initDb(env);
        this.baseUrl = baseUrl;
        this.authToken = authToken;
        this.appFetch = appFetch;
        this.loggingService = loggingService;
      }
      /**
       * Get default test definitions
       * These will be registered in the database on first run
       */
      getDefaultTestDefinitions() {
        return [
          // Tokens API (Read)
          {
            name: "List Tokens",
            endpoint_path: "/api/tokens",
            http_method: "GET",
            category: "api",
            description: "Tests listing all user API tokens"
          },
          // Workers API (Read)
          {
            name: "List Workers",
            endpoint_path: "/api/workers/scripts",
            http_method: "GET",
            category: "api",
            description: "Tests listing all Workers scripts"
          },
          // Storage API (Read)
          {
            name: "List D1 Databases",
            endpoint_path: "/api/storage/d1/databases",
            http_method: "GET",
            category: "api",
            description: "Tests listing all D1 databases"
          },
          {
            name: "List KV Namespaces",
            endpoint_path: "/api/storage/kv/namespaces",
            http_method: "GET",
            category: "api",
            description: "Tests listing all KV namespaces"
          },
          {
            name: "List R2 Buckets",
            endpoint_path: "/api/storage/r2/buckets",
            http_method: "GET",
            category: "api",
            description: "Tests listing all R2 buckets"
          },
          // Vectorize API (Read)
          {
            name: "List Vectorize Indexes",
            endpoint_path: "/api/vectorize/indexes",
            http_method: "GET",
            category: "api",
            description: "Tests listing all Vectorize indexes"
          },
          // Workers AI API (Read/Run)
          {
            name: "List AI Models",
            endpoint_path: "/api/ai/models",
            http_method: "GET",
            category: "api",
            description: "Tests listing available Workers AI models"
          },
          {
            name: "Run AI Prompt",
            endpoint_path: "/api/ai/run",
            http_method: "POST",
            category: "api",
            description: 'Tests running an AI prompt with a simple "Hello" message',
            request_body: JSON.stringify({ model: "@cf/meta/llama-2-7b-chat-int8", text: ["Hello"] })
          },
          // Additional Read Endpoints
          {
            name: "Worker Deployments",
            endpoint_path: "/api/workers/deployments",
            http_method: "GET",
            category: "api",
            description: "Tests listing worker deployments"
          },
          {
            name: "Worker Settings",
            endpoint_path: "/api/workers/settings",
            http_method: "GET",
            category: "api",
            description: "Tests retrieving worker account settings"
          },
          {
            name: "List Pages Projects",
            endpoint_path: "/api/pages/projects",
            http_method: "GET",
            category: "api",
            description: "Tests listing all Pages projects"
          },
          {
            name: "Verify Token",
            endpoint_path: "/api/tokens/verify",
            http_method: "GET",
            category: "api",
            description: "Tests token verification endpoint"
          },
          {
            name: "List Build Tokens",
            endpoint_path: "/api/cicd/tokens",
            http_method: "GET",
            category: "api",
            description: "Tests listing CI/CD build tokens"
          },
          // Health & Meta
          {
            name: "Health Status",
            endpoint_path: "/health/status",
            http_method: "GET",
            category: "health",
            description: "Tests basic health status endpoint"
          },
          {
            name: "OpenAPI JSON",
            endpoint_path: "/openapi.json",
            http_method: "GET",
            category: "meta",
            description: "Tests OpenAPI specification endpoint"
          },
          // Database Health & Sync Tests
          {
            name: "Token Table Sync",
            endpoint_path: "/health/db/tokens",
            http_method: "POST",
            category: "health",
            description: "Syncs manage_tokens table with Cloudflare API and validates data integrity"
          },
          {
            name: "API Permissions Map Sync",
            endpoint_path: "/health/db/permissions",
            http_method: "POST",
            category: "health",
            description: "Syncs api_permissions_map table with current token permissions and validates consistency"
          }
        ];
      }
      /**
       * Ensure all health tests are registered in the database
       */
      async ensureTestsRegistered() {
        const defaultTests = this.getDefaultTestDefinitions();
        const now = (/* @__PURE__ */ new Date()).toISOString();
        for (const testDef of defaultTests) {
          const existing = await this.db.selectFrom("health_tests").where("endpoint_path", "=", testDef.endpoint_path).selectAll().limit(1).executeTakeFirst();
          if (!existing) {
            await this.db.insertInto("health_tests").values({
              id: generateUUID(),
              test_key: testDef.endpoint_path.replace(/\//g, "_").replace(/^_/, ""),
              name: testDef.name,
              scope: "internal",
              endpoint_path: testDef.endpoint_path,
              http_method: testDef.http_method,
              category: testDef.category,
              description: testDef.description,
              executor_key: "http",
              error_meanings_json: null,
              error_solutions_json: null,
              metadata: null,
              request_body: testDef.request_body || null,
              enabled: 1,
              is_active: 1,
              created_at: now,
              updated_at: now
            }).execute();
          } else if (existing.description !== testDef.description || existing.http_method !== testDef.http_method) {
            await this.db.updateTable("health_tests").set({
              name: testDef.name,
              http_method: testDef.http_method,
              category: testDef.category,
              description: testDef.description,
              request_body: testDef.request_body || null,
              updated_at: now
            }).where("id", "=", existing.id).execute();
          }
        }
      }
      /**
       * Get enabled and active tests from database
       */
      async getTestsFromDatabase() {
        const result = await this.db.selectFrom("health_tests").where("enabled", "=", 1).where("is_active", "=", 1).select(["id", "name", "endpoint_path", "http_method", "category", "description", "request_body"]).execute();
        return result;
      }
      /**
       * Get all health tests with their latest results
       * Returns array of objects with test definition and latest result
       */
      async getTestsWithLatestResults() {
        try {
          await this.ensureTestsRegistered();
          const tests = await this.db.selectFrom("health_tests").where("is_active", "=", 1).orderBy("name").selectAll().execute();
          const testsWithResults = await Promise.all(
            tests.map(async (test) => {
              try {
                const latestResult = await this.db.selectFrom("health_test_results").where("health_test_id", "=", test.id).orderBy("run_at", "desc").selectAll().limit(1).executeTakeFirst();
                return {
                  test: {
                    id: test.id,
                    name: test.name,
                    endpoint_path: test.endpoint_path,
                    http_method: test.http_method,
                    category: test.category,
                    description: test.description,
                    enabled: test.enabled,
                    is_active: test.is_active,
                    created_at: test.created_at,
                    updated_at: test.updated_at
                  },
                  latest_result: latestResult ? {
                    id: latestResult.id,
                    health_test_id: latestResult.health_test_id,
                    status: latestResult.status,
                    status_text: latestResult.status_text,
                    response_time_ms: latestResult.response_time_ms,
                    outcome: latestResult.outcome,
                    error_message: latestResult.error_message,
                    response_body: latestResult.response_body,
                    run_at: latestResult.run_at,
                    run_group_id: latestResult.run_group_id || null
                  } : null
                };
              } catch (error) {
                console.error(`Error fetching result for test ${test.id}:`, error);
                return {
                  test: {
                    id: test.id,
                    name: test.name,
                    endpoint_path: test.endpoint_path,
                    http_method: test.http_method,
                    category: test.category,
                    description: test.description,
                    enabled: test.enabled,
                    is_active: test.is_active,
                    created_at: test.created_at,
                    updated_at: test.updated_at
                  },
                  latest_result: null
                };
              }
            })
          );
          return testsWithResults;
        } catch (error) {
          console.error("Error in getTestsWithLatestResults:", error);
          throw error;
        }
      }
      async runHealthCheck() {
        await this.ensureTestsRegistered();
        const tests = await this.getTestsFromDatabase();
        const checkGroupId = generateUUID();
        const results = [];
        let totalResponseTime = 0;
        for (const test of tests) {
          const startTime = Date.now();
          let status = 0;
          let statusText = "Error";
          let outcome = "fail";
          let responseBody = null;
          try {
            if (test.endpoint_path === "/health/db/tokens") {
              try {
                await this.syncTokensFromApiResponse(null);
                status = 200;
                statusText = "Token table sync completed successfully";
                outcome = "pass";
                responseBody = JSON.stringify({ success: true, message: "Token sync completed" });
              } catch (syncError) {
                status = 500;
                statusText = `Token sync failed: ${syncError.message}`;
                outcome = "fail";
                responseBody = JSON.stringify({ success: false, error: syncError.message });
              }
            } else if (test.endpoint_path === "/health/db/permissions") {
              try {
                const syncResult = await this.syncPermissionsMap();
                if (syncResult.success) {
                  status = 200;
                  statusText = syncResult.message;
                  outcome = "pass";
                  responseBody = JSON.stringify(syncResult);
                } else {
                  status = 500;
                  statusText = syncResult.message;
                  outcome = "fail";
                  responseBody = JSON.stringify(syncResult);
                }
              } catch (syncError) {
                status = 500;
                statusText = `Permissions sync failed: ${syncError.message}`;
                outcome = "fail";
                responseBody = JSON.stringify({ success: false, error: syncError.message });
              }
            } else {
              let url;
              let authHeader;
              if (test.endpoint_path.startsWith("/api/")) {
                url = `${this.baseUrl}${test.endpoint_path}`;
                authHeader = `Bearer ${this.authToken}`;
              } else if (test.endpoint_path.startsWith("/health/")) {
                url = `${this.baseUrl}${test.endpoint_path}`;
                authHeader = "";
              } else {
                const cloudflarePath = test.endpoint_path.replace("/api", "");
                url = `https://api.cloudflare.com/client/v4${cloudflarePath}`;
                authHeader = `Bearer ${this.env.CLOUDFLARE_ACCOUNT_TOKEN}`;
              }
              const method = test.http_method;
              const fetchOptions = {
                method,
                headers: {
                  "Content-Type": "application/json"
                }
              };
              if (authHeader) {
                fetchOptions.headers = {
                  ...fetchOptions.headers,
                  "Authorization": authHeader
                };
              }
              if (["POST", "PUT", "PATCH"].includes(method) && test.request_body) {
                fetchOptions.body = test.request_body;
              }
              const response = this.appFetch ? await this.appFetch(new Request(url, fetchOptions)) : await fetch(url, fetchOptions);
              status = response.status;
              statusText = response.statusText;
              if (status === 404) {
                outcome = "fail";
                statusText = "Endpoint not found (check routing or API path)";
              } else {
                outcome = response.ok ? "pass" : "fail";
              }
              try {
                const bodyText = await response.text();
                if (bodyText) {
                  responseBody = bodyText.substring(0, 500);
                  if (!response.ok && status !== 404) {
                    try {
                      const errorJson = JSON.parse(bodyText);
                      if (errorJson.errors && errorJson.errors.length > 0) {
                        statusText = errorJson.errors[0].message || statusText;
                      } else if (errorJson.error) {
                        statusText = errorJson.error;
                      }
                    } catch {
                      statusText = `${response.statusText}: ${bodyText.substring(0, 100)}`;
                    }
                  } else if (response.ok && test.endpoint_path === "/api/tokens") {
                    try {
                      const responseJson = JSON.parse(bodyText);
                      if (responseJson.success !== false) {
                        await this.syncTokensFromApiResponse(responseJson);
                      }
                    } catch (parseError) {
                      console.error("Failed to parse tokens response for sync:", parseError);
                    }
                  }
                }
              } catch {
              }
            }
          } catch (e) {
            status = 0;
            statusText = e.message || "Network error";
            outcome = "fail";
          }
          const responseTime = Date.now() - startTime;
          totalResponseTime += responseTime;
          const resultId = generateUUID();
          try {
            await this.db.insertInto("health_test_results").values({
              id: resultId,
              health_test_id: test.id,
              run_group_id: checkGroupId,
              status,
              status_text: statusText,
              response_time_ms: responseTime,
              outcome,
              error_message: outcome === "fail" ? statusText : null,
              response_body: responseBody,
              run_at: (/* @__PURE__ */ new Date()).toISOString(),
              endpoint: test.name,
              overall_status: null
            }).execute();
          } catch (dbError) {
            console.error("Failed to insert health test result:", {
              test: test.name,
              error: dbError.message
            });
          }
          results.push({
            endpoint: test.name,
            status,
            statusText,
            response_time_ms: responseTime,
            outcome,
            category: test.category,
            path: test.endpoint_path,
            method: test.http_method
          });
        }
        const healthy = results.filter((r) => r.outcome === "pass").length;
        const unhealthy = results.length - healthy;
        const overallStatus = unhealthy === 0 ? "pass" : unhealthy === results.length ? "fail" : "degraded";
        return {
          overall_status: overallStatus,
          total_endpoints: results.length,
          healthy_endpoints: healthy,
          unhealthy_endpoints: unhealthy,
          degraded_endpoints: 0,
          // For future use
          avg_response_time: totalResponseTime / results.length,
          checked_at: (/* @__PURE__ */ new Date()).toISOString(),
          check_group_id: checkGroupId,
          results
        };
      }
      async saveHealthCheck(result) {
        console.log("saveHealthCheck called (no-op): health_checks table removed, data in health_test_results");
      }
      /**
       * Get all registered health tests (active only by default)
       */
      async getRegisteredTests(includeInactive = false) {
        if (includeInactive) {
          const result = await this.env.DB.prepare(
            "SELECT * FROM health_tests ORDER BY name ASC"
          ).all();
          return result.results;
        } else {
          const result = await this.env.DB.prepare(
            "SELECT * FROM health_tests WHERE is_active = 1 ORDER BY name ASC"
          ).all();
          return result.results;
        }
      }
      /**
       * Get test results with test definitions joined
       */
      async getTestResultsWithDefinitions(runGroupId, limit = 100) {
        let query = this.db.selectFrom("health_test_results").innerJoin("health_tests", "health_tests.id", "health_test_results.health_test_id").select([
          "health_test_results.id",
          "health_test_results.health_test_id",
          "health_test_results.run_group_id",
          "health_test_results.status",
          "health_test_results.status_text",
          "health_test_results.response_time_ms",
          "health_test_results.outcome",
          "health_test_results.error_message",
          "health_test_results.response_body",
          "health_test_results.run_at",
          "health_tests.name",
          "health_tests.endpoint_path",
          "health_tests.http_method",
          "health_tests.category",
          "health_tests.description"
        ]).orderBy("health_test_results.run_at", "desc").limit(limit);
        if (runGroupId) {
          query = query.where("health_test_results.run_group_id", "=", runGroupId);
        }
        const results = await query.execute();
        return results.map((result) => ({
          id: result.id,
          health_test_id: result.health_test_id,
          run_group_id: result.run_group_id,
          status: result.status,
          status_text: result.status_text,
          response_time_ms: result.response_time_ms,
          outcome: result.outcome,
          error_message: result.error_message,
          response_body: result.response_body,
          run_at: result.run_at,
          health_test: {
            name: result.name,
            endpoint_path: result.endpoint_path,
            http_method: result.http_method,
            category: result.category,
            description: result.description
          }
        }));
      }
      /**
       * Sync API permissions map from manage_tokens table
       */
      async syncPermissionsMap() {
        try {
          const tokens2 = await this.db.selectFrom("manage_tokens").where("status", "=", "active").select(["permissions"]).execute();
          const permissionsSet = /* @__PURE__ */ new Set();
          for (const token of tokens2) {
            if (token.permissions) {
              try {
                const permissions = JSON.parse(token.permissions);
                if (Array.isArray(permissions)) {
                  permissions.forEach((perm) => permissionsSet.add(perm));
                }
              } catch (error) {
                console.error("Failed to parse token permissions:", token.permissions, error);
              }
            }
          }
          const existingMap = await this.db.selectFrom("api_permissions_map").selectAll().execute();
          const existingPermissionsMap = new Map(existingMap.map((p) => [p.permission, p]));
          const newPermissions = Array.from(permissionsSet);
          let added = 0;
          let removed = 0;
          for (const permission of newPermissions) {
            if (!existingPermissionsMap.has(permission)) {
              const basePath = this.extractBasePathFromPermission(permission);
              const description = this.generatePermissionDescription(permission);
              await this.db.insertInto("api_permissions_map").values({
                permission,
                base_path: basePath,
                verbs: null,
                description
              }).execute();
              added++;
            }
          }
          for (const existing of existingMap) {
            if (!newPermissions.includes(existing.permission)) {
              await this.db.deleteFrom("api_permissions_map").where("permission", "=", existing.permission).execute();
              removed++;
            }
          }
          const message = `Permissions map synced: ${added} added, ${removed} removed, ${newPermissions.length} total permissions`;
          console.log(message);
          await this.loggingService?.logAction({
            actionType: "database_sync",
            actionName: "Permissions map sync completed",
            outputData: { added, removed, total: newPermissions.length },
            status: "completed"
          });
          return {
            success: true,
            message,
            permissionsCount: newPermissions.length
          };
        } catch (error) {
          const message = `Failed to sync permissions map: ${error.message}`;
          console.error(message, error);
          await this.loggingService?.logAction({
            actionType: "database_sync",
            actionName: "Permissions map sync failed",
            errorMessage: error.message,
            status: "failed"
          });
          return {
            success: false,
            message,
            permissionsCount: 0
          };
        }
      }
      /**
       * Extract base path from Cloudflare permission string
       */
      extractBasePathFromPermission(permission) {
        const parts = permission.split(":");
        if (parts.length < 2) return "/";
        const resource = parts[0];
        const action = parts[1];
        const resourceMap = {
          "Workers Scripts": "/accounts/{account_id}/workers/scripts",
          "Workers": "/accounts/{account_id}/workers",
          "D1": "/accounts/{account_id}/d1",
          "KV": "/accounts/{account_id}/storage/kv",
          "R2": "/accounts/{account_id}/r2",
          "Vectorize": "/accounts/{account_id}/vectorize",
          "Workers AI": "/accounts/{account_id}/ai",
          "Pages": "/accounts/{account_id}/pages",
          "User Tokens": "/user/tokens",
          "Account Tokens": "/accounts/{account_id}/tokens"
        };
        return resourceMap[resource] || `/${resource.toLowerCase().replace(/\s+/g, "/")}`;
      }
      /**
       * Generate description for permission
       */
      generatePermissionDescription(permission) {
        const parts = permission.split(":");
        if (parts.length < 2) return `Permission: ${permission}`;
        const resource = parts[0];
        const action = parts[1];
        return `Allows ${action.toLowerCase()} operations on ${resource}`;
      }
      /**
       * Sync tokens from Cloudflare API response to manage_tokens table
       * If apiTokensResponse is null, just update last_verified timestamps
       */
      async syncTokensFromApiResponse(apiTokensResponse) {
        try {
          const now = (/* @__PURE__ */ new Date()).toISOString();
          if (!apiTokensResponse) {
            await this.loggingService?.logAction({
              actionType: "database_sync",
              actionName: "Token verification timestamps updated",
              status: "completed"
            });
            await this.db.updateTable("manage_tokens").set({ last_verified: now }).where("status", "=", "active").execute();
            console.log("Token verification timestamps updated");
            return;
          }
          const apiTokens = apiTokensResponse.result || apiTokensResponse;
          if (!Array.isArray(apiTokens)) {
            console.error("Invalid token response format:", apiTokensResponse);
            return;
          }
          const existingTokens = await this.db.selectFrom("manage_tokens").selectAll().execute();
          const existingTokensMap = new Map(existingTokens.map((t) => [t.token_id, t]));
          const apiTokensMap = new Map(apiTokens.map((t) => [t.id, t]));
          for (const apiToken of apiTokens) {
            const existingToken = existingTokensMap.get(apiToken.id);
            const permissions = apiToken.policies?.map((policy) => policy.permission) || [];
            const permissionsJson = JSON.stringify(permissions);
            const policiesJson = JSON.stringify(apiToken.policies || []);
            if (existingToken) {
              const permissionsChanged = existingToken.permissions !== permissionsJson;
              const statusChanged = existingToken.status !== apiToken.status;
              const nameChanged = existingToken.name !== apiToken.name;
              const expiresOnChanged = existingToken.expires_on !== apiToken.expires_on;
              const issuedOnChanged = existingToken.issued_on !== apiToken.issued_on;
              const policiesChanged = existingToken.policies !== policiesJson;
              if (permissionsChanged || statusChanged || nameChanged || expiresOnChanged || issuedOnChanged || policiesChanged) {
                await this.db.updateTable("manage_tokens").set({
                  name: apiToken.name,
                  status: apiToken.status,
                  permissions: permissionsJson,
                  policies: policiesJson,
                  issued_on: apiToken.issued_on,
                  expires_on: apiToken.expires_on,
                  last_verified: now,
                  updated_at: now
                }).where("token_id", "=", apiToken.id).execute();
              } else {
                await this.db.updateTable("manage_tokens").set({
                  last_verified: now
                }).where("token_id", "=", apiToken.id).execute();
              }
            } else {
              await this.db.insertInto("manage_tokens").values({
                id: generateUUID(),
                token_id: apiToken.id,
                name: apiToken.name,
                status: apiToken.status,
                permissions: permissionsJson,
                policies: policiesJson,
                issued_on: apiToken.issued_on,
                expires_on: apiToken.expires_on,
                last_verified: now,
                created_at: now,
                updated_at: now
              }).execute();
            }
          }
          for (const existingToken of existingTokens) {
            if (!apiTokensMap.has(existingToken.token_id) && existingToken.status !== "deleted") {
              await this.db.updateTable("manage_tokens").set({
                status: "deleted",
                updated_at: now
              }).where("token_id", "=", existingToken.token_id).execute();
            }
          }
          console.log(`Token sync completed. Processed ${apiTokens.length} API tokens, ${existingTokens.length} existing tokens.`);
        } catch (error) {
          console.error("Error syncing tokens:", error);
        }
      }
      async getLatestHealthCheck() {
        const latestResult = await this.db.selectFrom("health_test_results").select(["run_group_id", "run_at"]).orderBy("run_at", "desc").limit(1).executeTakeFirst();
        if (latestResult) {
          const allResultsInGroup = await this.db.selectFrom("health_test_results").innerJoin("health_tests", "health_tests.id", "health_test_results.health_test_id").where("health_test_results.run_group_id", "=", latestResult.run_group_id).select([
            "health_test_results.status",
            "health_test_results.status_text",
            "health_test_results.response_time_ms",
            "health_test_results.outcome",
            "health_tests.name",
            "health_tests.category",
            "health_tests.endpoint_path",
            "health_tests.http_method"
          ]).execute();
          const results = allResultsInGroup.map((result) => ({
            endpoint: result.name,
            status: result.status,
            statusText: result.status_text,
            response_time_ms: result.response_time_ms,
            outcome: result.outcome,
            category: result.category,
            path: result.endpoint_path,
            method: result.http_method
          }));
          const healthy = results.filter((r) => r.outcome === "pass").length;
          const unhealthy = results.length - healthy;
          const totalResponseTime = results.reduce((acc, r) => acc + r.response_time_ms, 0);
          return {
            overall_status: unhealthy === 0 ? "pass" : unhealthy === results.length ? "fail" : "degraded",
            total_endpoints: results.length,
            healthy_endpoints: healthy,
            unhealthy_endpoints: unhealthy,
            degraded_endpoints: 0,
            avg_response_time: totalResponseTime / results.length,
            checked_at: latestResult.run_at,
            check_group_id: latestResult.run_group_id,
            results
          };
        }
        return null;
      }
    };
  }
});

// node_modules/zod/v3/helpers/util.js
var util, objectUtil, ZodParsedType, getParsedType;
var init_util = __esm({
  "node_modules/zod/v3/helpers/util.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(util2) {
      util2.assertEqual = (_) => {
      };
      function assertIs(_arg) {
      }
      __name(assertIs, "assertIs");
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      __name(assertNever, "assertNever");
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      __name(joinValues, "joinValues");
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = /* @__PURE__ */ __name((data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    }, "getParsedType");
  }
});

// node_modules/zod/v3/ZodError.js
var ZodIssueCode, quotelessJson, ZodError;
var init_ZodError = __esm({
  "node_modules/zod/v3/ZodError.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_util();
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = /* @__PURE__ */ __name((obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    }, "quotelessJson");
    ZodError = class _ZodError extends Error {
      static {
        __name(this, "ZodError");
      }
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = /* @__PURE__ */ __name((error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        }, "processError");
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            const firstEl = sub.path[0];
            fieldErrors[firstEl] = fieldErrors[firstEl] || [];
            fieldErrors[firstEl].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error = new ZodError(issues);
      return error;
    };
  }
});

// node_modules/zod/v3/locales/en.js
var errorMap, en_default;
var init_en = __esm({
  "node_modules/zod/v3/locales/en.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_ZodError();
    init_util();
    errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "bigint")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message };
    }, "errorMap");
    en_default = errorMap;
  }
});

// node_modules/zod/v3/errors.js
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var overrideErrorMap;
var init_errors = __esm({
  "node_modules/zod/v3/errors.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_en();
    overrideErrorMap = en_default;
    __name(setErrorMap, "setErrorMap");
    __name(getErrorMap, "getErrorMap");
  }
});

// node_modules/zod/v3/helpers/parseUtil.js
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync;
var init_parseUtil = __esm({
  "node_modules/zod/v3/helpers/parseUtil.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_errors();
    init_en();
    makeIssue = /* @__PURE__ */ __name((params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    }, "makeIssue");
    EMPTY_PATH = [];
    __name(addIssueToContext, "addIssueToContext");
    ParseStatus = class _ParseStatus {
      static {
        __name(this, "ParseStatus");
      }
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
    OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
    isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
    isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
    isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
    isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");
  }
});

// node_modules/zod/v3/helpers/typeAliases.js
var init_typeAliases = __esm({
  "node_modules/zod/v3/helpers/typeAliases.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
var init_errorUtil = __esm({
  "node_modules/zod/v3/helpers/errorUtil.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
    })(errorUtil || (errorUtil = {}));
  }
});

// node_modules/zod/v3/types.js
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER;
var init_types2 = __esm({
  "node_modules/zod/v3/types.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_ZodError();
    init_errors();
    init_errorUtil();
    init_parseUtil();
    init_util();
    ParseInputLazyPath = class {
      static {
        __name(this, "ParseInputLazyPath");
      }
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (Array.isArray(this._key)) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = /* @__PURE__ */ __name((ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    }, "handleResult");
    __name(processCreateParams, "processCreateParams");
    ZodType = class {
      static {
        __name(this, "ZodType");
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        const ctx = {
          common: {
            issues: [],
            async: params?.async ?? false,
            contextualErrorMap: params?.errorMap
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      "~validate"(data) {
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return isValid(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params?.errorMap,
            async: true
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = /* @__PURE__ */ __name((val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        }, "getIssueProperties");
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          }), "setError");
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: /* @__PURE__ */ __name((data) => this["~validate"](data), "validate")
        };
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    __name(timeRegexSource, "timeRegexSource");
    __name(timeRegex, "timeRegex");
    __name(datetimeRegex, "datetimeRegex");
    __name(isValidIP, "isValidIP");
    __name(isValidJWT, "isValidJWT");
    __name(isValidCidr, "isValidCidr");
    ZodString = class _ZodString extends ZodType {
      static {
        __name(this, "ZodString");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "nanoid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "date",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "time") {
            const regex = timeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "time",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "duration",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "jwt") {
            if (!isValidJWT(input.data, check.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "jwt",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cidr") {
            if (!isValidCidr(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cidr",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
      }
      base64url(message) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil.errToObj(message)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          offset: options?.offset ?? false,
          local: options?.local ?? false,
          ...errorUtil.errToObj(options?.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          ...errorUtil.errToObj(options?.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options?.position,
          ...errorUtil.errToObj(options?.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString.create = (params) => {
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    __name(floatSafeRemainder, "floatSafeRemainder");
    ZodNumber = class _ZodNumber extends ZodType {
      static {
        __name(this, "ZodNumber");
      }
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind2, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind: kind2,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    ZodBigInt = class _ZodBigInt extends ZodType {
      static {
        __name(this, "ZodBigInt");
      }
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch {
            return this._getInvalidInput(input);
          }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return INVALID;
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind2, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind: kind2,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodBigInt.create = (params) => {
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    ZodBoolean = class extends ZodType {
      static {
        __name(this, "ZodBoolean");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    ZodDate = class _ZodDate extends ZodType {
      static {
        __name(this, "ZodDate");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    ZodSymbol = class extends ZodType {
      static {
        __name(this, "ZodSymbol");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    ZodUndefined = class extends ZodType {
      static {
        __name(this, "ZodUndefined");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    ZodNull = class extends ZodType {
      static {
        __name(this, "ZodNull");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    ZodAny = class extends ZodType {
      static {
        __name(this, "ZodAny");
      }
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    ZodUnknown = class extends ZodType {
      static {
        __name(this, "ZodUnknown");
      }
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    ZodNever = class extends ZodType {
      static {
        __name(this, "ZodNever");
      }
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    ZodVoid = class extends ZodType {
      static {
        __name(this, "ZodVoid");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    ZodArray = class _ZodArray extends ZodType {
      static {
        __name(this, "ZodArray");
      }
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    __name(deepPartialify, "deepPartialify");
    ZodObject = class _ZodObject extends ZodType {
      static {
        __name(this, "ZodObject");
      }
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: /* @__PURE__ */ __name((issue, ctx) => {
              const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: errorUtil.errToObj(message).message ?? defaultError
                };
              return {
                message: defaultError
              };
            }, "errorMap")
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...augmentation
          }), "shape")
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }), "shape"),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new _ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        for (const key of util.objectKeys(mask)) {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      omit(mask) {
        const shape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      required(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodUnion = class extends ZodType {
      static {
        __name(this, "ZodUnion");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        __name(handleResults, "handleResults");
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types, params) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    getDiscriminator = /* @__PURE__ */ __name((type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    }, "getDiscriminator");
    ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      static {
        __name(this, "ZodDiscriminatedUnion");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    __name(mergeValues, "mergeValues");
    ZodIntersection = class extends ZodType {
      static {
        __name(this, "ZodIntersection");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        }, "handleParsed");
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    ZodTuple = class _ZodTuple extends ZodType {
      static {
        __name(this, "ZodTuple");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas2, params) => {
      if (!Array.isArray(schemas2)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas2,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    ZodRecord = class _ZodRecord extends ZodType {
      static {
        __name(this, "ZodRecord");
      }
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap = class extends ZodType {
      static {
        __name(this, "ZodMap");
      }
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    ZodSet = class _ZodSet extends ZodType {
      static {
        __name(this, "ZodSet");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        __name(finalizeSet, "finalizeSet");
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    ZodFunction = class _ZodFunction extends ZodType {
      static {
        __name(this, "ZodFunction");
      }
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        __name(makeArgsIssue, "makeArgsIssue");
        function makeReturnsIssue(returns, error) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        __name(makeReturnsIssue, "makeReturnsIssue");
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return OK(async function(...args) {
            const error = new ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return OK(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    ZodLazy = class extends ZodType {
      static {
        __name(this, "ZodLazy");
      }
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    ZodLiteral = class extends ZodType {
      static {
        __name(this, "ZodLiteral");
      }
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    __name(createZodEnum, "createZodEnum");
    ZodEnum = class _ZodEnum extends ZodType {
      static {
        __name(this, "ZodEnum");
      }
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      static {
        __name(this, "ZodNativeEnum");
      }
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(util.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    ZodPromise = class extends ZodType {
      static {
        __name(this, "ZodPromise");
      }
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    ZodEffects = class extends ZodType {
      static {
        __name(this, "ZodEffects");
      }
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: /* @__PURE__ */ __name((arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          }, "addIssue"),
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return INVALID;
              if (result.status === "dirty")
                return DIRTY(result.value);
              if (status.value === "dirty")
                return DIRTY(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = /* @__PURE__ */ __name((acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          }, "executeRefinement");
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base))
              return INVALID;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid(base))
                return INVALID;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                status: status.value,
                value: result
              }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    ZodOptional = class extends ZodType {
      static {
        __name(this, "ZodOptional");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    ZodNullable = class extends ZodType {
      static {
        __name(this, "ZodNullable");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    ZodDefault = class extends ZodType {
      static {
        __name(this, "ZodDefault");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodCatch = class extends ZodType {
      static {
        __name(this, "ZodCatch");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    ZodNaN = class extends ZodType {
      static {
        __name(this, "ZodNaN");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      static {
        __name(this, "ZodBranded");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType {
      static {
        __name(this, "ZodPipeline");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = /* @__PURE__ */ __name(async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }, "handleAsync");
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    ZodReadonly = class extends ZodType {
      static {
        __name(this, "ZodReadonly");
      }
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze2 = /* @__PURE__ */ __name((data) => {
          if (isValid(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        }, "freeze");
        return isAsync(result) ? result.then((data) => freeze2(data)) : freeze2(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    __name(cleanParams, "cleanParams");
    __name(custom, "custom");
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = /* @__PURE__ */ __name((cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params), "instanceOfType");
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
    onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
    oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
    coerce = {
      string: /* @__PURE__ */ __name((arg) => ZodString.create({ ...arg, coerce: true }), "string"),
      number: /* @__PURE__ */ __name((arg) => ZodNumber.create({ ...arg, coerce: true }), "number"),
      boolean: /* @__PURE__ */ __name((arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }), "boolean"),
      bigint: /* @__PURE__ */ __name((arg) => ZodBigInt.create({ ...arg, coerce: true }), "bigint"),
      date: /* @__PURE__ */ __name((arg) => ZodDate.create({ ...arg, coerce: true }), "date")
    };
    NEVER = INVALID;
  }
});

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});
var init_external = __esm({
  "node_modules/zod/v3/external.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_errors();
    init_parseUtil();
    init_typeAliases();
    init_util();
    init_types2();
    init_ZodError();
  }
});

// node_modules/zod/index.js
var init_zod = __esm({
  "node_modules/zod/index.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    init_external();
    init_external();
  }
});

// src/services/openapi-generator.ts
function generateOpenAPISpec(baseUrl, overrideBaseUrl) {
  const serverUrl = overrideBaseUrl || baseUrl;
  return {
    openapi: "3.1.0",
    info: {
      title: "Cloudflare Worker Management API",
      description: `
Conversational meta-API for managing and querying Cloudflare services.

\u{1F4AC} The model may ask questions naturally to gather required details.
It can infer default values (e.g. GET for listing, POST for creation)
and should confirm actions conversationally before execution.

**Example dialogue:**

User: "List my R2 buckets"
\u2192 GPT infers { product: "r2", method: "GET" }

User: "Deploy my worker"
\u2192 GPT asks: "Can you share the script name or code?" and then calls POST /api/call
  with { product: "workers", action: "deploy", body: {...} }

**How it works:**
- The model should infer reasonable defaults (GET for listing, POST for creating)
- Ask follow-up questions naturally if parameters are missing
- Use the /api/meta/help endpoint to discover available products and actions
- The API will automatically infer HTTP methods from action names if not provided

**Supported products:**
- workers: Cloudflare Workers scripts, deployments, settings
- r2: Object storage buckets
- d1: SQL databases
- kv: Key-value namespaces
- vectorize: AI vector indexes
- ai: Workers AI model inference
- pages: Pages projects
- tokens: API token management
`,
      version: "1.0.0",
      contact: {
        name: "API Support",
        url: serverUrl
      }
    },
    servers: [
      {
        url: serverUrl,
        description: "Production server"
      }
    ],
    security: [
      {
        bearerAuth: []
      }
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: "http",
          scheme: "bearer",
          bearerFormat: "JWT",
          description: "Authentication token for API access"
        }
      },
      schemas: {
        Error: zodToOpenAPISchema(schemas.ErrorResponse),
        Success: zodToOpenAPISchema(schemas.SuccessResponse),
        HealthCheck: zodToOpenAPISchema(schemas.HealthCheckResponse),
        CreateTokenRequest: zodToOpenAPISchema(schemas.CreateTokenRequest),
        DeployWorkerRequest: zodToOpenAPISchema(schemas.DeployWorkerRequest),
        CreateProjectRequest: zodToOpenAPISchema(schemas.CreateProjectRequest),
        SetupCICDRequest: zodToOpenAPISchema(schemas.SetupCICDRequest),
        HealthCheckWorkersRequest: zodToOpenAPISchema(schemas.HealthCheckWorkersRequest),
        MetaApiCallRequest: zodToOpenAPISchema(schemas.MetaApiCallRequest)
      }
    },
    paths: {
      "/health": {
        get: {
          summary: "Health check",
          description: "Check if the API is operational",
          operationId: "healthCheck",
          security: [],
          responses: {
            "200": {
              description: "Service is healthy",
              content: {
                "application/json": {
                  schema: { $ref: "#/components/schemas/HealthCheck" }
                }
              }
            }
          }
        }
      },
      "/flows/token/create": {
        post: {
          summary: "Create managed API token",
          description: "Create a Cloudflare API token with secure storage and audit trail",
          operationId: "createManagedToken",
          requestBody: {
            required: true,
            content: {
              "application/json": {
                schema: { $ref: "#/components/schemas/CreateTokenRequest" }
              }
            }
          },
          responses: {
            "201": {
              description: "Token created successfully",
              content: {
                "application/json": {
                  schema: { $ref: "#/components/schemas/Success" }
                }
              }
            },
            "400": { $ref: "#/components/responses/BadRequest" },
            "500": { $ref: "#/components/responses/ServerError" }
          }
        }
      },
      "/flows/deploy/from-content": {
        post: {
          summary: "Deploy worker from content",
          description: "Deploy a Cloudflare Worker from JavaScript/TypeScript content",
          operationId: "deployWorkerFromContent",
          requestBody: {
            required: true,
            content: {
              "application/json": {
                schema: { $ref: "#/components/schemas/DeployWorkerRequest" }
              }
            }
          },
          responses: {
            "201": {
              description: "Worker deployed successfully",
              content: {
                "application/json": {
                  schema: { $ref: "#/components/schemas/Success" }
                }
              }
            },
            "400": { $ref: "#/components/responses/BadRequest" },
            "500": { $ref: "#/components/responses/ServerError" }
          }
        }
      },
      "/flows/project/create": {
        post: {
          summary: "Create project with bindings",
          description: "Create a complete project with KV, D1, R2, and other bindings",
          operationId: "createProject",
          requestBody: {
            required: true,
            content: {
              "application/json": {
                schema: { $ref: "#/components/schemas/CreateProjectRequest" }
              }
            }
          },
          responses: {
            "201": {
              description: "Project created successfully",
              content: {
                "application/json": {
                  schema: { $ref: "#/components/schemas/Success" }
                }
              }
            }
          }
        }
      },
      "/flows/cicd/setup": {
        post: {
          summary: "Setup CI/CD for worker",
          description: "Configure CI/CD pipeline for an existing worker",
          operationId: "setupCICD",
          requestBody: {
            required: true,
            content: {
              "application/json": {
                schema: { $ref: "#/components/schemas/SetupCICDRequest" }
              }
            }
          },
          responses: {
            "201": {
              description: "CI/CD configured successfully",
              content: {
                "application/json": {
                  schema: { $ref: "#/components/schemas/Success" }
                }
              }
            }
          }
        }
      },
      "/flows/health/check-recent-workers": {
        post: {
          summary: "Check worker health",
          description: "Monitor health of workers updated in the last N days",
          operationId: "checkWorkerHealth",
          requestBody: {
            required: true,
            content: {
              "application/json": {
                schema: { $ref: "#/components/schemas/HealthCheckWorkersRequest" }
              }
            }
          },
          responses: {
            "200": {
              description: "Health check completed",
              content: {
                "application/json": {
                  schema: { $ref: "#/components/schemas/Success" }
                }
              }
            }
          }
        }
      },
      "/api/raw/workers/scripts": {
        get: {
          summary: "List workers",
          description: "Get list of all Cloudflare Workers",
          operationId: "listWorkers",
          responses: {
            "200": {
              description: "List of workers",
              content: {
                "application/json": {
                  schema: { $ref: "#/components/schemas/Success" }
                }
              }
            }
          }
        }
      },
      "/api/call": {
        post: {
          summary: "Perform a Cloudflare API call (Conversational Meta-API)",
          description: `
The model may ask one short follow-up if details are missing. If product/method omitted, the server consults an internal coach to infer them.

The API automatically infers HTTP methods from action names:
- "list" or "get" \u2192 GET
- "create", "deploy", "run" \u2192 POST
- "update" \u2192 PUT
- "modify" \u2192 PATCH
- "delete" or "remove" \u2192 DELETE

If method is omitted, it will be inferred from action. If action is also omitted, method defaults to GET.
Product names are case-insensitive.

**Best practices:**
- For simple queries, only provide product and let the API infer the rest
- For complex operations, provide full details including body
- Use /api/meta/help to discover available capabilities
- Ask users conversationally for missing required parameters
`,
          operationId: "cloudflare_meta_api_call",
          requestBody: {
            required: true,
            content: {
              "application/json": {
                schema: { $ref: "#/components/schemas/MetaApiCallRequest" },
                examples: {
                  listWorkers: {
                    summary: "List Cloudflare Workers",
                    description: "Example of a simple list request. Method can be omitted and will default to GET.",
                    value: {
                      product: "workers",
                      action: "list_scripts"
                    }
                  },
                  listWorkersMinimal: {
                    summary: "List Workers (minimal)",
                    description: "Minimal request - only product is required for listing operations.",
                    value: {
                      product: "workers"
                    }
                  },
                  listR2Buckets: {
                    summary: "List R2 buckets",
                    description: "List all R2 buckets in the account.",
                    value: {
                      product: "r2",
                      action: "list_buckets"
                    }
                  },
                  createBucket: {
                    summary: "Create R2 bucket",
                    description: "Create a new R2 bucket with a name.",
                    value: {
                      product: "r2",
                      action: "create_bucket",
                      method: "POST",
                      body: { name: "my-bucket" }
                    }
                  },
                  deployWorker: {
                    summary: "Deploy a Worker script",
                    description: "Deploy a new Worker script with content.",
                    value: {
                      product: "workers",
                      action: "deploy",
                      method: "POST",
                      params: { script_name: "hello-world" },
                      body: {
                        script: "export default { fetch() { return new Response('Hi!') } }"
                      }
                    }
                  },
                  runAIPrompt: {
                    summary: "Run AI model inference",
                    description: "Execute a Workers AI model with text input.",
                    value: {
                      product: "ai",
                      action: "run",
                      method: "POST",
                      body: {
                        model: "@cf/meta/llama-2-7b-chat-int8",
                        text: ["Hello, how are you?"]
                      }
                    }
                  },
                  listD1Databases: {
                    summary: "List D1 databases",
                    description: "List all D1 databases in the account.",
                    value: {
                      product: "d1",
                      action: "list_databases"
                    }
                  },
                  listKVNamespaces: {
                    summary: "List KV namespaces",
                    description: "List all KV namespaces in the account.",
                    value: {
                      product: "kv",
                      action: "list_namespaces"
                    }
                  }
                }
              }
            }
          },
          responses: {
            "200": {
              description: "Successful Cloudflare API response",
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {
                      success: { type: "boolean" },
                      result: { type: "object" },
                      errors: { type: "array", items: { type: "string" } }
                    }
                  }
                }
              }
            },
            "400": {
              description: "Needs one clarification or invalid input",
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {
                      success: { type: "boolean" },
                      needs_clarification: { type: "boolean" },
                      message: { type: "string" },
                      error: { type: "string" },
                      details: { type: "object" }
                    }
                  },
                  example: {
                    success: false,
                    needs_clarification: true,
                    message: "Which product\u2014workers, r2, d1, vectorize, ai?"
                  }
                }
              }
            },
            "500": { $ref: "#/components/responses/ServerError" }
          }
        }
      },
      "/api/meta/help": {
        get: {
          summary: "List available products and actions",
          description: `
Returns a discoverable list of supported Cloudflare products and common actions.
GPT Actions will often hit this first on a cold start to discover capabilities.

This endpoint helps the model understand what operations are available without
having to guess or ask the user for every detail.
`,
          operationId: "getMetaHelp",
          responses: {
            "200": {
              description: "Supported endpoints list",
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {
                      success: { type: "boolean" },
                      result: {
                        type: "object",
                        properties: {
                          products: {
                            type: "array",
                            items: { type: "string" },
                            description: "List of available Cloudflare products"
                          },
                          mappings: {
                            type: "object",
                            description: "Detailed mappings for each product with base paths and verbs",
                            additionalProperties: {
                              type: "object",
                              properties: {
                                permission: { type: "string" },
                                base_path: { type: "string" },
                                verbs: { type: "string" },
                                actions: {
                                  type: "array",
                                  items: { type: "string" }
                                }
                              }
                            }
                          },
                          usage: {
                            type: "object",
                            description: "Usage examples and guidance",
                            properties: {
                              description: { type: "string" },
                              examples: {
                                type: "array",
                                items: {
                                  type: "object",
                                  properties: {
                                    product: { type: "string" },
                                    action: { type: "string" }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  example: {
                    success: true,
                    result: {
                      products: ["workers", "r2", "d1", "kv", "vectorize", "ai", "pages", "tokens"],
                      mappings: {
                        workers: {
                          permission: "Workers Scripts:Edit",
                          base_path: "/accounts/{account_id}/workers/scripts",
                          verbs: "GET,POST,PUT,DELETE",
                          actions: ["list", "deploy", "delete"]
                        },
                        r2: {
                          permission: "R2:Edit",
                          base_path: "/accounts/{account_id}/r2/buckets",
                          verbs: "GET,POST,DELETE",
                          actions: ["list_buckets", "create_bucket", "delete_bucket"]
                        },
                        vectorize: {
                          permission: "Vectorize:Edit",
                          base_path: "/accounts/{account_id}/vectorize/indexes",
                          verbs: "GET,POST,DELETE",
                          actions: ["list_indexes", "query", "delete_index"]
                        },
                        ai: {
                          permission: "Workers AI:Edit",
                          base_path: "/accounts/{account_id}/ai/run",
                          verbs: "POST",
                          actions: ["list_models", "run"]
                        }
                      },
                      usage: {
                        description: "Use /api/call with product and optional action/method to make API calls",
                        examples: [
                          { product: "workers", action: "list_scripts" },
                          { product: "r2", action: "list_buckets" },
                          { product: "d1", action: "list_databases" }
                        ]
                      }
                    }
                  }
                }
              }
            },
            "500": { $ref: "#/components/responses/ServerError" }
          }
        }
      },
      "/api/coach": {
        post: {
          summary: "Reasoning coach (optional direct access)",
          description: `
Lets the model ask the coach for a suggestion explicitly. Usually not necessary because /api/call auto-consults the coach when needed.

This endpoint allows GPT to directly consult the context coach for intent interpretation.
`,
          operationId: "coachSuggest",
          requestBody: {
            required: true,
            content: {
              "application/json": {
                schema: {
                  type: "object",
                  properties: {
                    prompt: {
                      type: "string",
                      description: "Natural language prompt describing the user intent"
                    },
                    context: {
                      type: "object",
                      additionalProperties: true,
                      description: "Optional context about recent conversation or hints"
                    }
                  },
                  required: ["prompt"]
                },
                examples: {
                  inferWorkers: {
                    summary: "Workers listing intent",
                    value: {
                      prompt: "list my workers",
                      context: { recent: "user mentioned Workers" }
                    }
                  }
                }
              }
            }
          },
          responses: {
            "200": {
              description: "Coach suggestion",
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {
                      confidence: { type: "number", minimum: 0, maximum: 1 },
                      product: { type: "string", nullable: true },
                      action: { type: "string", nullable: true },
                      method: {
                        type: "string",
                        enum: ["GET", "POST", "PUT", "PATCH", "DELETE"],
                        nullable: true
                      },
                      next_step: { type: "string", enum: ["clarify", "execute"] },
                      coach_message: { type: "string" }
                    }
                  },
                  example: {
                    confidence: 0.86,
                    product: "workers",
                    action: "list",
                    method: "GET",
                    next_step: "execute",
                    coach_message: "Looks like they want a Workers list; proceed to fetch scripts."
                  }
                }
              }
            },
            "400": { $ref: "#/components/responses/BadRequest" },
            "500": { $ref: "#/components/responses/ServerError" },
            "503": {
              description: "Coach service not available",
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {
                      error: { type: "string" }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "/api/telemetry/stats": {
        get: {
          summary: "Get coach telemetry statistics",
          description: "Returns rolling statistics about coach inferences, confidence scores, and clarification rates.",
          operationId: "getTelemetryStats",
          parameters: [
            {
              name: "days",
              in: "query",
              schema: { type: "integer", default: 7 },
              description: "Number of days to look back for statistics"
            }
          ],
          responses: {
            "200": {
              description: "Telemetry statistics",
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {
                      success: { type: "boolean" },
                      result: {
                        type: "object",
                        properties: {
                          stats: {
                            type: "object",
                            properties: {
                              total: { type: "integer" },
                              clarifications: { type: "integer" },
                              executed: { type: "integer" },
                              avg_confidence: { type: "number" }
                            }
                          },
                          recent: { type: "array" },
                          total_recent: { type: "integer" }
                        }
                      }
                    }
                  }
                }
              }
            },
            "500": { $ref: "#/components/responses/ServerError" }
          }
        }
      },
      "/api/telemetry/tune": {
        post: {
          summary: "Manually trigger coach threshold auto-tuning",
          description: "Triggers the auto-tuning algorithm to adjust the clarification threshold based on recent telemetry data.",
          operationId: "tuneThreshold",
          responses: {
            "200": {
              description: "Tuning result",
              content: {
                "application/json": {
                  schema: {
                    type: "object",
                    properties: {
                      success: { type: "boolean" },
                      result: {
                        type: "object",
                        properties: {
                          clarRate: { type: "number" },
                          avgConf: { type: "number" },
                          newThreshold: { type: "number" }
                        }
                      }
                    }
                  },
                  example: {
                    success: true,
                    result: {
                      clarRate: 0.18,
                      avgConf: 0.82,
                      newThreshold: 0.804
                    }
                  }
                }
              }
            },
            "500": { $ref: "#/components/responses/ServerError" }
          }
        }
      }
    },
    responses: {
      BadRequest: {
        description: "Bad request",
        content: {
          "application/json": {
            schema: { $ref: "#/components/schemas/Error" }
          }
        }
      },
      ServerError: {
        description: "Internal server error",
        content: {
          "application/json": {
            schema: { $ref: "#/components/schemas/Error" }
          }
        }
      }
    }
  };
}
function zodToOpenAPISchema(zodSchema) {
  if (zodSchema instanceof external_exports.ZodObject) {
    const shape = zodSchema._def.shape();
    const properties = {};
    const required = [];
    for (const [key, value] of Object.entries(shape)) {
      properties[key] = zodToOpenAPISchema(value);
      if (!value.isOptional()) {
        required.push(key);
      }
    }
    return {
      type: "object",
      properties,
      required: required.length > 0 ? required : void 0
    };
  }
  if (zodSchema instanceof external_exports.ZodString) {
    return { type: "string", description: zodSchema.description };
  }
  if (zodSchema instanceof external_exports.ZodNumber) {
    return { type: "number", description: zodSchema.description };
  }
  if (zodSchema instanceof external_exports.ZodBoolean) {
    return { type: "boolean", description: zodSchema.description };
  }
  if (zodSchema instanceof external_exports.ZodArray) {
    return {
      type: "array",
      items: zodToOpenAPISchema(zodSchema._def.type)
    };
  }
  if (zodSchema instanceof external_exports.ZodLiteral) {
    const value = zodSchema._def.value;
    if (typeof value === "boolean") {
      return { type: "boolean", const: value };
    }
    if (typeof value === "number") {
      return { type: "number", const: value };
    }
    return { type: "string", const: String(value) };
  }
  if (zodSchema instanceof external_exports.ZodEnum) {
    return { type: "string", enum: zodSchema._def.values };
  }
  if (zodSchema instanceof external_exports.ZodRecord) {
    return {
      type: "object",
      additionalProperties: zodToOpenAPISchema(zodSchema._def.valueType)
    };
  }
  return { type: "string" };
}
function jsonToYaml(obj, indent = 0) {
  const spaces = "  ".repeat(indent);
  let yaml = "";
  for (const [key, value] of Object.entries(obj)) {
    if (value === null || value === void 0) {
      continue;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
      yaml += `${spaces}${key}:
${jsonToYaml(value, indent + 1)}`;
    } else if (Array.isArray(value)) {
      yaml += `${spaces}${key}:
`;
      for (const item of value) {
        if (typeof item === "object") {
          yaml += `${spaces}- 
${jsonToYaml(item, indent + 2)}`;
        } else {
          yaml += `${spaces}- ${item}
`;
        }
      }
    } else if (typeof value === "string") {
      yaml += `${spaces}${key}: "${value}"
`;
    } else {
      yaml += `${spaces}${key}: ${value}
`;
    }
  }
  return yaml;
}
var schemas;
var init_openapi_generator = __esm({
  "src/services/openapi-generator.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_zod();
    schemas = {
      // Error response
      ErrorResponse: external_exports.object({
        success: external_exports.literal(false),
        error: external_exports.string(),
        details: external_exports.string().optional()
      }),
      // Success response wrapper
      SuccessResponse: external_exports.object({
        success: external_exports.literal(true),
        result: external_exports.any(),
        message: external_exports.string().optional()
      }),
      // Health check
      HealthCheckResponse: external_exports.object({
        status: external_exports.string(),
        version: external_exports.string(),
        timestamp: external_exports.string()
      }),
      // Token creation
      CreateTokenRequest: external_exports.object({
        name: external_exports.string().describe("Token name"),
        purpose: external_exports.string().describe("What this token will be used for"),
        permissions: external_exports.array(external_exports.object({
          id: external_exports.string(),
          name: external_exports.string().optional()
        })),
        ttl_days: external_exports.number().optional().describe("Days until expiration"),
        policies: external_exports.array(external_exports.any())
      }),
      // Worker deployment
      DeployWorkerRequest: external_exports.object({
        script_name: external_exports.string().describe("Worker script name"),
        content: external_exports.string().describe("Worker JavaScript/TypeScript content"),
        compatibility_date: external_exports.string().optional().default("2024-06-01"),
        bindings: external_exports.object({
          kv: external_exports.array(external_exports.object({ binding: external_exports.string(), id: external_exports.string() })).optional(),
          d1: external_exports.array(external_exports.object({ binding: external_exports.string(), database_id: external_exports.string() })).optional(),
          r2: external_exports.array(external_exports.object({ binding: external_exports.string(), bucket_name: external_exports.string() })).optional()
        }).optional(),
        vars: external_exports.record(external_exports.string()).optional()
      }),
      // Project creation
      CreateProjectRequest: external_exports.object({
        projectName: external_exports.string(),
        bindings: external_exports.array(external_exports.enum(["kv", "d1", "r2", "analytics_engine", "queue"])).optional(),
        githubOwner: external_exports.string().optional(),
        githubRepo: external_exports.string().optional()
      }),
      // CI/CD setup
      SetupCICDRequest: external_exports.object({
        worker_name: external_exports.string(),
        github_owner: external_exports.string(),
        github_repo: external_exports.string(),
        production_branch: external_exports.string().optional().default("main"),
        auto_deploy: external_exports.boolean().optional().default(true)
      }),
      // Health check request
      HealthCheckWorkersRequest: external_exports.object({
        days: external_exports.number().optional().default(7).describe("Check workers updated in last N days"),
        include_observability: external_exports.boolean().optional().default(true),
        filter_pattern: external_exports.string().optional().describe("Filter workers by name pattern")
      }),
      // Meta API Gateway request
      MetaApiCallRequest: external_exports.object({
        product: external_exports.string().describe(`
Cloudflare product area. Infer from user intent:
- "workers" for code, scripts, or deploy actions
- "r2" for object storage and buckets
- "d1" for SQL databases
- "kv" for key-value storage
- "vectorize" for AI vector indexes
- "ai" for model inference and Workers AI
- "pages" for Pages projects
- "tokens" for API token management
`),
        action: external_exports.string().optional().describe(`
Optional semantic action name. Infer from context:
- "list" or "list_*" \u2192 typically GET
- "create" or "deploy" \u2192 typically POST
- "update" or "modify" \u2192 typically PUT/PATCH
- "delete" or "remove" \u2192 typically DELETE
- "run" or "execute" \u2192 typically POST
If method is not provided, it will be inferred from action.
`),
        method: external_exports.enum(["GET", "POST", "PUT", "PATCH", "DELETE"]).optional().describe(`
HTTP method. If not provided, will be inferred from action:
- "list" \u2192 GET
- "create", "deploy", "run" \u2192 POST
- "update" \u2192 PUT/PATCH
- "delete" \u2192 DELETE
Defaults to GET if action is not provided.
`),
        params: external_exports.record(external_exports.any()).optional().describe("Path or query parameters to inject into endpoint URL (e.g. {account_id}, {zone_id}, {script_name})"),
        body: external_exports.record(external_exports.any()).optional().describe("Optional JSON request body for POST/PUT/PATCH operations")
      })
    };
    __name(generateOpenAPISpec, "generateOpenAPISpec");
    __name(zodToOpenAPISchema, "zodToOpenAPISchema");
    __name(jsonToYaml, "jsonToYaml");
  }
});

// src/services/self-healing.ts
var self_healing_exports = {};
__export(self_healing_exports, {
  SelfHealingService: () => SelfHealingService
});
var SelfHealingService;
var init_self_healing = __esm({
  "src/services/self-healing.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_types();
    init_client();
    init_apiClient();
    SelfHealingService = class {
      static {
        __name(this, "SelfHealingService");
      }
      env;
      db;
      apiClient;
      accountId;
      stepCallbacks = /* @__PURE__ */ new Map();
      // For real-time updates
      constructor(env, accountId) {
        this.env = env;
        this.db = initDb(env);
        this.accountId = accountId;
        this.apiClient = new CloudflareApiClient({ apiToken: getCloudflareToken(env) });
      }
      /**
       * Register a callback for real-time step updates
       */
      onStepUpdate(attemptId, callback) {
        this.stepCallbacks.set(attemptId, callback);
      }
      /**
       * Log a healing step to the database and notify callbacks
       */
      async logStep(attemptId, stepNumber, stepType, title, content, status = "in_progress", aiThoughts, decision, metadata) {
        const stepId = generateUUID();
        const now = (/* @__PURE__ */ new Date()).toISOString();
        await this.db.insertInto("self_healing_steps").values({
          id: stepId,
          healing_attempt_id: attemptId,
          step_number: stepNumber,
          step_type: stepType,
          title,
          content,
          ai_thoughts: aiThoughts || null,
          decision: decision || null,
          status,
          metadata: metadata ? JSON.stringify(metadata) : null,
          created_at: now
        }).execute();
        const callback = this.stepCallbacks.get(attemptId);
        if (callback) {
          callback({
            id: stepId,
            step_number: stepNumber,
            step_type: stepType,
            title,
            content,
            ai_thoughts: aiThoughts,
            decision,
            status,
            metadata,
            created_at: now
          });
        }
        return stepId;
      }
      /**
       * Analyze failed health tests and attempt to heal them using AI
       * Now with detailed step-by-step logging
       */
      async analyzeAndHeal(healthCheckGroupId, failedTests) {
        const results = [];
        for (const test of failedTests) {
          const attemptId = generateUUID();
          let stepNumber = 0;
          try {
            const now = (/* @__PURE__ */ new Date()).toISOString();
            await this.db.insertInto("self_healing_attempts").values({
              id: attemptId,
              health_check_group_id: healthCheckGroupId,
              health_test_result_id: test.test_result_id || null,
              health_test_id: test.test_id,
              ai_analysis: "",
              // Will be updated
              ai_recommendation: "",
              // Will be updated
              healing_action: "",
              // Will be updated
              action_details: "",
              status: "in_progress",
              created_at: now,
              updated_at: now
            }).execute();
            stepNumber++;
            await this.logStep(
              attemptId,
              stepNumber,
              "thinking",
              "Analyzing Error",
              `Starting analysis of failed test: ${test.test_name}`,
              "in_progress",
              `I need to understand why this test failed. The endpoint ${test.http_method} ${test.endpoint_path} returned status ${test.status} with message: ${test.status_text}`
            );
            stepNumber++;
            await this.logStep(
              attemptId,
              stepNumber,
              "analysis",
              "AI Error Analysis",
              "Querying Workers AI to analyze the root cause...",
              "in_progress",
              "Using AI to understand the error pattern and determine the most likely cause."
            );
            const aiAnalysis = await this.analyzeErrorWithAI(test, attemptId, stepNumber);
            await this.logStep(
              attemptId,
              stepNumber,
              "analysis",
              "AI Error Analysis",
              `AI Analysis Complete: ${aiAnalysis.analysis}`,
              "completed",
              aiAnalysis.analysis,
              void 0,
              { error_type: aiAnalysis.error_type, can_auto_fix: aiAnalysis.can_auto_fix }
            );
            stepNumber++;
            await this.logStep(
              attemptId,
              stepNumber,
              "decision",
              "Determining Healing Action",
              "Evaluating possible fixes based on AI analysis...",
              "in_progress",
              `Based on the analysis, the error type is: ${aiAnalysis.error_type}. Can auto-fix: ${aiAnalysis.can_auto_fix ? "Yes" : "No"}`
            );
            const healingAction = await this.determineHealingAction(test, aiAnalysis);
            await this.logStep(
              attemptId,
              stepNumber,
              "decision",
              "Healing Action Decided",
              `Action: ${healingAction.description}`,
              "completed",
              `I've decided to ${healingAction.type.replace(/_/g, " ")} because: ${aiAnalysis.recommendation}`,
              `Proceeding with: ${healingAction.type}`,
              healingAction.details
            );
            await this.db.updateTable("self_healing_attempts").set({
              ai_analysis: aiAnalysis.analysis,
              ai_recommendation: aiAnalysis.recommendation,
              healing_action: healingAction.type,
              action_details: JSON.stringify(healingAction.details),
              updated_at: (/* @__PURE__ */ new Date()).toISOString()
            }).where("id", "=", attemptId).execute();
            stepNumber++;
            await this.logStep(
              attemptId,
              stepNumber,
              "action",
              "Executing Healing Action",
              `Performing: ${healingAction.type.replace(/_/g, " ")}...`,
              "in_progress",
              `Now executing the healing action: ${healingAction.description}`
            );
            const healingResult = await this.executeHealingAction(
              attemptId,
              test,
              healingAction,
              aiAnalysis,
              stepNumber
            );
            stepNumber++;
            await this.logStep(
              attemptId,
              stepNumber,
              "verification",
              "Verifying Healing Effectiveness",
              "Analyzing whether the healing action resolved the issue...",
              "in_progress",
              "Checking if the fix was successful and if any manual steps are required."
            );
            const effectivenessAnalysis = await this.analyzeEffectiveness(
              attemptId,
              test,
              healingResult,
              stepNumber
            );
            await this.db.updateTable("self_healing_attempts").set({
              status: healingResult.status,
              verification_result: JSON.stringify(healingResult.verification_result),
              effectiveness_analysis: effectivenessAnalysis.analysis,
              manual_steps_required: effectivenessAnalysis.manual_steps,
              updated_at: (/* @__PURE__ */ new Date()).toISOString()
            }).where("id", "=", attemptId).execute();
            await this.logStep(
              attemptId,
              stepNumber,
              "verification",
              "Verification Complete",
              effectivenessAnalysis.analysis,
              healingResult.status === "success" ? "completed" : "failed",
              effectivenessAnalysis.analysis,
              healingResult.status === "success" ? "Healing was effective" : "Healing requires manual intervention",
              {
                status: healingResult.status,
                effective: healingResult.status === "success",
                manual_steps: effectivenessAnalysis.manual_steps
              }
            );
            results.push({
              ...healingResult,
              effectiveness_analysis: effectivenessAnalysis.analysis,
              manual_steps_required: effectivenessAnalysis.manual_steps || void 0
            });
          } catch (error) {
            console.error(`Failed to heal test ${test.test_name}:`, error);
            stepNumber++;
            await this.logStep(
              attemptId,
              stepNumber,
              "analysis",
              "Healing Failed",
              `Error: ${error.message}`,
              "failed",
              `The healing process encountered an error: ${error.message}`,
              "Manual intervention required",
              { error: error.message, stack: error.stack }
            );
            await this.db.updateTable("self_healing_attempts").set({
              status: "failed",
              error_message: error.message,
              updated_at: (/* @__PURE__ */ new Date()).toISOString()
            }).where("id", "=", attemptId).execute();
            results.push({
              attempt_id: attemptId,
              health_check_group_id: healthCheckGroupId,
              health_test_id: test.test_id,
              ai_analysis: "Failed to analyze error",
              ai_recommendation: "Manual intervention required",
              healing_action: {
                type: "other",
                details: {},
                description: "Healing attempt failed"
              },
              status: "failed",
              error_message: error.message
            });
          }
        }
        return results;
      }
      /**
       * Analyze effectiveness of healing action
       */
      async analyzeEffectiveness(attemptId, test, healingResult, currentStepNumber) {
        if (!this.env.AI) {
          return {
            analysis: healingResult.status === "success" ? "Healing action completed. Please verify the fix by running the health check again." : "Healing action did not fully resolve the issue. Manual intervention may be required.",
            manual_steps: healingResult.error_message || null
          };
        }
        try {
          const prompt = `Analyze whether this healing action was effective:

Test: ${test.test_name}
Endpoint: ${test.http_method} ${test.endpoint_path}
Original Error: ${test.status_text}
Healing Action: ${healingResult.healing_action.type}
Action Status: ${healingResult.status}
Verification Result: ${JSON.stringify(healingResult.verification_result || {})}

Determine:
1. Was the healing action effective?
2. Does the issue appear to be resolved?
3. What manual steps (if any) are still required?

Return JSON:
{
  "analysis": "Detailed analysis of effectiveness",
  "effective": true/false,
  "manual_steps": "Step-by-step manual actions if needed, or null if fully automated"
}`;
          const aiResponse = await this.env.AI.run("@cf/openai/gpt-oss-120b", {
            instructions: "You are a Cloudflare API expert. Analyze healing effectiveness and provide actionable guidance.",
            input: prompt
          });
          const responseText = typeof aiResponse === "string" ? aiResponse : aiResponse.response || JSON.stringify(aiResponse);
          let parsed;
          try {
            const jsonMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/) || responseText.match(/```\s*([\s\S]*?)\s*```/) || [null, responseText];
            parsed = JSON.parse(jsonMatch[1] || jsonMatch[0] || responseText);
          } catch {
            parsed = {
              analysis: responseText.substring(0, 500),
              effective: healingResult.status === "success",
              manual_steps: null
            };
          }
          return {
            analysis: parsed.analysis || "Effectiveness analysis unavailable",
            manual_steps: parsed.manual_steps || null
          };
        } catch (error) {
          return {
            analysis: `Effectiveness analysis failed: ${error.message}. Status: ${healingResult.status}`,
            manual_steps: healingResult.error_message || null
          };
        }
      }
      /**
       * Use Workers AI to analyze the error and recommend a fix
       */
      async analyzeErrorWithAI(test, attemptId, currentStepNumber) {
        if (!this.env.AI) {
          return this.analyzeErrorPattern(test);
        }
        try {
          const errorContext = {
            test_name: test.test_name,
            endpoint: test.endpoint_path,
            method: test.http_method,
            status_code: test.status,
            status_text: test.status_text,
            error_message: test.error_message,
            response_body: test.response_body ? test.response_body.substring(0, 500) : null
          };
          const prompt = `Analyze this health check failure and recommend a fix:

Test: ${test.test_name}
Endpoint: ${test.http_method} ${test.endpoint_path}
Status: ${test.status} ${test.status_text}
Error: ${test.error_message || "No error message"}

Common issues:
1. Token permissions: "GET method not allowed for the api_token authentication scheme" or "Invalid token" - means the Cloudflare API token needs additional permissions
2. Invalid request body: "Bad input" or validation errors - means the request payload is incorrect
3. Endpoint not found: 404 errors - means the endpoint path is wrong
4. Authentication: "Valid user-level authentication not found" - means token type is wrong

Return JSON with:
{
  "analysis": "Brief analysis of the root cause",
  "recommendation": "Specific recommended fix",
  "error_type": "token_permissions" | "request_body" | "endpoint_path" | "authentication" | "other",
  "can_auto_fix": true/false,
  "required_permissions": ["permission1", "permission2"] (if error_type is token_permissions),
  "suggested_fix": "specific action to take"
}`;
          const aiResponse = await this.env.AI.run("@cf/openai/gpt-oss-120b", {
            instructions: "You are a Cloudflare API expert. Analyze health check failures and recommend fixes. Always return valid JSON.",
            input: JSON.stringify(errorContext)
          });
          const responseText = typeof aiResponse === "string" ? aiResponse : aiResponse.response || JSON.stringify(aiResponse);
          let parsed;
          try {
            const jsonMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/) || responseText.match(/```\s*([\s\S]*?)\s*```/) || [null, responseText];
            parsed = JSON.parse(jsonMatch[1] || jsonMatch[0] || responseText);
          } catch {
            return this.analyzeErrorPattern(test);
          }
          return {
            analysis: parsed.analysis || "Error analysis unavailable",
            recommendation: parsed.recommendation || "Manual review required",
            error_type: parsed.error_type || "other",
            can_auto_fix: parsed.can_auto_fix !== false
          };
        } catch (error) {
          console.error("AI analysis failed, using pattern matching:", error);
          return this.analyzeErrorPattern(test);
        }
      }
      /**
       * Pattern-based error analysis (fallback when AI is unavailable)
       */
      analyzeErrorPattern(test) {
        const errorText = (test.error_message || test.status_text || "").toLowerCase();
        const status = test.status;
        if (errorText.includes("method not allowed for the api_token") || errorText.includes("invalid token") || errorText.includes("code: 10000") || errorText.includes("code: 12006")) {
          return {
            analysis: "The Cloudflare API token is missing required permissions for this endpoint.",
            recommendation: "Update the API token to include the necessary permissions for this endpoint.",
            error_type: "token_permissions",
            can_auto_fix: true
          };
        }
        if (errorText.includes("valid user-level authentication not found") || errorText.includes("code: 9109") || status === 401) {
          return {
            analysis: "Authentication failed. The token may be invalid or the wrong type.",
            recommendation: "Verify the API token is valid and has the correct type (API Token vs User Service Key).",
            error_type: "authentication",
            can_auto_fix: false
            // Can't auto-fix invalid tokens
          };
        }
        if (errorText.includes("bad input") || errorText.includes("required properties") || errorText.includes("oneOf") || status === 400) {
          return {
            analysis: "The request body is invalid or missing required fields.",
            recommendation: "Fix the request body format and required fields.",
            error_type: "request_body",
            can_auto_fix: true
          };
        }
        if (status === 404 || errorText.includes("not found")) {
          return {
            analysis: "The endpoint path is incorrect or not implemented.",
            recommendation: "Verify the endpoint path is correct or implement the missing endpoint.",
            error_type: "endpoint_path",
            can_auto_fix: false
          };
        }
        return {
          analysis: `Unknown error: ${test.status_text || "No error message"}`,
          recommendation: "Manual review required to determine the root cause.",
          error_type: "other",
          can_auto_fix: false
        };
      }
      /**
       * Determine the healing action based on AI analysis
       */
      async determineHealingAction(test, aiAnalysis) {
        if (aiAnalysis.error_type === "token_permissions" && aiAnalysis.can_auto_fix) {
          const requiredPermissions = await this.getRequiredPermissions(test.endpoint_path, test.http_method);
          return {
            type: "update_token_permissions",
            details: {
              endpoint_path: test.endpoint_path,
              http_method: test.http_method,
              required_permissions: requiredPermissions
            },
            description: `Update API token to include permissions: ${requiredPermissions.join(", ")}`
          };
        }
        if (aiAnalysis.error_type === "request_body" && aiAnalysis.can_auto_fix) {
          return {
            type: "fix_request_body",
            details: {
              endpoint_path: test.endpoint_path,
              http_method: test.http_method,
              current_body: test.response_body
            },
            description: "Fix request body format based on API requirements"
          };
        }
        return {
          type: "other",
          details: {
            error_type: aiAnalysis.error_type,
            recommendation: aiAnalysis.recommendation
          },
          description: aiAnalysis.recommendation
        };
      }
      /**
       * Get required permissions for an endpoint from the API permissions map using Drizzle ORM
       */
      async getRequiredPermissions(endpointPath, httpMethod) {
        try {
          const pathParts = endpointPath.split("/").slice(0, 4);
          const basePathPattern = `%${pathParts.join("/")}%`;
          const permissions = await this.db.selectFrom("api_permissions_map").where("base_path", "like", basePathPattern).select(["permission"]).execute();
          if (permissions.length > 0) {
            return permissions.map((p) => p.permission);
          }
          const inferred = [];
          if (endpointPath.includes("/workers/")) {
            inferred.push("Workers Scripts:Edit");
          }
          if (endpointPath.includes("/d1/")) {
            inferred.push("D1:Edit");
          }
          if (endpointPath.includes("/storage/kv/")) {
            inferred.push("Workers KV Storage:Edit");
          }
          if (endpointPath.includes("/r2/")) {
            inferred.push("Workers R2 Storage:Edit");
          }
          if (endpointPath.includes("/vectorize/")) {
            inferred.push("Vectorize:Edit");
          }
          if (endpointPath.includes("/ai/")) {
            inferred.push("Workers AI:Edit");
          }
          if (endpointPath.includes("/builds/")) {
            inferred.push("Workers Builds Configuration:Edit");
          }
          if (endpointPath.includes("/tokens")) {
            inferred.push("API Tokens:Edit");
          }
          return inferred.length > 0 ? inferred : ["Account:Read"];
        } catch (error) {
          console.error("Failed to get required permissions:", error);
          return [];
        }
      }
      /**
       * Execute the healing action
       */
      async executeHealingAction(attemptId, test, action, aiAnalysis, currentStepNumber) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        await this.db.updateTable("self_healing_attempts").set({
          status: "in_progress",
          updated_at: now
        }).where("id", "=", attemptId).execute();
        let errorMessage;
        try {
          let verificationResult = null;
          let status = "failed";
          if (action.type === "update_token_permissions") {
            const requiredPermissions = action.details.required_permissions || [];
            try {
              const permissionGroupsResponse = await fetch(
                "https://api.cloudflare.com/client/v4/user/tokens/permission_groups",
                {
                  headers: {
                    "Authorization": `Bearer ${getCloudflareToken(this.env)}`,
                    "Content-Type": "application/json"
                  }
                }
              );
              if (permissionGroupsResponse.ok) {
                const permissionGroups = await permissionGroupsResponse.json();
                const groups = permissionGroups.result || [];
                const policies = [];
                for (const permName of requiredPermissions) {
                  const group = groups.find(
                    (g) => g.name === permName || g.name.includes(permName.split(":")[0])
                  );
                  if (group) {
                    policies.push({
                      id: group.id,
                      effect: "allow",
                      resources: {}
                    });
                  }
                }
                if (policies.length > 0) {
                  await this.logStep(
                    attemptId,
                    currentStepNumber,
                    "action",
                    "Creating New Token",
                    `Creating new API token with ${policies.length} permission(s)...`,
                    "in_progress",
                    `I've mapped ${policies.length} required permissions. Now creating a new token with these permissions.`
                  );
                  const tokenName = `Auto-Healed-Token-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`;
                  const tokenResponse = await fetch(
                    "https://api.cloudflare.com/client/v4/user/tokens",
                    {
                      method: "POST",
                      headers: {
                        "Authorization": `Bearer ${getCloudflareToken(this.env)}`,
                        "Content-Type": "application/json"
                      },
                      body: JSON.stringify({
                        name: tokenName,
                        policies,
                        expires_on: new Date(Date.now() + 90 * 24 * 60 * 60 * 1e3).toISOString()
                        // 90 days
                      })
                    }
                  );
                  if (tokenResponse.ok) {
                    const tokenData = await tokenResponse.json();
                    verificationResult = {
                      action: "created_new_token",
                      token_name: tokenName,
                      token_id: tokenData.result?.id,
                      required_permissions: requiredPermissions,
                      note: `Created new token "${tokenName}" with required permissions. Update CLOUDFLARE_ACCOUNT_TOKEN environment variable with the new token value.`,
                      new_token_value: tokenData.result?.value,
                      // Include token value for easy update
                      warning: "Store this token securely and update your environment variables."
                    };
                    status = "success";
                  } else {
                    const errorText = await tokenResponse.text();
                    verificationResult = {
                      action: "documented_required_permissions",
                      required_permissions: requiredPermissions,
                      note: `Failed to create new token: ${errorText}. Please manually create a token with these permissions.`
                    };
                    status = "failed";
                    errorMessage = `Token creation failed: ${errorText}`;
                  }
                } else {
                  verificationResult = {
                    action: "documented_required_permissions",
                    required_permissions: requiredPermissions,
                    note: "Could not automatically create token. Please manually create a token with these permissions: " + requiredPermissions.join(", ")
                  };
                  status = "success";
                }
              } else {
                verificationResult = {
                  action: "documented_required_permissions",
                  required_permissions: requiredPermissions,
                  note: "Please create a new API token with these permissions: " + requiredPermissions.join(", ")
                };
                status = "success";
              }
            } catch (tokenError) {
              verificationResult = {
                action: "documented_required_permissions",
                required_permissions: action.details.required_permissions,
                note: `Could not create new token automatically: ${tokenError.message}. Please manually create a token with the required permissions.`
              };
              status = "success";
            }
          } else if (action.type === "fix_request_body") {
            verificationResult = {
              action: "analyzed_request_body",
              note: "Request body format needs to be corrected. Check API documentation for required fields."
            };
            status = "success";
          } else {
            verificationResult = {
              action: "analyzed",
              recommendation: action.description
            };
            status = "success";
          }
          await this.db.updateTable("self_healing_attempts").set({
            status,
            verification_result: JSON.stringify(verificationResult),
            updated_at: now
          }).where("id", "=", attemptId).execute();
          return {
            attempt_id: attemptId,
            health_check_group_id: test.health_check_group_id || "",
            health_test_id: test.test_id,
            ai_analysis: aiAnalysis.analysis,
            ai_recommendation: aiAnalysis.recommendation,
            healing_action: action,
            status,
            verification_result: verificationResult
          };
        } catch (error) {
          errorMessage = error.message;
          await this.db.updateTable("self_healing_attempts").set({
            status: "failed",
            error_message: errorMessage,
            updated_at: now
          }).where("id", "=", attemptId).execute();
          return {
            attempt_id: attemptId,
            health_check_group_id: test.health_check_group_id || "",
            health_test_id: test.test_id,
            ai_analysis: aiAnalysis.analysis,
            ai_recommendation: aiAnalysis.recommendation,
            healing_action: action,
            status: "failed",
            error_message: errorMessage
          };
        }
      }
      /**
       * Get all healing attempts for a health check group using Kysely
       */
      async getHealingAttempts(healthCheckGroupId) {
        const attempts = await this.db.selectFrom("self_healing_attempts").where("health_check_group_id", "=", healthCheckGroupId).orderBy("created_at", "desc").selectAll().execute();
        const attemptsWithSteps = await Promise.all(
          attempts.map(async (attempt) => {
            const steps = await this.db.selectFrom("self_healing_steps").where("healing_attempt_id", "=", attempt.id).orderBy("step_number").selectAll().execute();
            return {
              ...attempt,
              action_details: attempt.action_details ? JSON.parse(attempt.action_details) : null,
              verification_result: attempt.verification_result ? JSON.parse(attempt.verification_result) : null,
              steps: steps.map((step) => ({
                id: step.id,
                step_number: step.step_number,
                step_type: step.step_type,
                title: step.title,
                content: step.content,
                ai_thoughts: step.ai_thoughts,
                decision: step.decision,
                status: step.status,
                metadata: step.metadata ? JSON.parse(step.metadata) : null,
                created_at: step.created_at
              }))
            };
          })
        );
        return attemptsWithSteps;
      }
      async getHealingSteps(attemptId) {
        const steps = await this.db.selectFrom("self_healing_steps").where("healing_attempt_id", "=", attemptId).orderBy("step_number").selectAll().execute();
        return steps.map((step) => ({
          id: step.id,
          healing_attempt_id: step.healing_attempt_id,
          step_number: step.step_number,
          step_type: step.step_type,
          title: step.title,
          content: step.content,
          ai_thoughts: step.ai_thoughts,
          decision: step.decision,
          status: step.status,
          metadata: step.metadata ? JSON.parse(step.metadata) : null,
          created_at: step.created_at
        }));
      }
      async getHealingAttemptsForSession(healthCheckGroupId) {
        const attempts = await this.db.selectFrom("self_healing_attempts").where("health_check_group_id", "=", healthCheckGroupId).selectAll().execute();
        return attempts.map((attempt) => ({
          attempt_id: attempt.id,
          health_check_group_id: attempt.health_check_group_id,
          health_test_id: attempt.health_test_id,
          ai_analysis: attempt.ai_analysis,
          ai_recommendation: attempt.ai_recommendation,
          healing_action: attempt.healing_action ? JSON.parse(attempt.healing_action) : { type: "other", details: {}, description: "Unknown action" },
          status: attempt.status,
          error_message: attempt.error_message || void 0,
          verification_result: attempt.verification_result ? JSON.parse(attempt.verification_result) : void 0,
          effectiveness_analysis: attempt.effectiveness_analysis || void 0,
          manual_steps_required: attempt.manual_steps_required || void 0,
          test_name: "Unknown Test"
          // Will be enriched by the caller
        }));
      }
    };
  }
});

// src/routes/health.ts
async function generateAiInsights(data, db, days = 30) {
  const insights = [];
  const insightFixes = db ? await db.selectFrom("insight_fixes").select(["insight_type", "insight_category", "fixed_at", "fix_description"]).execute() : [];
  const wasRecentlyFixed = /* @__PURE__ */ __name((insightType, category) => {
    const relevantFixes = insightFixes.filter((fix) => {
      const typeMatches = fix.insight_type === insightType;
      const categoryMatches = !category || !fix.insight_category || fix.insight_category === category;
      return typeMatches && categoryMatches;
    });
    if (relevantFixes.length === 0) return { fixed: false };
    const latestFix = relevantFixes.sort(
      (a, b) => new Date(b.fixed_at).getTime() - new Date(a.fixed_at).getTime()
    )[0];
    return {
      fixed: true,
      fixDate: latestFix.fixed_at,
      description: latestFix.fix_description
    };
  }, "wasRecentlyFixed");
  const getDataCutoffDate = /* @__PURE__ */ __name((insightType, category) => {
    const fixInfo = wasRecentlyFixed(insightType, category);
    return fixInfo.fixed ? new Date(fixInfo.fixDate) : null;
  }, "getDataCutoffDate");
  const actionTypes = Object.entries(data.actions_summary.action_types);
  if (actionTypes.length > 0) {
    const mostCommonAction = actionTypes.reduce((a, b) => a[1] > b[1] ? a : b);
    const totalActions2 = Number(data.actions_summary.total_actions);
    const percentage = (Number(mostCommonAction[1]) / totalActions2 * 100).toFixed(1);
    const top3Actions = actionTypes.sort((a, b) => b[1] - a[1]).slice(0, 3).map(([name, count]) => `${name} (${count})`);
    const recommendation = mostCommonAction[0] === "cloudflare_api_call" ? "High external API usage detected:\n\u2022 Monitor rate limits\n\u2022 Consider caching responses\n\u2022 Review API call frequency" : mostCommonAction[0] === "request_received" ? "Heavy inbound traffic:\n\u2022 Ensure worker scaling is configured properly\n\u2022 Monitor CPU usage\n\u2022 Consider rate limiting if needed" : "Review action distribution to optimize system performance";
    if (Number(percentage) > 80 || mostCommonAction[0] === "error") {
      insights.push({
        type: "action_patterns",
        title: `${mostCommonAction[0]} Dominates System Activity`,
        insight: `Out of ${totalActions2.toLocaleString()} total actions, ${mostCommonAction[0]} accounts for ${percentage}% (${Number(mostCommonAction[1]).toLocaleString()} occurrences).

Top 3 actions:
${top3Actions.join("\n")}

${recommendation}`,
        priority: "info",
        usefulness: mostCommonAction[0] === "error" ? "high" : "medium",
        ai_prompt: `${mostCommonAction[0]} actions dominate system activity at ${percentage}% (${Number(mostCommonAction[1]).toLocaleString()} occurrences out of ${totalActions2.toLocaleString()} total). Top actions: ${top3Actions.join(", ")}. Analyze:
1. Whether this action distribution is expected for the workload
2. Opportunities to optimize ${mostCommonAction[0]} operations
3. ${mostCommonAction[0] === "cloudflare_api_call" ? "Caching strategies to reduce API calls" : mostCommonAction[0] === "request_received" ? "Load balancing and scaling recommendations" : "Performance optimizations for dominant actions"}

Provide specific recommendations to optimize system efficiency.`
      });
    }
  }
  const failedActions = Number(data.actions_summary.status_breakdown.failed) || 0;
  const totalActions = Number(data.actions_summary.total_actions);
  const errorRate = totalActions > 0 ? failedActions / totalActions * 100 : 0;
  const errorAnalysisFix = wasRecentlyFixed("error_analysis");
  if (!errorAnalysisFix.fixed && errorRate > 10) {
    const failedByType = Object.entries(data.actions_summary.action_types).filter(([_, count]) => Number(count) > 0).sort((a, b) => b[1] - a[1]).slice(0, 3);
    insights.push({
      type: "error_analysis",
      title: `Critical: ${errorRate.toFixed(1)}% Action Failure Rate`,
      insight: `${failedActions.toLocaleString()} out of ${totalActions.toLocaleString()} actions failed. This is ${(errorRate / 10).toFixed(1)}x above the 10% threshold.

Immediate actions:
1) Check /health/analytics for error patterns
2) Review recent deployments (last 24h)
3) Verify Cloudflare API token permissions
4) Check D1 database connection health

Most active action types: ${failedByType.map(([name]) => name).join(", ")}.`,
      priority: "high",
      usefulness: "critical",
      // Critical because error rate is dangerously high
      ai_prompt: `Analyze the Cloudflare Worker error logs and identify the root cause of the ${errorRate.toFixed(1)}% action failure rate. ${failedActions} out of ${totalActions} actions are failing. Focus on these action types: ${failedByType.map(([name]) => name).join(", ")}. Check:
1. Recent code changes in the last 24 hours
2. API token permissions and expiration
3. D1 database connection issues
4. Cloudflare API rate limits or service issues

Provide specific fixes for each identified issue.`
    });
  } else if (!errorAnalysisFix.fixed && errorRate > 5) {
    insights.push({
      type: "error_analysis",
      title: `Elevated Error Rate: ${errorRate.toFixed(1)}%`,
      insight: `${failedActions} actions failed out of ${totalActions.toLocaleString()} total. While below critical threshold (10%), this is elevated.

Recommended actions:
1) Review error logs in /health/analytics
2) Check for intermittent API issues
3) Monitor trend over next hour`,
      priority: "medium",
      usefulness: "high",
      // High because errors are elevated and need attention
      ai_prompt: `Review the Cloudflare Worker logs and identify why ${failedActions} actions are failing (${errorRate.toFixed(1)}% error rate). This is elevated but not critical. Look for:
1. Intermittent failures or patterns
2. Specific endpoints or operations causing issues
3. Recent configuration changes

Suggest preventive measures to reduce the error rate below 5%.`
    });
  } else if (errorAnalysisFix.fixed && errorRate < 5) {
  }
  const failedTests = data.failed_tests;
  const healedTests = failedTests.filter((t) => t.healing_status === "success");
  const healingRate = failedTests.length > 0 ? healedTests.length / failedTests.length * 100 : 0;
  const selfHealingFix = wasRecentlyFixed("self_healing");
  if (!selfHealingFix.fixed && failedTests.length > 0) {
    const failedTestNames = failedTests.slice(0, 3).map((t) => t.test_name).join(", ");
    const healedTestNames = healedTests.slice(0, 2).map((t) => t.test_name).join(", ");
    const stillFailingTests = failedTests.filter((t) => t.healing_status !== "success").slice(0, 2).map((t) => t.test_name).join(", ");
    if (healingRate === 0) {
      insights.push({
        type: "self_healing",
        title: `AI Self-Healing: 0% Success Rate`,
        insight: `None of ${failedTests.length} failed tests were automatically healed.

Failed tests: ${failedTestNames}

Action required:
1) Review AI healing logs in /health/self-healing
2) Check if Cloudflare AI binding is configured
3) Verify API token has required permissions for healing actions
4) Consider manual intervention for: ${failedTestNames}`,
        priority: "high",
        usefulness: "critical",
        // Critical because healing system is completely broken
        ai_prompt: `The AI self-healing system failed to heal any of the ${failedTests.length} failed tests: ${failedTestNames}. Investigate why the healing attempts failed:
1. Review the healing attempt logs in the self_healing_attempts table
2. Check if the Cloudflare AI binding is properly configured
3. Verify the API token has sufficient permissions
4. Analyze the error messages from failed healing attempts

Provide specific fixes to improve the healing success rate and manual steps to resolve: ${failedTestNames}.`
      });
    } else if (healingRate < 50) {
      insights.push({
        type: "self_healing",
        title: `AI Self-Healing: ${healingRate.toFixed(1)}% Success (Below Target)`,
        insight: `${healedTests.length} of ${failedTests.length} failed tests were healed.

Successfully healed: ${healedTestNames || "none"}
Still failing: ${stillFailingTests}

Recommendations:
1) Review healing attempt logs
2) Check if failures are due to permissions or configuration issues
3) Consider updating healing strategies`,
        priority: "medium",
        usefulness: "high",
        // High because healing needs improvement
        ai_prompt: `AI self-healing is at ${healingRate.toFixed(1)}% success rate (${healedTests.length}/${failedTests.length}). Successfully healed: ${healedTestNames}. Still failing: ${stillFailingTests}. Analyze:
1. Why some tests heal successfully while others don't
2. Common patterns in failed healing attempts
3. Permission or configuration issues preventing healing

Provide strategies to improve healing success rate above 50% and specific fixes for: ${stillFailingTests}.`
      });
    }
  } else if (selfHealingFix.fixed && healingRate > 50) {
  }
  const responseTimes = data.session_patterns.response_times;
  if (responseTimes.length > 0) {
    const sortedTimes = [...responseTimes].sort((a, b) => a - b);
    const avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
    const p50 = sortedTimes[Math.floor(sortedTimes.length * 0.5)];
    const p95 = sortedTimes[Math.floor(sortedTimes.length * 0.95)];
    const p99 = sortedTimes[Math.floor(sortedTimes.length * 0.99)];
    const slowRequests = sortedTimes.filter((t) => t > 5e3).length;
    if (avgResponseTime > 5e3) {
      insights.push({
        type: "performance",
        title: `Performance Issue: ${avgResponseTime.toFixed(0)}ms Average`,
        insight: `Response times are critically slow. ${slowRequests} requests (${(slowRequests / sortedTimes.length * 100).toFixed(1)}%) exceeded 5s.

Immediate actions:
1) Check D1 query performance
2) Review Cloudflare API response times
3) Identify slow endpoints in /health/analytics
4) Consider adding indexes to D1 tables
5) Enable query caching where possible`,
        priority: "high",
        usefulness: "critical",
        // Critical because performance is severely degraded
        chart_data: {
          type: "percentile",
          values: { avg: avgResponseTime, p50, p95, p99 },
          threshold: 5e3,
          unit: "ms"
        },
        ai_prompt: `Response times are critically slow with ${avgResponseTime.toFixed(0)}ms average (P95: ${p95.toFixed(0)}ms, P99: ${p99.toFixed(0)}ms). ${slowRequests} requests exceeded 5 seconds. Analyze the worker code and:
1. Identify slow D1 queries and suggest index optimizations
2. Review Cloudflare API calls for bottlenecks
3. Find endpoints with highest response times
4. Suggest caching strategies for frequently accessed data
5. Recommend code optimizations to reduce CPU time

Provide specific code changes to improve performance.`
      });
    } else if (avgResponseTime > 2e3) {
      insights.push({
        type: "performance",
        title: `Moderate Performance: ${avgResponseTime.toFixed(0)}ms Average`,
        insight: `Response times are acceptable but could be improved.

Recommendations:
1) Profile slow queries
2) Optimize D1 indexes
3) Review worker CPU time
4) Consider edge caching for static responses`,
        priority: "medium",
        usefulness: "medium",
        // Medium because performance is OK but could be better
        chart_data: {
          type: "percentile",
          values: { avg: avgResponseTime, p50, p95, p99 },
          threshold: 2e3,
          unit: "ms"
        },
        ai_prompt: `Response times average ${avgResponseTime.toFixed(0)}ms (P95: ${p95.toFixed(0)}ms). While acceptable, there's room for improvement. Review the codebase and:
1. Identify queries that could benefit from indexes
2. Find opportunities for caching
3. Analyze CPU-intensive operations
4. Suggest optimizations to bring average response time under 1 second

Provide specific recommendations with code examples.`
      });
    }
  }
  const failedCategories = failedTests.reduce((acc, test) => {
    if (!acc[test.category]) acc[test.category] = [];
    acc[test.category].push(test);
    return acc;
  }, {});
  const categoryEntries = Object.entries(failedCategories);
  if (categoryEntries.length > 0 && db) {
    const worstCategory = categoryEntries.reduce((a, b) => a[1].length > b[1].length ? a : b);
    const categoryName = worstCategory[0];
    const testsInCategory = worstCategory[1];
    const totalFailed = failedTests.length;
    const percentage = (testsInCategory.length / totalFailed * 100).toFixed(1);
    const allCategories = categoryEntries.sort((a, b) => b[1].length - a[1].length).map(([cat, tests]) => `${cat} (${tests.length})`).join(", ");
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);
    const cutoffDateStr = cutoffDate.toISOString();
    const detailedFailures = await db.selectFrom("health_test_results").innerJoin("health_tests", "health_tests.id", "health_test_results.health_test_id").select([
      "health_tests.name",
      "health_tests.endpoint_path",
      "health_tests.http_method",
      "health_test_results.status",
      "health_test_results.status_text",
      "health_test_results.error_message",
      "health_test_results.run_at"
    ]).where("health_tests.category", "=", categoryName).where("health_test_results.outcome", "=", "fail").where("health_test_results.run_at", ">=", cutoffDateStr).orderBy("health_test_results.run_at", "asc").execute();
    const failuresByEndpoint = detailedFailures.reduce((acc, failure) => {
      const key = `${failure.http_method} ${failure.endpoint_path}`;
      if (!acc[key]) {
        acc[key] = {
          method: failure.http_method,
          endpoint: failure.endpoint_path,
          name: failure.name,
          first_seen: failure.run_at,
          last_seen: failure.run_at,
          occurrences: 0,
          status_codes: {},
          errors: /* @__PURE__ */ new Set()
        };
      }
      acc[key].occurrences++;
      acc[key].last_seen = failure.run_at;
      acc[key].status_codes[failure.status] = (acc[key].status_codes[failure.status] || 0) + 1;
      if (failure.error_message) {
        acc[key].errors.add(failure.error_message);
      } else if (failure.status_text) {
        acc[key].errors.add(failure.status_text);
      }
      return acc;
    }, {});
    const topFailures = Object.values(failuresByEndpoint).sort((a, b) => b.occurrences - a.occurrences).slice(0, 10);
    const failureDetails = topFailures.length > 0 ? topFailures.map((f) => {
      const firstSeen = new Date(f.first_seen).toLocaleDateString();
      const lastSeen = new Date(f.last_seen).toLocaleDateString();
      const mostCommonStatus = Object.entries(f.status_codes).sort((a, b) => b[1] - a[1])[0];
      const statusCode = mostCommonStatus ? mostCommonStatus[0] : "Unknown";
      const errorSummary = Array.from(f.errors).slice(0, 2).join("; ");
      return `\u2022 ${f.method} ${f.endpoint}
  First: ${firstSeen} | Last: ${lastSeen} | Count: ${f.occurrences}
  Status: ${statusCode} | Error: ${errorSummary || "Unknown error"}`;
    }).join("\n\n") : "No detailed failure data available for this period.";
    const rootCauseAnalysis = categoryName === "api" ? "Common API failure causes:\n\u2022 Invalid or expired API tokens\n\u2022 Insufficient permissions\n\u2022 Rate limit exceeded\n\u2022 Cloudflare API service issues" : categoryName === "database" ? "Common database failure causes:\n\u2022 Connection timeout\n\u2022 Query syntax errors\n\u2022 Missing indexes causing slow queries\n\u2022 Schema migration issues" : categoryName === "auth" ? "Common auth failure causes:\n\u2022 Token expiration\n\u2022 Invalid permission scopes\n\u2022 Missing required headers\n\u2022 Account access issues" : `Review ${categoryName} system components and recent changes`;
    insights.push({
      type: "failure_analysis",
      title: `${categoryName} Failures: ${testsInCategory.length} Tests (${percentage}%)`,
      insight: `${testsInCategory.length} of ${totalFailed} failed tests are in ${categoryName} category.

Category breakdown: ${allCategories}

\u{1F4CA} Detailed Failure Patterns (Last ${days} Days):

${failureDetails}

${rootCauseAnalysis}`,
      priority: "high",
      usefulness: "critical",
      ai_prompt: `Analyze and fix ${categoryName} category failures. ${testsInCategory.length} tests failing (${percentage}% of all failures).

Detailed failure data:
${topFailures.map((f) => `
${f.method} ${f.endpoint}:
- Occurrences: ${f.occurrences}
- First seen: ${new Date(f.first_seen).toISOString()}
- Last seen: ${new Date(f.last_seen).toISOString()}
- Status codes: ${JSON.stringify(f.status_codes)}
- Errors: ${Array.from(f.errors).join(", ")}`).join("\n")}

Investigate:
1. Root cause for each failing endpoint
2. ${categoryName === "api" ? "API token validity, permissions, and rate limits" : categoryName === "database" ? "Database connection, query performance, and schema" : categoryName === "auth" ? "Authentication configuration and token management" : `${categoryName} system configuration`}
3. Pattern analysis across failures
4. Recent code or config changes

Provide:
- Specific fix for each endpoint
- Code changes needed
- Configuration updates
- Preventive measures`
    });
  }
  if (db) {
    try {
      const now = (/* @__PURE__ */ new Date()).toISOString();
      if (errorAnalysisFix.fixed && errorRate < 5) {
        console.log(`\u2705 Auto-detection: error_analysis issue resolved (error rate: ${errorRate.toFixed(1)}%)`);
      }
      if (selfHealingFix.fixed && healingRate > 50) {
        console.log(`\u2705 Auto-detection: self_healing issue resolved (healing rate: ${healingRate.toFixed(1)}%)`);
      }
      if (!errorAnalysisFix.fixed && errorRate < 5 && failedActions === 0) {
        await db.insertInto("insight_fixes").values({
          id: generateUUID(),
          insight_type: "error_analysis",
          insight_category: null,
          fix_description: `Auto-resolved: Error rate dropped to ${errorRate.toFixed(2)}% with zero failed actions`,
          fixed_at: now,
          fixed_by: "auto",
          metadata: JSON.stringify({ error_rate: errorRate, failed_actions: failedActions }),
          created_at: now,
          updated_at: now
        }).execute();
        console.log(`\u{1F916} Auto-marked error_analysis as fixed (error rate: ${errorRate.toFixed(1)}%)`);
      }
      if (!selfHealingFix.fixed && healingRate > 80 && failedTests.length === 0) {
        await db.insertInto("insight_fixes").values({
          id: generateUUID(),
          insight_type: "self_healing",
          insight_category: null,
          fix_description: `Auto-resolved: Healing rate improved to ${healingRate.toFixed(1)}% with no failed tests`,
          fixed_at: now,
          fixed_by: "auto",
          metadata: JSON.stringify({ healing_rate: healingRate, failed_tests_count: failedTests.length }),
          created_at: now,
          updated_at: now
        }).execute();
        console.log(`\u{1F916} Auto-marked self_healing as fixed (healing rate: ${healingRate.toFixed(1)}%)`);
      }
    } catch (autoDetectError) {
      console.error("Auto-detection error (non-fatal):", autoDetectError);
    }
  }
  return insights;
}
var healthRoutes, buildInternalFetch, health_default2;
var init_health3 = __esm({
  "src/routes/health.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    init_types();
    init_health_check();
    init_openapi_generator();
    init_client();
    healthRoutes = new Hono2();
    healthRoutes.post("/check", async (c) => {
      try {
        const body = await c.req.json().catch(() => ({}));
        const { auto_heal = true } = body;
        const baseUrl = new URL(c.req.url).origin;
        const authToken = c.env.CLIENT_AUTH_TOKEN;
        const internalFetch = await buildInternalFetch(c, baseUrl);
        const loggingService = c.get("loggingService");
        const healthService = new HealthCheckService(c.env, baseUrl, authToken, internalFetch, loggingService);
        const result = await healthService.runHealthCheck();
        try {
          await healthService.saveHealthCheck(result);
        } catch (saveError) {
          console.warn("Failed to save to legacy health_checks table:", saveError.message);
        }
        let healingResults = null;
        if (auto_heal && result.unhealthy_endpoints > 0) {
          try {
            const accountId = c.env.CLOUDFLARE_ACCOUNT_ID || "";
            const { SelfHealingService: SelfHealingService2 } = await Promise.resolve().then(() => (init_self_healing(), self_healing_exports));
            const healingService = new SelfHealingService2(c.env, accountId);
            const failedResults = await healthService.getTestResultsWithDefinitions(result.check_group_id);
            const failedTests = failedResults.filter((r) => r.outcome === "fail").map((r) => ({
              test_result_id: r.id,
              test_id: r.health_test_id,
              test_name: r.health_test?.name || "Unknown",
              endpoint_path: r.health_test?.endpoint_path || "",
              http_method: r.health_test?.http_method || "GET",
              status: r.status,
              status_text: r.status_text,
              error_message: r.error_message,
              response_body: r.response_body,
              health_check_group_id: result.check_group_id
            }));
            if (failedTests.length > 0) {
              healingResults = await healingService.analyzeAndHeal(result.check_group_id, failedTests);
            }
          } catch (healError) {
            console.error("Auto-healing failed:", healError);
          }
        }
        return c.json({
          success: true,
          result,
          healing: healingResults ? {
            attempted: true,
            results: healingResults
          } : null
        });
      } catch (error) {
        console.error("Health check failed:", error);
        return c.json({
          success: false,
          error: error.message,
          details: error.stack
        }, 500);
      }
    });
    healthRoutes.get("/latest", async (c) => {
      try {
        const baseUrl = new URL(c.req.url).origin;
        const authToken = c.env.CLIENT_AUTH_TOKEN;
        const accountId = c.env.CLOUDFLARE_ACCOUNT_ID || "";
        const loggingService = c.get("loggingService");
        const healthService = new HealthCheckService(c.env, baseUrl, authToken, void 0, loggingService);
        const result = await healthService.getLatestHealthCheck();
        if (!result) {
          return c.json({
            success: false,
            error: "No health check data available"
          }, 404);
        }
        const { SelfHealingService: SelfHealingService2 } = await Promise.resolve().then(() => (init_self_healing(), self_healing_exports));
        const healingService = new SelfHealingService2(c.env, accountId);
        const healingAttempts = await healingService.getHealingAttempts(result.check_group_id);
        return c.json({
          success: true,
          result: {
            session: {
              sessionUuid: result.check_group_id,
              startedAt: result.checked_at,
              completedAt: result.checked_at,
              status: result.overall_status,
              totalTests: result.total_endpoints,
              passedTests: result.healthy_endpoints,
              failedTests: result.unhealthy_endpoints,
              avgResponseTime: result.avg_response_time
            },
            tests: result.results.map((r) => ({
              testKey: r.endpoint,
              name: r.endpoint,
              status: r.outcome,
              runAt: result.checked_at,
              responseTimeMs: r.response_time_ms,
              statusCode: r.status,
              statusText: r.statusText,
              category: r.category,
              scope: "api"
            })),
            selfHealing: healingAttempts.length > 0 ? {
              results: healingAttempts.map((a) => ({
                testKey: a.health_test_id,
                status: a.status,
                aiAnalysis: a.ai_analysis,
                aiRecommendation: a.ai_recommendation,
                healingAction: a.healing_action,
                actionDetails: a.action_details,
                steps: a.steps || []
              }))
            } : null
          }
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    healthRoutes.get("/history", async (c) => {
      try {
        const limit = parseInt(c.req.query("limit") || "10");
        const baseUrl = new URL(c.req.url).origin;
        const authToken = c.env.CLIENT_AUTH_TOKEN;
        const loggingService = c.get("loggingService");
        const healthService = new HealthCheckService(c.env, baseUrl, authToken, void 0, loggingService);
        const results = [];
        return c.json({
          success: true,
          result: results,
          count: results.length
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    buildInternalFetch = /* @__PURE__ */ __name(async (ctx, baseUrl) => {
      const { default: mainApp } = await Promise.resolve().then(() => (init_src(), src_exports));
      return async (request) => {
        const url = new URL(request.url, baseUrl);
        const absoluteRequest = new Request(url.toString(), request);
        return await mainApp.fetch(absoluteRequest, ctx.env, ctx.executionCtx);
      };
    }, "buildInternalFetch");
    healthRoutes.post("/tests/run", async (c) => {
      try {
        let body;
        try {
          body = await c.req.json();
        } catch {
          body = {};
        }
        const { triggerSource = "manual" } = body;
        const baseUrl = new URL(c.req.url).origin;
        const authToken = c.env.CLIENT_AUTH_TOKEN;
        const internalFetch = await buildInternalFetch(c, baseUrl);
        const loggingService = c.get("loggingService");
        const healthService = new HealthCheckService(c.env, baseUrl, authToken, internalFetch, loggingService);
        const result = await healthService.runHealthCheck();
        try {
          await healthService.saveHealthCheck(result);
        } catch (saveError) {
          console.warn("Failed to save to legacy health_checks table:", saveError.message);
        }
        let healingResults = null;
        if (result.unhealthy_endpoints > 0) {
          try {
            const accountId = c.env.CLOUDFLARE_ACCOUNT_ID || "";
            const { SelfHealingService: SelfHealingService2 } = await Promise.resolve().then(() => (init_self_healing(), self_healing_exports));
            const healingService = new SelfHealingService2(c.env, accountId);
            const failedResults = await healthService.getTestResultsWithDefinitions(result.check_group_id);
            const failedTests = failedResults.filter((r) => r.outcome === "fail").map((r) => ({
              test_result_id: r.id,
              test_id: r.health_test_id,
              test_name: r.health_test?.name || "Unknown",
              endpoint_path: r.health_test?.endpoint_path || "",
              http_method: r.health_test?.http_method || "GET",
              status: r.status,
              status_text: r.status_text,
              error_message: r.error_message,
              response_body: r.response_body,
              health_check_group_id: result.check_group_id
            }));
            if (failedTests.length > 0) {
              healingResults = await healingService.analyzeAndHeal(result.check_group_id, failedTests);
            }
          } catch (healError) {
            console.error("Self-healing failed:", healError);
          }
        }
        return c.json({
          success: true,
          result: {
            ...result,
            healing_results: healingResults,
            trigger_source: triggerSource
          }
        });
      } catch (error) {
        console.error("Error in /tests/run:", error);
        return c.json({
          success: false,
          error: error.message,
          details: error.stack
        }, 500);
      }
    });
    healthRoutes.get("/unit-tests", async (c) => {
      return c.json({
        success: false,
        error: "Unit tests endpoint deprecated - use /health/tests instead",
        message: "Unit tests have been consolidated into the health check system"
      }, 410);
    });
    healthRoutes.get("/tests/session/latest", async (c) => {
      return c.json({
        success: false,
        error: "Unit tests endpoint deprecated - use /health/tests/results instead",
        message: "Unit tests have been consolidated into the health check system"
      }, 410);
    });
    healthRoutes.get("/tests/session/:sessionUuid", async (c) => {
      return c.json({
        success: false,
        error: "Unit tests endpoint deprecated - use /health/tests/results instead",
        message: "Unit tests have been consolidated into the health check system"
      }, 410);
    });
    healthRoutes.get("/tests", async (c) => {
      try {
        const baseUrl = new URL(c.req.url).origin;
        const authToken = c.env.CLIENT_AUTH_TOKEN;
        const includeInactive = c.req.query("include_inactive") === "true";
        const loggingService = c.get("loggingService");
        const healthService = new HealthCheckService(c.env, baseUrl, authToken, void 0, loggingService);
        const tests = await healthService.getRegisteredTests(includeInactive);
        const formattedTests = tests.map((test) => ({
          testKey: test.test_key || test.id,
          name: test.name,
          scope: test.scope,
          category: test.category,
          description: test.description,
          executorKey: test.executor_key,
          endpointPath: test.endpoint_path,
          httpMethod: test.http_method,
          enabled: test.enabled === 1,
          isActive: test.is_active === 1,
          latestResult: null
          // Will be populated by frontend if needed
        }));
        return c.json({
          success: true,
          result: formattedTests,
          count: formattedTests.length
        });
      } catch (error) {
        console.error("Error fetching health tests:", error);
        return c.json({
          success: false,
          error: error.message,
          details: error.stack
        }, 500);
      }
    });
    healthRoutes.get("/results", async (c) => {
      try {
        const runGroupId = c.req.query("run_group_id");
        const limit = parseInt(c.req.query("limit") || "100");
        const baseUrl = new URL(c.req.url).origin;
        const authToken = c.env.CLIENT_AUTH_TOKEN;
        const loggingService = c.get("loggingService");
        const healthService = new HealthCheckService(c.env, baseUrl, authToken, void 0, loggingService);
        const results = await healthService.getTestResultsWithDefinitions(
          runGroupId || void 0,
          limit
        );
        return c.json({
          success: true,
          result: results,
          count: results.length
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    healthRoutes.get("/tests-with-results", async (c) => {
      try {
        const baseUrl = new URL(c.req.url).origin;
        const authToken = c.env.CLIENT_AUTH_TOKEN;
        const loggingService = c.get("loggingService");
        const healthService = new HealthCheckService(c.env, baseUrl, authToken, void 0, loggingService);
        const testsWithResults = await healthService.getTestsWithLatestResults();
        return c.json({
          success: true,
          result: testsWithResults,
          count: testsWithResults.length
        });
      } catch (error) {
        console.error("Error in /tests-with-results:", error);
        return c.json({
          success: false,
          error: error.message,
          details: error.stack
        }, 500);
      }
    });
    healthRoutes.post("/db/tokens", async (c) => {
      try {
        const baseUrl = new URL(c.req.url).origin;
        const authToken = c.env.CLIENT_AUTH_TOKEN;
        const loggingService = c.get("loggingService");
        const healthService = new HealthCheckService(c.env, baseUrl, authToken, void 0, loggingService);
        await healthService.syncTokensFromApiResponse(null);
        return c.json({
          success: true,
          message: "Token table sync completed successfully"
        });
      } catch (error) {
        console.error("Token table sync failed:", error);
        return c.json({
          success: false,
          error: error.message,
          details: error.stack
        }, 500);
      }
    });
    healthRoutes.post("/db/permissions", async (c) => {
      try {
        const baseUrl = new URL(c.req.url).origin;
        const authToken = c.env.CLIENT_AUTH_TOKEN;
        const loggingService = c.get("loggingService");
        const healthService = new HealthCheckService(c.env, baseUrl, authToken, void 0, loggingService);
        const result = await healthService.syncPermissionsMap();
        if (result.success) {
          return c.json({
            success: true,
            message: result.message,
            permissionsCount: result.permissionsCount
          });
        } else {
          return c.json({
            success: false,
            error: result.message,
            permissionsCount: result.permissionsCount
          }, 500);
        }
      } catch (error) {
        console.error("API permissions map sync failed:", error);
        return c.json({
          success: false,
          error: error.message,
          details: error.stack
        }, 500);
      }
    });
    healthRoutes.get("/sessions", async (c) => {
      try {
        const limit = parseInt(c.req.query("limit") || "50");
        const offset = parseInt(c.req.query("offset") || "0");
        const requestType = c.req.query("request_type");
        const db = initDb(c.env);
        let query = db.selectFrom("sessions").selectAll().orderBy("started_at", "desc").limit(limit).offset(offset);
        if (requestType) {
          query = query.where("request_type", "=", requestType);
        }
        const sessions = await query.execute();
        return c.json({
          success: true,
          result: sessions,
          count: sessions.length,
          limit,
          offset
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    healthRoutes.get("/sessions/:sessionId/actions", async (c) => {
      try {
        const sessionId = c.req.param("sessionId");
        const limit = parseInt(c.req.query("limit") || "100");
        const offset = parseInt(c.req.query("offset") || "0");
        const db = initDb(c.env);
        const actions = await db.selectFrom("actions_log").selectAll().where("session_id", "=", sessionId).orderBy("sequence_number", "asc").limit(limit).offset(offset).execute();
        return c.json({
          success: true,
          result: actions,
          session_id: sessionId,
          count: actions.length,
          limit,
          offset
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    healthRoutes.get("/actions", async (c) => {
      try {
        const limit = parseInt(c.req.query("limit") || "100");
        const offset = parseInt(c.req.query("offset") || "0");
        const actionType = c.req.query("action_type");
        const sessionId = c.req.query("session_id");
        const db = initDb(c.env);
        let query = db.selectFrom("actions_log").innerJoin("sessions", "sessions.session_id", "actions_log.session_id").select([
          "actions_log.id",
          "actions_log.session_id",
          "actions_log.action_type",
          "actions_log.action_name",
          "actions_log.timestamp",
          "actions_log.duration_ms",
          "actions_log.status",
          "actions_log.input_data",
          "actions_log.output_data",
          "actions_log.error_message",
          "actions_log.sequence_number",
          "sessions.request_type",
          "sessions.request_path",
          "sessions.account_id",
          "sessions.user_id"
        ]).orderBy("actions_log.timestamp", "desc").limit(limit).offset(offset);
        if (actionType) {
          query = query.where("actions_log.action_type", "=", actionType);
        }
        if (sessionId) {
          query = query.where("actions_log.session_id", "=", sessionId);
        }
        const actions = await query.execute();
        return c.json({
          success: true,
          result: actions,
          count: actions.length,
          limit,
          offset
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    healthRoutes.get("/sessions/stats", async (c) => {
      try {
        const db = initDb(c.env);
        const requestTypeStats = await db.selectFrom("sessions").select(["request_type"]).select((eb) => eb.fn.count("request_type").as("count")).groupBy("request_type").execute();
        const errorSessions = await db.selectFrom("sessions").select(["session_id", "request_type", "error_message", "started_at"]).where("error_message", "is not", null).orderBy("started_at", "desc").limit(10).execute();
        const avgResponseTime = await db.selectFrom("sessions").select((eb) => eb.fn.avg("duration_ms").as("avg_duration")).where("duration_ms", "is not", null).executeTakeFirst();
        return c.json({
          success: true,
          result: {
            request_type_distribution: requestTypeStats,
            recent_errors: errorSessions,
            average_response_time_ms: avgResponseTime?.avg_duration || null
          }
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    healthRoutes.get("/stats", async (c) => {
      try {
        const db = initDb(c.env);
        const days = parseInt(c.req.query("days") || "30");
        const cutoffDate = /* @__PURE__ */ new Date();
        cutoffDate.setDate(cutoffDate.getDate() - days);
        const cutoffDateStr = cutoffDate.toISOString();
        const sessionStats = await db.selectFrom("sessions").select([
          (eb) => eb.fn.count("id").as("total_sessions"),
          (eb) => eb.fn.avg("duration_ms").as("avg_response_time"),
          (eb) => eb.fn.min("started_at").as("earliest_session"),
          (eb) => eb.fn.max("started_at").as("latest_session")
        ]).where("started_at", ">=", cutoffDateStr).executeTakeFirst();
        const requestTypeStats = await db.selectFrom("sessions").select(["request_type"]).select((eb) => eb.fn.count("request_type").as("count")).where("started_at", ">=", cutoffDateStr).groupBy("request_type").execute();
        const errorStats = await db.selectFrom("sessions").select([
          (eb) => eb.fn.count("id").as("total_sessions"),
          (eb) => eb.fn.countAll().as("error_sessions")
        ]).where("started_at", ">=", cutoffDateStr).where("error_message", "is not", null).executeTakeFirst();
        const totalSessionsForError = await db.selectFrom("sessions").select((eb) => eb.fn.count("id").as("total")).where("started_at", ">=", cutoffDateStr).executeTakeFirst();
        const errorStatsFixed = {
          total_sessions: totalSessionsForError?.total || 0,
          error_sessions: errorStats?.error_sessions || 0
        };
        const totalActions = await db.selectFrom("actions_log").innerJoin("sessions", "sessions.session_id", "actions_log.session_id").select([
          (eb) => eb.fn.count("actions_log.id").as("total_actions"),
          (eb) => eb.fn.avg("actions_log.duration_ms").as("avg_action_time")
        ]).where("sessions.started_at", ">=", cutoffDateStr).executeTakeFirst();
        const failedActions = await db.selectFrom("actions_log").innerJoin("sessions", "sessions.session_id", "actions_log.session_id").select((eb) => eb.fn.count("actions_log.id").as("failed")).where("sessions.started_at", ">=", cutoffDateStr).where("actions_log.status", "=", "failed").executeTakeFirst();
        const actionStats = {
          total_actions: totalActions?.total_actions || 0,
          failed_actions: failedActions?.failed || 0,
          avg_action_time: totalActions?.avg_action_time || 0
        };
        const healthStats = await db.selectFrom("health_test_results").select([
          (eb) => eb.fn.count("id").as("total_tests"),
          (eb) => eb.fn.sum(
            eb.case().when("outcome", "=", "fail").then(1).else(0).end()
          ).as("failed_tests"),
          (eb) => eb.fn.sum(
            eb.case().when("outcome", "=", "pass").then(1).else(0).end()
          ).as("passed_tests"),
          (eb) => eb.fn.avg("response_time_ms").as("avg_response_time")
        ]).where("run_at", ">=", cutoffDateStr).executeTakeFirst();
        const healingStats = await db.selectFrom("self_healing_attempts").select([
          (eb) => eb.fn.count("id").as("total_attempts"),
          (eb) => eb.fn.sum(
            eb.case().when("status", "=", "success").then(1).else(0).end()
          ).as("successful_healings"),
          (eb) => eb.fn.sum(
            eb.case().when("status", "=", "failed").then(1).else(0).end()
          ).as("failed_healings")
        ]).where("created_at", ">=", cutoffDateStr).executeTakeFirst();
        const tokenStats = await db.selectFrom("manage_tokens").select([
          (eb) => eb.fn.count("id").as("total_tokens"),
          (eb) => eb.fn.sum(
            eb.case().when("status", "=", "active").then(1).else(0).end()
          ).as("active_tokens"),
          (eb) => eb.fn.sum(
            eb.case().when("status", "=", "inactive").then(1).else(0).end()
          ).as("inactive_tokens"),
          (eb) => eb.fn.sum(
            eb.case().when("status", "=", "deleted").then(1).else(0).end()
          ).as("deleted_tokens")
        ]).executeTakeFirst();
        const permissionStats = await db.selectFrom("api_permissions_map").select([
          (eb) => eb.fn.count("id").as("total_permissions")
        ]).executeTakeFirst();
        return c.json({
          success: true,
          result: {
            period_days: days,
            sessions: sessionStats || { total_sessions: 0, avg_response_time: 0 },
            request_types: requestTypeStats || [],
            error_rate: errorStatsFixed ? {
              total_sessions: Number(errorStatsFixed.total_sessions) || 0,
              error_sessions: Number(errorStatsFixed.error_sessions) || 0,
              error_rate_percent: Number(errorStatsFixed.total_sessions) > 0 ? (Number(errorStatsFixed.error_sessions) / Number(errorStatsFixed.total_sessions) * 100).toFixed(2) : "0"
            } : { total_sessions: 0, error_sessions: 0, error_rate_percent: "0" },
            actions: actionStats || { total_actions: 0, failed_actions: 0, avg_action_time: 0 },
            health_checks: healthStats || { total_tests: 0, failed_tests: 0, passed_tests: 0, avg_response_time: 0 },
            self_healing: healingStats ? {
              total_attempts: Number(healingStats.total_attempts) || 0,
              successful_healings: Number(healingStats.successful_healings) || 0,
              failed_healings: Number(healingStats.failed_healings) || 0,
              success_rate_percent: Number(healingStats.total_attempts) > 0 ? (Number(healingStats.successful_healings) / Number(healingStats.total_attempts) * 100).toFixed(2) : "0"
            } : { total_attempts: 0, successful_healings: 0, failed_healings: 0, success_rate_percent: "0" },
            tokens: tokenStats ? {
              total_tokens: Number(tokenStats.total_tokens) || 0,
              active_tokens: Number(tokenStats.active_tokens) || 0,
              inactive_tokens: Number(tokenStats.inactive_tokens) || 0,
              deleted_tokens: Number(tokenStats.deleted_tokens) || 0
            } : { total_tokens: 0, active_tokens: 0, inactive_tokens: 0, deleted_tokens: 0 },
            permissions: permissionStats || { total_permissions: 0 }
          }
        });
      } catch (error) {
        console.error("Error in /health/stats:", error);
        return c.json({ success: false, error: error.message, stack: error.stack }, 500);
      }
    });
    healthRoutes.get("/insights", async (c) => {
      try {
        const db = initDb(c.env);
        const days = parseInt(c.req.query("days") || "30");
        const cutoffDate = /* @__PURE__ */ new Date();
        cutoffDate.setDate(cutoffDate.getDate() - days);
        const cutoffDateStr = cutoffDate.toISOString();
        const recentActions = await db.selectFrom("actions_log").innerJoin("sessions", "sessions.session_id", "actions_log.session_id").select([
          "actions_log.action_type",
          "actions_log.action_name",
          "actions_log.status",
          "actions_log.duration_ms",
          "sessions.request_type",
          "sessions.request_method",
          "sessions.request_path",
          "actions_log.timestamp"
        ]).where("actions_log.timestamp", ">=", cutoffDateStr).orderBy("actions_log.timestamp", "desc").limit(500).execute();
        const failedTestsWithHealing = await db.selectFrom("health_test_results").innerJoin("health_tests", "health_tests.id", "health_test_results.health_test_id").leftJoin("self_healing_attempts", "self_healing_attempts.health_test_result_id", "health_test_results.id").select([
          "health_test_results.id",
          "health_test_results.status",
          "health_test_results.status_text",
          "health_test_results.outcome",
          "health_test_results.run_at",
          "health_tests.name",
          "health_tests.category",
          "health_tests.endpoint_path",
          "self_healing_attempts.status as healing_status",
          "self_healing_attempts.ai_analysis",
          "self_healing_attempts.effectiveness_analysis"
        ]).where("health_test_results.outcome", "=", "fail").where("health_test_results.run_at", ">=", cutoffDateStr).orderBy("health_test_results.run_at", "desc").limit(100).execute();
        const sessionPatterns = await db.selectFrom("sessions").select([
          "request_type",
          "request_method",
          "status_code",
          "duration_ms",
          "started_at"
        ]).where("started_at", ">=", cutoffDateStr).orderBy("started_at", "desc").limit(200).execute();
        const insightsData = {
          period_days: days,
          actions_summary: {
            total_actions: recentActions.length,
            action_types: recentActions.reduce((acc, action) => {
              acc[action.action_type] = (acc[action.action_type] || 0) + 1;
              return acc;
            }, {}),
            status_breakdown: recentActions.reduce((acc, action) => {
              acc[action.status] = (acc[action.status] || 0) + 1;
              return acc;
            }, {})
          },
          failed_tests: failedTestsWithHealing.map((test) => ({
            test_name: test.name,
            category: test.category,
            endpoint: test.endpoint_path,
            status: test.status,
            error: test.status_text,
            healing_attempted: !!test.healing_status,
            healing_status: test.healing_status,
            ai_insights: test.ai_analysis,
            effectiveness: test.effectiveness_analysis
          })),
          session_patterns: {
            request_types: sessionPatterns.reduce((acc, session) => {
              acc[session.request_type] = (acc[session.request_type] || 0) + 1;
              return acc;
            }, {}),
            response_times: sessionPatterns.filter((s) => s.duration_ms).map((s) => s.duration_ms),
            status_codes: sessionPatterns.reduce((acc, session) => {
              if (session.status_code) {
                acc[session.status_code] = (acc[session.status_code] || 0) + 1;
              }
              return acc;
            }, {})
          }
        };
        let aiInsights = [];
        try {
          aiInsights = await generateAiInsights(insightsData, db, days);
        } catch (insightError) {
          console.error("Error generating insights:", insightError);
          aiInsights = [{
            type: "system_info",
            title: "System Overview",
            insight: `Monitoring ${insightsData.actions_summary.total_actions} actions and ${insightsData.failed_tests.length} test results over the last ${days} days.`,
            priority: "info",
            ai_prompt: "Review system health and performance metrics."
          }];
        }
        return c.json({
          success: true,
          result: {
            data: insightsData,
            insights: aiInsights,
            generated_at: (/* @__PURE__ */ new Date()).toISOString()
          }
        });
      } catch (error) {
        console.error("Error in /health/insights:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    healthRoutes.post("/insights/mark-fixed", async (c) => {
      try {
        const body = await c.req.json();
        const { insight_type, insight_category, fix_description, fixed_by = "manual" } = body;
        if (!insight_type || !fix_description) {
          return c.json({
            success: false,
            error: "insight_type and fix_description are required"
          }, 400);
        }
        const db = initDb(c.env);
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const fixId = generateUUID();
        await db.insertInto("insight_fixes").values({
          id: fixId,
          insight_type,
          insight_category: insight_category || null,
          fix_description,
          fixed_at: now,
          fixed_by,
          metadata: null,
          created_at: now,
          updated_at: now
        }).execute();
        return c.json({
          success: true,
          result: {
            id: fixId,
            insight_type,
            insight_category,
            fix_description,
            fixed_at: now,
            fixed_by
          },
          message: `Insight '${insight_type}' marked as fixed. Future insights will filter out data before ${now}.`
        });
      } catch (error) {
        console.error("Error marking insight as fixed:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    healthRoutes.get("/insights/fixes", async (c) => {
      try {
        const db = initDb(c.env);
        const fixes = await db.selectFrom("insight_fixes").selectAll().orderBy("fixed_at", "desc").execute();
        return c.json({
          success: true,
          result: fixes,
          count: fixes.length
        });
      } catch (error) {
        console.error("Error fetching insight fixes:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    healthRoutes.delete("/insights/fixes/:fixId", async (c) => {
      try {
        const fixId = c.req.param("fixId");
        const db = initDb(c.env);
        await db.deleteFrom("insight_fixes").where("id", "=", fixId).execute();
        return c.json({
          success: true,
          message: `Insight fix ${fixId} deleted. The insight will now reappear if the issue persists.`
        });
      } catch (error) {
        console.error("Error deleting insight fix:", error);
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    __name(generateAiInsights, "generateAiInsights");
    healthRoutes.get("/status", async (c) => {
      return c.json({ status: "ok" });
    });
    healthRoutes.post("/heal", async (c) => {
      try {
        const body = await c.req.json();
        const { health_check_group_id, auto_heal = true } = body;
        if (!health_check_group_id) {
          return c.json({
            success: false,
            error: "health_check_group_id is required"
          }, 400);
        }
        const baseUrl = new URL(c.req.url).origin;
        const authToken = c.env.CLIENT_AUTH_TOKEN;
        const accountId = c.env.CLOUDFLARE_ACCOUNT_ID || "";
        const loggingService = c.get("loggingService");
        const healthService = new HealthCheckService(c.env, baseUrl, authToken, void 0, loggingService);
        const failedResults = await healthService.getTestResultsWithDefinitions(health_check_group_id);
        const failedTests = failedResults.filter((result) => result.outcome === "fail").map((result) => ({
          test_result_id: result.id,
          test_id: result.health_test_id,
          test_name: result.health_test?.name || "Unknown",
          endpoint_path: result.health_test?.endpoint_path || "",
          http_method: result.health_test?.http_method || "GET",
          status: result.status,
          status_text: result.status_text,
          error_message: result.error_message,
          response_body: result.response_body,
          health_check_group_id
        }));
        if (failedTests.length === 0) {
          return c.json({
            success: true,
            message: "No failed tests to heal",
            result: []
          });
        }
        const { SelfHealingService: SelfHealingService2 } = await Promise.resolve().then(() => (init_self_healing(), self_healing_exports));
        const healingService = new SelfHealingService2(c.env, accountId);
        const healingResults = await healingService.analyzeAndHeal(health_check_group_id, failedTests);
        return c.json({
          success: true,
          result: healingResults,
          message: `Analyzed ${failedTests.length} failed test(s) and attempted healing`
        });
      } catch (error) {
        console.error("Self-healing failed:", error);
        return c.json({
          success: false,
          error: error.message,
          details: error.stack
        }, 500);
      }
    });
    healthRoutes.get("/heal/:healthCheckGroupId", async (c) => {
      try {
        const healthCheckGroupId = c.req.param("healthCheckGroupId");
        const accountId = c.env.CLOUDFLARE_ACCOUNT_ID || "";
        const { SelfHealingService: SelfHealingService2 } = await Promise.resolve().then(() => (init_self_healing(), self_healing_exports));
        const healingService = new SelfHealingService2(c.env, accountId);
        const attempts = await healingService.getHealingAttempts(healthCheckGroupId);
        return c.json({
          success: true,
          result: attempts,
          count: attempts.length
        });
      } catch (error) {
        return c.json({
          success: false,
          error: error.message
        }, 500);
      }
    });
    healthRoutes.get("/heal/:healthCheckGroupId/steps/:attemptId", async (c) => {
      try {
        const attemptId = c.req.param("attemptId");
        const accountId = c.env.CLOUDFLARE_ACCOUNT_ID || "";
        const { SelfHealingService: SelfHealingService2 } = await Promise.resolve().then(() => (init_self_healing(), self_healing_exports));
        const healingService = new SelfHealingService2(c.env, accountId);
        const steps = await healingService.getHealingSteps(attemptId);
        return c.json({
          success: true,
          result: steps,
          count: steps.length
        });
      } catch (error) {
        return c.json({
          success: false,
          error: error.message
        }, 500);
      }
    });
    healthRoutes.get("/openapi.json", (c) => {
      try {
        const baseUrl = new URL(c.req.url).origin;
        const workerUrl = "https://core-cloudflare-manager-api.hacolby.workers.dev";
        const spec = generateOpenAPISpec(baseUrl, baseUrl.includes("localhost") ? workerUrl : void 0);
        return c.json(spec);
      } catch (error) {
        return c.json({ error: error.message }, 500);
      }
    });
    healthRoutes.get("/openapi.yaml", (c) => {
      try {
        const baseUrl = new URL(c.req.url).origin;
        const workerUrl = `https://core-cloudflare-manager-api.${c.env.CLOUDFLARE_ACCOUNT_ID}.workers.dev`;
        const spec = generateOpenAPISpec(baseUrl, baseUrl.includes("localhost") ? workerUrl : void 0);
        const yaml = jsonToYaml(spec);
        return c.text(yaml, 200, {
          "Content-Type": "application/x-yaml"
        });
      } catch (error) {
        return c.text("error: " + error.message, 500);
      }
    });
    healthRoutes.get("/tests/session/:sessionUuid/healing", async (c) => {
      try {
        const sessionUuid = c.req.param("sessionUuid");
        const { SelfHealingService: SelfHealingService2 } = await Promise.resolve().then(() => (init_self_healing(), self_healing_exports));
        const healingService = new SelfHealingService2(c.env, c.env.CLOUDFLARE_ACCOUNT_ID || "");
        const healingResults = await healingService.getHealingAttemptsForSession(sessionUuid);
        return c.json({
          success: true,
          result: {
            sessionUuid,
            results: healingResults
          }
        });
      } catch (error) {
        console.error("Error getting healing status:", error);
        return c.json({
          success: false,
          error: error.message,
          details: error.stack
        }, 500);
      }
    });
    health_default2 = healthRoutes;
  }
});

// src/services/token-manager.ts
var REQUIRED_ACCOUNT_PERMISSIONS, REQUIRED_USER_PERMISSIONS, TokenManagerService;
var init_token_manager = __esm({
  "src/services/token-manager.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_client();
    REQUIRED_ACCOUNT_PERMISSIONS = [
      { name: "Workers Scripts", scope: "write" },
      { name: "Workers KV Storage", scope: "write" },
      { name: "D1", scope: "write" },
      { name: "Workers R2 Storage", scope: "write" },
      { name: "Workers AI", scope: "write" },
      { name: "AI Gateway", scope: "write" },
      { name: "Queues", scope: "write" },
      { name: "Vectorize", scope: "write" },
      { name: "Hyperdrive", scope: "write" },
      { name: "Workers Tail", scope: "read" },
      { name: "Pages", scope: "write" },
      { name: "Images", scope: "write" },
      { name: "Cloudflare Tunnel", scope: "write" },
      { name: "Workers Observability", scope: "write" }
    ];
    REQUIRED_USER_PERMISSIONS = [
      // User-level permissions
      { name: "API Tokens", scope: "write" },
      // Account-level permissions (user tokens can have these too!)
      { name: "Workers Scripts", scope: "read" },
      { name: "Workers KV Storage", scope: "read" },
      { name: "D1", scope: "read" },
      { name: "Workers AI", scope: "read" },
      { name: "Account", scope: "read" }
      // For listing accounts
    ];
    TokenManagerService = class {
      static {
        __name(this, "TokenManagerService");
      }
      env;
      db;
      accountId;
      constructor(env) {
        this.env = env;
        this.db = initDb(env);
        this.accountId = env.CLOUDFLARE_ACCOUNT_ID;
      }
      /**
       * Verify a token using its specific verification endpoint
       */
      async verifyToken(token, tokenType) {
        const verifyUrl = tokenType === "account" ? `https://api.cloudflare.com/client/v4/accounts/${this.accountId}/tokens/verify` : "https://api.cloudflare.com/client/v4/user/tokens/verify";
        try {
          const response = await fetch(verifyUrl, {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json"
            }
          });
          const data = await response.json();
          if (!data.success) {
            return {
              token_type: tokenType,
              token_id: "unknown",
              is_valid: false,
              is_active: false,
              expires_on: null,
              missing_permissions: [],
              has_all_permissions: false,
              verification_url: verifyUrl,
              error: data.errors?.[0]?.message || "Token verification failed"
            };
          }
          const result = data.result;
          const tokenId = result.id;
          const status = result.status;
          const expiresOn = result.expires_on || null;
          const permissions = await this.getTokenPermissions(token, tokenId, tokenType);
          const requiredPerms = tokenType === "account" ? REQUIRED_ACCOUNT_PERMISSIONS : REQUIRED_USER_PERMISSIONS;
          const missingPermissions = this.findMissingPermissions(permissions, requiredPerms);
          return {
            token_type: tokenType,
            token_id: tokenId,
            is_valid: true,
            is_active: status === "active",
            expires_on: expiresOn,
            missing_permissions: missingPermissions,
            has_all_permissions: missingPermissions.length === 0,
            verification_url: verifyUrl
          };
        } catch (error) {
          return {
            token_type: tokenType,
            token_id: "unknown",
            is_valid: false,
            is_active: false,
            expires_on: null,
            missing_permissions: [],
            has_all_permissions: false,
            verification_url: verifyUrl,
            error: error.message || "Failed to verify token"
          };
        }
      }
      /**
       * Get the permissions for a token
       */
      async getTokenPermissions(token, tokenId, tokenType) {
        try {
          const url = `https://api.cloudflare.com/client/v4/user/tokens/${tokenId}`;
          const response = await fetch(url, {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json"
            }
          });
          const data = await response.json();
          if (data.success && data.result) {
            return data.result.policies || [];
          }
          return [];
        } catch (error) {
          console.error(`Failed to get token permissions for ${tokenType} token:`, error);
          return [];
        }
      }
      /**
       * Find missing permissions by comparing current permissions with required ones
       */
      findMissingPermissions(currentPolicies, requiredPermissions) {
        const missing = [];
        for (const required of requiredPermissions) {
          const hasPermission = currentPolicies.some((policy) => {
            const permissionGroups = policy.permission_groups || [];
            return permissionGroups.some((pg) => {
              const pgName = pg.name?.toLowerCase() || "";
              const requiredBaseName = required.name.toLowerCase();
              const requiredScope = required.scope.toLowerCase();
              const nameWithScope = `${requiredBaseName} ${requiredScope}`;
              const matches = pgName === nameWithScope;
              if (requiredScope === "read") {
                const nameWithWrite = `${requiredBaseName} write`;
                return matches || pgName === nameWithWrite;
              }
              return matches;
            });
          });
          if (!hasPermission) {
            missing.push(`${required.name}:${required.scope}`);
          }
        }
        return missing;
      }
      /**
       * Update a token's permissions to include all required permissions
       * Uses global admin token (if available) or falls back to user token
       */
      async updateTokenPermissions(targetTokenId, targetTokenType, missingPermissions) {
        try {
          const authToken = this.env.CLOUDFLARE_GLOBAL_ADMIN_TOKEN || this.env.CLOUDFLARE_USER_TOKEN;
          const tokenSource = this.env.CLOUDFLARE_GLOBAL_ADMIN_TOKEN ? "GLOBAL ADMIN" : "USER";
          console.log(`\u{1F504} Cross-token healing: Using ${tokenSource} token to modify ${targetTokenType.toUpperCase()} token`);
          const url = `https://api.cloudflare.com/client/v4/user/tokens/${targetTokenId}`;
          const getResponse = await fetch(url, {
            method: "GET",
            headers: {
              Authorization: `Bearer ${authToken}`,
              "Content-Type": "application/json"
            }
          });
          const currentData = await getResponse.json();
          if (!currentData.success) {
            return {
              success: false,
              token_type: targetTokenType,
              token_id: targetTokenId,
              permissions_added: [],
              permissions_already_present: [],
              error: "Failed to get current token details",
              message: currentData.errors?.[0]?.message || "Unknown error"
            };
          }
          const currentToken = currentData.result;
          const currentPolicies = currentToken.policies || [];
          let userId;
          if (targetTokenType === "user") {
            for (const policy of currentPolicies) {
              const resources = policy.resources || {};
              for (const key of Object.keys(resources)) {
                if (key.startsWith("com.cloudflare.api.user.")) {
                  userId = key.replace("com.cloudflare.api.user.", "");
                  console.log(`\u{1F4DD} Extracted user ID from existing policy: ${userId}`);
                  break;
                }
              }
              if (userId) break;
            }
            if (!userId) {
              return {
                success: false,
                token_type: targetTokenType,
                token_id: targetTokenId,
                permissions_added: [],
                permissions_already_present: [],
                error: "Could not determine user ID from existing token policies",
                message: "User tokens must be scoped to a specific user ID"
              };
            }
          }
          const permissionGroupsMap = await this.getCloudflareApiPermissions(authToken);
          const requiredPerms = targetTokenType === "account" ? REQUIRED_ACCOUNT_PERMISSIONS : REQUIRED_USER_PERMISSIONS;
          const userLevelPermGroups = [];
          const accountLevelPermGroups = [];
          const permissionsAdded = [];
          const userLevelPermNames = ["api tokens"];
          for (const required of requiredPerms) {
            const permKey = `${required.name}:${required.scope}`;
            if (missingPermissions.includes(permKey)) {
              const lookupKey = `${required.name} ${required.scope}`.toLowerCase();
              const permGroup = permissionGroupsMap.get(lookupKey);
              if (permGroup) {
                const isUserLevel = userLevelPermNames.some((name) => required.name.toLowerCase().includes(name));
                if (targetTokenType === "user" && !isUserLevel) {
                  accountLevelPermGroups.push({ id: permGroup.id });
                } else {
                  userLevelPermGroups.push({ id: permGroup.id });
                }
                permissionsAdded.push(permKey);
                console.log(`\u2705 Mapped "${required.name} ${required.scope}" \u2192 ${permGroup.id} (${permGroup.name}) [${isUserLevel ? "user-level" : "account-level"}]`);
              } else {
                console.warn(`\u26A0\uFE0F Could not find permission group for "${required.name} ${required.scope}"`);
                console.warn(`   Available keys: ${Array.from(permissionGroupsMap.keys()).filter((k) => k.includes(required.name.toLowerCase().split(" ")[0])).join(", ")}`);
              }
            }
          }
          const updatedPolicies = [...currentPolicies];
          if (userLevelPermGroups.length > 0) {
            updatedPolicies.push({
              effect: "allow",
              permission_groups: userLevelPermGroups,
              resources: targetTokenType === "account" ? { [`com.cloudflare.api.account.${this.accountId}`]: "*" } : { [`com.cloudflare.api.user.${userId}`]: "*" }
            });
          }
          if (targetTokenType === "user" && accountLevelPermGroups.length > 0) {
            updatedPolicies.push({
              effect: "allow",
              permission_groups: accountLevelPermGroups,
              resources: { [`com.cloudflare.api.account.${this.accountId}`]: "*" }
            });
          }
          const updateResponse = await fetch(url, {
            method: "PUT",
            headers: {
              Authorization: `Bearer ${authToken}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              name: currentToken.name,
              policies: updatedPolicies
            })
          });
          const updateData = await updateResponse.json();
          if (!updateData.success) {
            return {
              success: false,
              token_type: targetTokenType,
              token_id: targetTokenId,
              permissions_added: [],
              permissions_already_present: [],
              error: "Failed to update token permissions",
              message: updateData.errors?.[0]?.message || "Unknown error"
            };
          }
          console.log(`\u2705 Successfully updated ${targetTokenType} token with ${permissionsAdded.length} new permissions`);
          return {
            success: true,
            token_type: targetTokenType,
            token_id: targetTokenId,
            permissions_added: permissionsAdded,
            permissions_already_present: missingPermissions.filter(
              (p) => !permissionsAdded.includes(p)
            ),
            message: `Successfully added ${permissionsAdded.length} missing permissions using cross-token authentication`
          };
        } catch (error) {
          return {
            success: false,
            token_type: targetTokenType,
            token_id: targetTokenId,
            permissions_added: [],
            permissions_already_present: [],
            error: error.message || "Failed to update token",
            message: "An error occurred while updating token permissions"
          };
        }
      }
      /**
       * Fetch permission groups from Cloudflare API to get correct IDs
       * This ensures we use the proper 32-character permission group IDs
       */
      async getCloudflareApiPermissions(token) {
        const permMap = /* @__PURE__ */ new Map();
        try {
          const response = await fetch("https://api.cloudflare.com/client/v4/user/tokens/permission_groups", {
            method: "GET",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json"
            }
          });
          const data = await response.json();
          if (data.success && data.result) {
            console.log(`\u{1F4CB} Fetched ${data.result.length} permission groups from Cloudflare API`);
            for (const group of data.result) {
              permMap.set(group.id, group);
              const normalizedName = group.name.toLowerCase();
              permMap.set(normalizedName, group);
              permMap.set(normalizedName.replace(/\s+/g, "_"), group);
              const resourcePatterns = [
                `com.cloudflare.api.account.${normalizedName.replace(/\s+/g, ".")}`,
                `com.cloudflare.api.account.${normalizedName.replace(/\s+/g, "_")}`,
                `com.cloudflare.api.account.${normalizedName.replace(/\s+/g, "")}`
              ];
              for (const pattern of resourcePatterns) {
                permMap.set(pattern, group);
              }
              if (normalizedName.includes("workers") && normalizedName.includes("script")) {
                permMap.set("com.cloudflare.api.account.workers.script", group);
              }
              if (normalizedName.includes("kv") || normalizedName.includes("storage")) {
                permMap.set("com.cloudflare.api.account.workers.kv", group);
              }
              if (normalizedName.includes("d1")) {
                permMap.set("com.cloudflare.api.account.d1", group);
              }
              if (normalizedName.includes("r2")) {
                permMap.set("com.cloudflare.api.account.workers.r2", group);
              }
              if (normalizedName.includes("ai") && !normalizedName.includes("gateway")) {
                permMap.set("com.cloudflare.api.account.ai", group);
              }
              if (normalizedName.includes("ai") && normalizedName.includes("gateway")) {
                permMap.set("com.cloudflare.api.account.ai_gateway", group);
              }
              if (normalizedName.includes("queue")) {
                permMap.set("com.cloudflare.api.account.workers.queues", group);
              }
              if (normalizedName.includes("vectorize")) {
                permMap.set("com.cloudflare.api.account.vectorize", group);
              }
              if (normalizedName.includes("hyperdrive")) {
                permMap.set("com.cloudflare.api.account.hyperdrive", group);
              }
              if (normalizedName.includes("tail")) {
                permMap.set("com.cloudflare.api.account.workers.tail", group);
              }
              if (normalizedName.includes("pages")) {
                permMap.set("com.cloudflare.api.account.pages", group);
              }
              if (normalizedName.includes("image")) {
                permMap.set("com.cloudflare.api.account.images", group);
              }
              if (normalizedName.includes("tunnel")) {
                permMap.set("com.cloudflare.api.account.tunnel", group);
              }
              if (normalizedName.includes("analytics")) {
                permMap.set("com.cloudflare.api.account.workers.analytics_engine", group);
              }
              if (normalizedName.includes("token")) {
                permMap.set("com.cloudflare.api.user.tokens", group);
              }
            }
            console.log(`\u2705 Created ${permMap.size} permission mappings`);
          } else {
            console.warn("\u26A0\uFE0F Failed to fetch permission groups from Cloudflare API, will use fallback IDs");
          }
        } catch (error) {
          console.error("Failed to fetch Cloudflare permission groups:", error);
        }
        return permMap;
      }
      /**
       * Check the health of both tokens and optionally auto-heal them
       */
      async checkTokenHealth(autoHeal = false) {
        const timestamp = (/* @__PURE__ */ new Date()).toISOString();
        const accountToken = this.env.CLOUDFLARE_ACCOUNT_TOKEN;
        const accountValidation = await this.verifyToken(accountToken, "account");
        const userToken = this.env.CLOUDFLARE_USER_TOKEN;
        const userValidation = await this.verifyToken(userToken, "user");
        let overallHealth = "healthy";
        if (!accountValidation.is_valid || !userValidation.is_valid) {
          overallHealth = "unhealthy";
        } else if (!accountValidation.has_all_permissions || !userValidation.has_all_permissions) {
          overallHealth = "degraded";
        }
        const recommendations = [];
        if (!accountValidation.is_valid) {
          recommendations.push("\u274C Account token is invalid. Please create a new account token.");
        } else if (!accountValidation.is_active) {
          recommendations.push("\u26A0\uFE0F Account token is not active. Please check token status.");
        } else if (!accountValidation.has_all_permissions) {
          recommendations.push(
            `\u26A0\uFE0F Account token is missing ${accountValidation.missing_permissions.length} permissions: ${accountValidation.missing_permissions.slice(0, 3).join(", ")}${accountValidation.missing_permissions.length > 3 ? "..." : ""}`
          );
        }
        if (!userValidation.is_valid) {
          recommendations.push("\u274C User token is invalid. Please create a new user token.");
        } else if (!userValidation.is_active) {
          recommendations.push("\u26A0\uFE0F User token is not active. Please check token status.");
        } else if (!userValidation.has_all_permissions) {
          recommendations.push(
            `\u26A0\uFE0F User token is missing ${userValidation.missing_permissions.length} permissions: ${userValidation.missing_permissions.join(", ")}`
          );
        }
        if (accountValidation.expires_on) {
          const expiresAt = new Date(accountValidation.expires_on);
          const daysUntilExpiry = Math.floor(
            (expiresAt.getTime() - Date.now()) / (1e3 * 60 * 60 * 24)
          );
          if (daysUntilExpiry < 30) {
            recommendations.push(
              `\u26A0\uFE0F Account token expires in ${daysUntilExpiry} days. Consider rotating it.`
            );
          }
        }
        if (userValidation.expires_on) {
          const expiresAt = new Date(userValidation.expires_on);
          const daysUntilExpiry = Math.floor(
            (expiresAt.getTime() - Date.now()) / (1e3 * 60 * 60 * 24)
          );
          if (daysUntilExpiry < 30) {
            recommendations.push(
              `\u26A0\uFE0F User token expires in ${daysUntilExpiry} days. Consider rotating it.`
            );
          }
        }
        if (recommendations.length === 0) {
          recommendations.push("\u2705 All tokens are healthy and have required permissions.");
        }
        const report = {
          timestamp,
          account_token: accountValidation,
          user_token: userValidation,
          overall_health: overallHealth,
          recommendations,
          auto_heal_attempted: autoHeal
        };
        if (autoHeal && overallHealth !== "healthy") {
          const autoHealResults = {};
          if (accountValidation.is_valid && accountValidation.is_active && !accountValidation.has_all_permissions) {
            const healerToken = this.env.CLOUDFLARE_GLOBAL_ADMIN_TOKEN ? "GLOBAL ADMIN" : "USER";
            console.log(
              `\u{1F527} Auto-healing account token (missing ${accountValidation.missing_permissions.length} permissions) using ${healerToken} token...`
            );
            autoHealResults.account_token = await this.updateTokenPermissions(
              accountValidation.token_id,
              "account",
              accountValidation.missing_permissions
            );
          }
          if (userValidation.is_valid && userValidation.is_active && !userValidation.has_all_permissions) {
            const healerToken = this.env.CLOUDFLARE_GLOBAL_ADMIN_TOKEN ? "GLOBAL ADMIN" : "USER";
            console.log(
              `\u{1F527} Auto-healing user token (missing ${userValidation.missing_permissions.length} permissions) using ${healerToken} token...`
            );
            autoHealResults.user_token = await this.updateTokenPermissions(
              userValidation.token_id,
              "user",
              userValidation.missing_permissions
            );
          }
          report.auto_heal_results = autoHealResults;
        }
        await this.logTokenHealthCheck(report);
        return report;
      }
      /**
       * Log token health check to database for tracking
       */
      async logTokenHealthCheck(report) {
        try {
          await this.db.insertInto("token_health_log").values({
            event_type: "token_health_check",
            metadata: JSON.stringify({
              overall_health: report.overall_health,
              account_token_valid: report.account_token.is_valid,
              account_token_has_all_perms: report.account_token.has_all_permissions,
              account_token_missing_perms: report.account_token.missing_permissions.length,
              user_token_valid: report.user_token.is_valid,
              user_token_has_all_perms: report.user_token.has_all_permissions,
              user_token_missing_perms: report.user_token.missing_permissions.length,
              auto_heal_attempted: report.auto_heal_attempted,
              auto_heal_success: report.auto_heal_results ? Object.values(report.auto_heal_results).every((r) => r.success) : null
            })
          }).execute();
        } catch (error) {
          console.error("Failed to log token health check:", error);
        }
      }
      /**
       * Manually heal tokens (public method for API endpoint)
       * Uses cross-token authentication strategy
       */
      async healTokens() {
        const healthReport = await this.checkTokenHealth(false);
        const results = {
          success: true,
          message: "Token healing completed"
        };
        if (healthReport.account_token.is_valid && healthReport.account_token.is_active && !healthReport.account_token.has_all_permissions) {
          const healerToken = this.env.CLOUDFLARE_GLOBAL_ADMIN_TOKEN ? "GLOBAL ADMIN" : "USER";
          console.log(`\u{1F527} Healing account token using ${healerToken} token...`);
          results.account_token = await this.updateTokenPermissions(
            healthReport.account_token.token_id,
            "account",
            healthReport.account_token.missing_permissions
          );
          if (!results.account_token.success) {
            results.success = false;
          }
        } else {
          results.account_token = {
            success: true,
            token_type: "account",
            token_id: healthReport.account_token.token_id,
            permissions_added: [],
            permissions_already_present: [],
            message: "Account token already has all required permissions"
          };
        }
        if (healthReport.user_token.is_valid && healthReport.user_token.is_active && !healthReport.user_token.has_all_permissions) {
          const healerToken = this.env.CLOUDFLARE_GLOBAL_ADMIN_TOKEN ? "GLOBAL ADMIN" : "USER";
          console.log(`\u{1F527} Healing user token using ${healerToken} token...`);
          results.user_token = await this.updateTokenPermissions(
            healthReport.user_token.token_id,
            "user",
            healthReport.user_token.missing_permissions
          );
          if (!results.user_token.success) {
            results.success = false;
          }
        } else {
          results.user_token = {
            success: true,
            token_type: "user",
            token_id: healthReport.user_token.token_id,
            permissions_added: [],
            permissions_already_present: [],
            message: "User token already has all required permissions"
          };
        }
        if (!results.success) {
          results.message = "Failed to heal some tokens";
        } else if (results.account_token.permissions_added.length === 0 && results.user_token.permissions_added.length === 0) {
          results.message = "All tokens already have required permissions";
        } else {
          results.message = `Successfully healed tokens (Account: +${results.account_token.permissions_added.length} perms, User: +${results.user_token.permissions_added.length} perms)`;
        }
        return results;
      }
      /**
       * Get token health history from the database
       */
      async getTokenHealthHistory(limit = 10) {
        try {
          const results = await this.db.selectFrom("token_health_log").select(["event_type", "metadata", "created_at"]).where("event_type", "=", "token_health_check").orderBy("created_at", "desc").limit(limit).execute();
          return results.map((r) => ({
            timestamp: r.created_at,
            ...JSON.parse(r.metadata || "{}")
          }));
        } catch (error) {
          console.error("Failed to get token health history:", error);
          return [];
        }
      }
      /**
       * List all available permission groups from Cloudflare API
       * Useful for debugging and understanding available permissions
       */
      async listPermissionGroups() {
        try {
          const authToken = this.env.CLOUDFLARE_GLOBAL_ADMIN_TOKEN || this.env.CLOUDFLARE_USER_TOKEN;
          const response = await fetch("https://api.cloudflare.com/client/v4/user/tokens/permission_groups", {
            method: "GET",
            headers: {
              Authorization: `Bearer ${authToken}`,
              "Content-Type": "application/json"
            }
          });
          const data = await response.json();
          if (data.success && data.result) {
            return data.result;
          }
          return [];
        } catch (error) {
          console.error("Failed to list permission groups:", error);
          return [];
        }
      }
    };
  }
});

// src/routes/tokens.ts
var tokenRoutes, tokens_default2;
var init_tokens3 = __esm({
  "src/routes/tokens.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    init_token_manager();
    tokenRoutes = new Hono2();
    tokenRoutes.get("/health", async (c) => {
      try {
        const autoHeal = c.req.query("auto_heal") === "true";
        const tokenManager = new TokenManagerService(c.env);
        const report = await tokenManager.checkTokenHealth(autoHeal);
        return c.json({
          success: true,
          data: report
        });
      } catch (error) {
        console.error("Token health check failed:", error);
        return c.json(
          {
            success: false,
            error: "Failed to check token health",
            message: error.message
          },
          500
        );
      }
    });
    tokenRoutes.post("/heal", async (c) => {
      try {
        const tokenManager = new TokenManagerService(c.env);
        const report = await tokenManager.checkTokenHealth(true);
        if (report.overall_health === "healthy") {
          return c.json({
            success: true,
            message: "All tokens are already healthy",
            data: report
          });
        }
        if (!report.auto_heal_results) {
          return c.json({
            success: false,
            message: "Auto-heal was not performed (tokens may be invalid or inactive)",
            data: report
          });
        }
        const accountHealSuccess = report.auto_heal_results.account_token?.success ?? true;
        const userHealSuccess = report.auto_heal_results.user_token?.success ?? true;
        if (accountHealSuccess && userHealSuccess) {
          return c.json({
            success: true,
            message: "Successfully healed all tokens",
            data: report
          });
        } else {
          return c.json(
            {
              success: false,
              message: "Failed to heal some tokens",
              data: report
            },
            500
          );
        }
      } catch (error) {
        console.error("Token healing failed:", error);
        return c.json(
          {
            success: false,
            error: "Failed to heal tokens",
            message: error.message
          },
          500
        );
      }
    });
    tokenRoutes.get("/history", async (c) => {
      try {
        const limit = parseInt(c.req.query("limit") || "10", 10);
        const tokenManager = new TokenManagerService(c.env);
        const history = await tokenManager.getTokenHealthHistory(limit);
        return c.json({
          success: true,
          data: {
            history,
            count: history.length
          }
        });
      } catch (error) {
        console.error("Failed to get token health history:", error);
        return c.json(
          {
            success: false,
            error: "Failed to get token health history",
            message: error.message
          },
          500
        );
      }
    });
    tokenRoutes.get("/status", async (c) => {
      try {
        const tokenManager = new TokenManagerService(c.env);
        const report = await tokenManager.checkTokenHealth(false);
        return c.json({
          success: true,
          data: {
            overall_health: report.overall_health,
            account_token: {
              is_valid: report.account_token.is_valid,
              is_active: report.account_token.is_active,
              has_all_permissions: report.account_token.has_all_permissions,
              missing_permissions_count: report.account_token.missing_permissions.length
            },
            user_token: {
              is_valid: report.user_token.is_valid,
              is_active: report.user_token.is_active,
              has_all_permissions: report.user_token.has_all_permissions,
              missing_permissions_count: report.user_token.missing_permissions.length
            },
            recommendations: report.recommendations
          }
        });
      } catch (error) {
        console.error("Token status check failed:", error);
        return c.json(
          {
            success: false,
            error: "Failed to check token status",
            message: error.message
          },
          500
        );
      }
    });
    tokenRoutes.get("/permission-groups", async (c) => {
      try {
        const tokenManager = new TokenManagerService(c.env);
        const groups = await tokenManager.listPermissionGroups();
        return c.json({
          success: true,
          data: {
            permission_groups: groups,
            count: groups.length
          }
        });
      } catch (error) {
        console.error("Failed to list permission groups:", error);
        return c.json(
          {
            success: false,
            error: "Failed to list permission groups",
            message: error.message
          },
          500
        );
      }
    });
    tokens_default2 = tokenRoutes;
  }
});

// src/services/logging.ts
var LoggingService;
var init_logging2 = __esm({
  "src/services/logging.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_types();
    init_client();
    LoggingService = class _LoggingService {
      static {
        __name(this, "LoggingService");
      }
      env;
      db;
      sessionId = null;
      sequenceCounter = 0;
      constructor(env) {
        this.env = env;
        this.db = initDb(env);
      }
      /**
       * Start a new session
       */
      async startSession(sessionData) {
        this.sessionId = generateUUID();
        this.sequenceCounter = 0;
        const now = (/* @__PURE__ */ new Date()).toISOString();
        try {
          await this.db.insertInto("sessions").values({
            id: generateUUID(),
            session_id: this.sessionId,
            request_type: sessionData.requestType,
            request_method: sessionData.requestMethod || null,
            request_path: sessionData.requestPath || null,
            request_headers: sessionData.requestHeaders ? JSON.stringify(sessionData.requestHeaders) : null,
            request_body: sessionData.requestBody || null,
            user_agent: sessionData.userAgent || null,
            client_ip: sessionData.clientIp || null,
            account_id: sessionData.accountId || null,
            user_id: sessionData.userId || null,
            started_at: now,
            completed_at: null,
            duration_ms: null,
            status_code: null,
            response_size: null,
            error_message: null,
            metadata: sessionData.metadata ? JSON.stringify(sessionData.metadata) : null,
            created_at: now
          }).execute();
          await this.logAction({
            actionType: "session_started",
            actionName: `Session started: ${sessionData.requestType}`,
            inputData: sessionData,
            status: "info"
          });
        } catch (error) {
          console.error("Failed to start session:", error);
          throw error;
        }
        return this.sessionId;
      }
      /**
       * End the current session
       */
      async endSession(statusCode, responseSize, errorMessage) {
        if (!this.sessionId) return;
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const startTime = await this.getSessionStartTime();
        let durationMs;
        if (startTime) {
          durationMs = new Date(now).getTime() - new Date(startTime).getTime();
        }
        try {
          await this.db.updateTable("sessions").set({
            completed_at: now,
            duration_ms: durationMs || null,
            status_code: statusCode || null,
            response_size: responseSize || null,
            error_message: errorMessage || null
          }).where("session_id", "=", this.sessionId).execute();
          await this.logAction({
            actionType: "session_completed",
            actionName: `Session completed: ${statusCode || "unknown"} status`,
            outputData: { statusCode, responseSize, durationMs },
            errorMessage,
            status: errorMessage ? "failed" : "completed"
          });
        } catch (error) {
          console.error("Failed to end session:", error);
        }
        this.sessionId = null;
        this.sequenceCounter = 0;
      }
      /**
       * Log an action within the current session
       */
      async logAction(actionData) {
        if (!this.sessionId) {
          console.warn("Cannot log action: no active session");
          return;
        }
        this.sequenceCounter++;
        const now = (/* @__PURE__ */ new Date()).toISOString();
        try {
          await this.db.insertInto("actions_log").values({
            id: generateUUID(),
            session_id: this.sessionId,
            action_type: actionData.actionType,
            action_name: actionData.actionName,
            timestamp: now,
            duration_ms: actionData.durationMs || null,
            status: actionData.status || "completed",
            input_data: actionData.inputData ? this.safeJsonStringify(actionData.inputData) : null,
            output_data: actionData.outputData ? this.safeJsonStringify(actionData.outputData) : null,
            error_message: actionData.errorMessage || null,
            metadata: actionData.metadata ? JSON.stringify(actionData.metadata) : null,
            sequence_number: this.sequenceCounter,
            created_at: now
          }).execute();
        } catch (error) {
          console.error("Failed to log action:", error);
        }
      }
      /**
       * Log an API request to Cloudflare
       */
      async logCloudflareApiCall(method, endpoint, requestData) {
        const actionId = `cloudflare_api_${method}_${endpoint.replace(/[^a-zA-Z0-9]/g, "_")}`;
        await this.logAction({
          actionType: "cloudflare_api_call",
          actionName: `Cloudflare API: ${method} ${endpoint}`,
          inputData: requestData,
          status: "started"
        });
        return actionId;
      }
      /**
       * Log a Cloudflare API response
       */
      async logCloudflareApiResponse(actionId, responseData, error) {
        await this.logAction({
          actionType: "cloudflare_api_response",
          actionName: `Cloudflare API Response`,
          outputData: responseData,
          errorMessage: error,
          status: error ? "failed" : "completed"
        });
      }
      /**
       * Log an AI request
       */
      async logAiRequest(model, prompt, parameters) {
        const actionId = `ai_request_${model}_${Date.now()}`;
        await this.logAction({
          actionType: "ai_request",
          actionName: `AI Request: ${model}`,
          inputData: { model, prompt, parameters },
          status: "started"
        });
        return actionId;
      }
      /**
       * Log an AI response
       */
      async logAiResponse(actionId, response, error) {
        await this.logAction({
          actionType: "ai_response",
          actionName: `AI Response`,
          outputData: response,
          errorMessage: error,
          status: error ? "failed" : "completed"
        });
      }
      /**
       * Log a database query
       */
      async logDatabaseQuery(query, parameters, result, error) {
        await this.logAction({
          actionType: "database_query",
          actionName: `Database Query: ${query.substring(0, 50)}${query.length > 50 ? "..." : ""}`,
          inputData: { query, parameters },
          outputData: result,
          errorMessage: error,
          status: error ? "failed" : "completed"
        });
      }
      /**
       * Log an error
       */
      async logError(errorType, errorMessage, errorData) {
        await this.logAction({
          actionType: "error",
          actionName: `Error: ${errorType}`,
          errorMessage,
          inputData: errorData,
          status: "failed"
        });
      }
      /**
       * Log request received
       */
      async logRequestReceived(method, path, headers, body) {
        await this.logAction({
          actionType: "request_received",
          actionName: `Request: ${method} ${path}`,
          inputData: { method, path, headers, body },
          status: "info"
        });
      }
      /**
       * Log response sent
       */
      async logResponseSent(statusCode, responseData, responseSize) {
        await this.logAction({
          actionType: "response_sent",
          actionName: `Response: ${statusCode}`,
          outputData: responseData,
          metadata: { responseSize },
          status: "completed"
        });
      }
      /**
       * Get the current session ID
       */
      getSessionId() {
        return this.sessionId;
      }
      /**
       * Check if there's an active session
       */
      hasActiveSession() {
        return this.sessionId !== null;
      }
      /**
       * Get session start time
       */
      async getSessionStartTime() {
        if (!this.sessionId) return null;
        try {
          const result = await this.db.selectFrom("sessions").select(["started_at"]).where("session_id", "=", this.sessionId).executeTakeFirst();
          return result?.started_at || null;
        } catch (error) {
          console.error("Failed to get session start time:", error);
          return null;
        }
      }
      /**
       * Safely stringify data, truncating if too large
       */
      safeJsonStringify(data, maxLength = 1e4) {
        try {
          const jsonString = JSON.stringify(data);
          if (jsonString.length > maxLength) {
            return jsonString.substring(0, maxLength) + "...[truncated]";
          }
          return jsonString;
        } catch (error) {
          return "[unable to stringify]";
        }
      }
      /**
       * Create a middleware function for Hono that automatically logs requests
       */
      createLoggingMiddleware() {
        return async (c, next) => {
          const loggingService = new _LoggingService(c.env);
          const requestMethod = c.req.method;
          const requestPath = c.req.path;
          const requestHeaders = {};
          const headerNames = ["user-agent", "x-forwarded-for", "cf-ray", "x-real-ip", "authorization"];
          headerNames.forEach((name) => {
            const value = c.req.header(name);
            if (value) requestHeaders[name] = value;
          });
          const clientIp = c.req.header("x-forwarded-for") || c.req.header("x-real-ip") || c.req.header("cf-connecting-ip") || "unknown";
          const accountId = c.env.CLOUDFLARE_ACCOUNT_ID;
          const sessionData = {
            requestType: "api",
            requestMethod,
            requestPath,
            requestHeaders,
            userAgent: c.req.header("user-agent"),
            clientIp,
            accountId
          };
          await loggingService.startSession(sessionData);
          c.set("loggingService", loggingService);
          try {
            const response = await next();
            if (response && typeof response.clone === "function") {
              const responseBody = await response.clone().text().catch(() => "");
              const responseSize = new Blob([responseBody]).size;
              await loggingService.logResponseSent(
                response.status,
                responseBody.length < 1e3 ? responseBody : "[response body too large]",
                responseSize
              );
              await loggingService.endSession(response.status, responseSize);
            } else {
              await loggingService.endSession(200, 0);
            }
            return response;
          } catch (error) {
            await loggingService.logError("request_error", error.message, {
              stack: error.stack,
              method: requestMethod,
              path: requestPath
            });
            await loggingService.endSession(500, 0, error.message);
            throw error;
          }
        };
      }
    };
  }
});

// src/logTailingDO.ts
import { DurableObject } from "cloudflare:workers";
var LogTailingDO;
var init_logTailingDO = __esm({
  "src/logTailingDO.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    LogTailingDO = class extends DurableObject {
      static {
        __name(this, "LogTailingDO");
      }
      sessions = /* @__PURE__ */ new Set();
      logBuffer = [];
      maxBufferSize = 1e3;
      constructor(state, env) {
        super(state, env);
      }
      async fetch(request) {
        const url = new URL(request.url);
        if (request.headers.get("Upgrade") === "websocket") {
          const pair = new WebSocketPair();
          const [client, server] = Object.values(pair);
          this.handleSession(server);
          return new Response(null, {
            status: 101,
            webSocket: client
          });
        }
        if (request.method === "POST" && url.pathname === "/publish") {
          const logEntry = await request.text();
          this.broadcast(logEntry);
          return Response.json({ success: true });
        }
        if (request.method === "GET" && url.pathname === "/buffer") {
          return Response.json({ logs: this.logBuffer });
        }
        return new Response("Not found", { status: 404 });
      }
      handleSession(webSocket) {
        this.sessions.add(webSocket);
        if (this.logBuffer.length > 0) {
          webSocket.send(JSON.stringify({
            type: "buffer",
            logs: this.logBuffer.slice(-100)
            // Last 100 logs
          }));
        }
        webSocket.addEventListener("message", (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.type === "ping") {
              webSocket.send(JSON.stringify({ type: "pong" }));
            }
          } catch (error) {
            console.error("Error handling WebSocket message:", error);
          }
        });
        webSocket.addEventListener("close", () => {
          this.sessions.delete(webSocket);
        });
        webSocket.addEventListener("error", () => {
          this.sessions.delete(webSocket);
        });
        webSocket.accept();
      }
      broadcast(logEntry) {
        this.logBuffer.push(logEntry);
        if (this.logBuffer.length > this.maxBufferSize) {
          this.logBuffer.shift();
        }
        const message = JSON.stringify({
          type: "log",
          data: logEntry,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        this.sessions.forEach((session) => {
          try {
            session.send(message);
          } catch (error) {
            console.error("Error sending to WebSocket:", error);
            this.sessions.delete(session);
          }
        });
      }
    };
  }
});

// src/contextCoachDO.ts
import { DurableObject as DurableObject2 } from "cloudflare:workers";
var ContextCoachDO;
var init_contextCoachDO = __esm({
  "src/contextCoachDO.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    ContextCoachDO = class extends DurableObject2 {
      static {
        __name(this, "ContextCoachDO");
      }
      constructor(state, env) {
        super(state, env);
      }
      async fetch(request) {
        const url = new URL(request.url);
        if (request.method === "POST" && url.pathname === "/coach") {
          try {
            const payload = await request.json();
            const { prompt, context } = payload;
            const history = await this.ctx.storage.get("context") ?? [];
            history.push(prompt || "");
            await this.ctx.storage.put("context", history.slice(-10));
            if (!this.env.AI) {
              return Response.json({
                should_modify: false,
                confidence: 0.5,
                coach_message: "AI binding not configured. ContextCoach is available but AI features are disabled.",
                suggested_changes: {}
              });
            }
            const systemPrompt = `You are ContextCoach, a concise, curious assistant.
Given the user's current prompt and stored context, decide whether clarification or action is needed.
Return your result in structured JSON with: should_modify, confidence, coach_message, suggested_changes.`;
            const userPrompt = JSON.stringify({ prompt, context, recent_prompts: history });
            const aiResponse = await this.env.AI.run("@cf/openai/gpt-oss-120b", {
              instructions: `${systemPrompt}`,
              input: userPrompt
            });
            const suggestion = {
              should_modify: false,
              confidence: 0.75,
              coach_message: aiResponse.response || "ContextCoach is ready to guide API interactions. Implement deeper logic next.",
              suggested_changes: {}
            };
            return Response.json(suggestion);
          } catch (error) {
            return Response.json({ error: error.message }, { status: 500 });
          }
        }
        if (request.method === "GET" && url.pathname === "/health") {
          return Response.json({ status: "healthy" });
        }
        return new Response("Not found", { status: 404 });
      }
    };
  }
});

// src/rpc-entrypoint.ts
import { WorkerEntrypoint } from "cloudflare:workers";
var CloudflareManagerRPC;
var init_rpc_entrypoint = __esm({
  "src/rpc-entrypoint.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_apiClient();
    init_cloudflare();
    CloudflareManagerRPC = class extends WorkerEntrypoint {
      static {
        __name(this, "CloudflareManagerRPC");
      }
      getApiClient() {
        return new CloudflareApiClient({ apiToken: this.env.CLOUDFLARE_ACCOUNT_TOKEN });
      }
      getCloudflareSDK() {
        return new cloudflare_default({ apiToken: this.env.CLOUDFLARE_ACCOUNT_TOKEN });
      }
      /**
       * List all Workers
       */
      async listWorkers() {
        const apiClient = this.getApiClient();
        const accountId = this.env.CLOUDFLARE_ACCOUNT_ID;
        return await apiClient.get(`/accounts/${accountId}/workers/scripts`);
      }
      /**
       * Get a specific Worker
       */
      async getWorker(scriptName) {
        const apiClient = this.getApiClient();
        const accountId = this.env.CLOUDFLARE_ACCOUNT_ID;
        return await apiClient.get(`/accounts/${accountId}/workers/scripts/${scriptName}`);
      }
      /**
       * List KV namespaces
       */
      async listKVNamespaces() {
        const apiClient = this.getApiClient();
        const accountId = this.env.CLOUDFLARE_ACCOUNT_ID;
        return await apiClient.get(`/accounts/${accountId}/storage/kv/namespaces`);
      }
      /**
       * List D1 databases
       */
      async listD1Databases() {
        const apiClient = this.getApiClient();
        const accountId = this.env.CLOUDFLARE_ACCOUNT_ID;
        return await apiClient.get(`/accounts/${accountId}/d1/databases`);
      }
      /**
       * List R2 buckets
       */
      async listR2Buckets() {
        const apiClient = this.getApiClient();
        const accountId = this.env.CLOUDFLARE_ACCOUNT_ID;
        return await apiClient.get(`/accounts/${accountId}/r2/buckets`);
      }
      /**
       * Verify token
       */
      async verifyToken() {
        const apiClient = this.getApiClient();
        return await apiClient.get("/user/tokens/verify");
      }
      /**
       * Health check
       */
      async healthCheck() {
        return {
          status: "healthy",
          version: "1.0.0",
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  CloudflareManagerRPC: () => CloudflareManagerRPC,
  ContextCoachDO: () => ContextCoachDO,
  LogTailingDO: () => LogTailingDO,
  default: () => src_default,
  scheduled: () => scheduled,
  tail: () => tail
});
var app, authMiddleware, cfInitMiddleware, apiClientMiddleware, scheduled, tail, src_default;
var init_src = __esm({
  "src/index.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_dist();
    init_cors();
    init_cloudflare();
    init_types();
    init_api();
    init_flows();
    init_health3();
    init_tokens3();
    init_apiClient();
    init_health_check();
    init_coachTelemetry();
    init_logging2();
    init_token_manager();
    init_logTailingDO();
    init_contextCoachDO();
    init_rpc_entrypoint();
    app = new Hono2();
    app.use("*", cors());
    app.use("*", async (c, next) => {
      const loggingService = new LoggingService(c.env);
      const loggingMiddleware = loggingService.createLoggingMiddleware();
      return loggingMiddleware(c, next);
    });
    authMiddleware = /* @__PURE__ */ __name(async (c, next) => {
      const authHeader = c.req.header("Authorization");
      if (!authHeader || !authHeader.startsWith("Bearer ")) {
        return c.json({ success: false, error: "Missing or invalid Authorization header" }, 401);
      }
      const token = authHeader.substring(7);
      if (token !== String(c.env.CLIENT_AUTH_TOKEN)) {
        return c.json({ success: false, error: "Invalid authentication token" }, 403);
      }
      await next();
    }, "authMiddleware");
    cfInitMiddleware = /* @__PURE__ */ __name(async (c, next) => {
      const cf = new cloudflare_default({ apiToken: getCloudflareToken(c.env) });
      const accountId = c.env.CLOUDFLARE_ACCOUNT_ID;
      c.set("cf", cf);
      c.set("accountId", accountId);
      c.set("startTime", Date.now());
      c.set("requestId", generateUUID());
      await next();
    }, "cfInitMiddleware");
    apiClientMiddleware = /* @__PURE__ */ __name(async (c, next) => {
      try {
        const apiToken = getCloudflareToken(c.env);
        if (!c.get("apiClient")) {
          const loggingService = c.get("loggingService");
          const apiClient = new CloudflareApiClient({ apiToken }, void 0, loggingService);
          c.set("apiClient", apiClient);
        }
        await next();
      } catch (error) {
        return c.json({ success: false, error: error.message || "Failed to initialize API client" }, 500);
      }
    }, "apiClientMiddleware");
    app.get("/health", (c) => {
      return c.json({
        status: "healthy",
        version: "1.0.0",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    });
    app.use("/health/*", cfInitMiddleware, apiClientMiddleware);
    app.use("/api/*", authMiddleware, cfInitMiddleware, apiClientMiddleware);
    app.use("/flows/*", authMiddleware, cfInitMiddleware, apiClientMiddleware);
    app.use("/mcp", authMiddleware, cfInitMiddleware);
    app.use("/agent", authMiddleware, cfInitMiddleware);
    app.route("/api", api_default);
    app.route("/flows", flows_default);
    app.route("/health", health_default2);
    app.route("/tokens", tokens_default2);
    app.get("/openapi.json", async (c) => {
      return health_default2.fetch(c.req.raw, c.env, c.executionCtx);
    });
    app.get("/openapi.yaml", async (c) => {
      return health_default2.fetch(c.req.raw, c.env, c.executionCtx);
    });
    app.get("/", async (c) => {
      try {
        const url = new URL(c.req.url);
        const requestInit = {
          method: c.req.method,
          headers: Object.fromEntries(c.req.raw.headers.entries())
        };
        const response = await c.env.ASSETS.fetch(new Request(`${url.origin}/index.html`, requestInit));
        return response;
      } catch (error) {
        return c.html("<h1>Cloudflare WaaS</h1><p>Welcome to Worker Management API</p>");
      }
    });
    app.get("/health.html", async (c) => {
      try {
        const url = new URL(c.req.url);
        const requestInit = {
          method: c.req.method,
          headers: Object.fromEntries(c.req.raw.headers.entries())
        };
        const response = await c.env.ASSETS.fetch(new Request(`${url.origin}/health-dashboard.html`, requestInit));
        return response;
      } catch (error) {
        return c.html("<h1>Health Dashboard</h1><p>Health dashboard not found</p>");
      }
    });
    app.get("/nav.html", async (c) => {
      try {
        const url = new URL(c.req.url);
        const requestInit = {
          method: c.req.method,
          headers: Object.fromEntries(c.req.raw.headers.entries())
        };
        const response = await c.env.ASSETS.fetch(new Request(`${url.origin}/nav.html`, requestInit));
        return response;
      } catch (error) {
        return c.text("<!-- Navigation not found -->", 404);
      }
    });
    app.get("/styles.css", async (c) => {
      try {
        const url = new URL(c.req.url);
        const requestInit = {
          method: c.req.method,
          headers: Object.fromEntries(c.req.raw.headers.entries())
        };
        return await c.env.ASSETS.fetch(new Request(`${url.origin}/styles.css`, requestInit));
      } catch (error) {
        return c.text("/* CSS not found */", 404);
      }
    });
    app.get("/app.js", async (c) => {
      try {
        const url = new URL(c.req.url);
        const requestInit = {
          method: c.req.method,
          headers: Object.fromEntries(c.req.raw.headers.entries())
        };
        return await c.env.ASSETS.fetch(new Request(`${url.origin}/app.js`, requestInit));
      } catch (error) {
        return c.text("// JS not found", 404);
      }
    });
    app.get("/logs/tail", async (c) => {
      const authHeader = c.req.header("Authorization");
      if (!authHeader || !authHeader.startsWith("Bearer ")) {
        return c.json({ error: "Unauthorized" }, 401);
      }
      const token = authHeader.substring(7);
      if (token !== c.env.CLIENT_AUTH_TOKEN) {
        return c.json({ error: "Invalid token" }, 403);
      }
      const doId = c.env.LOG_TAILING_DO.idFromName("log-tailer");
      const stub = c.env.LOG_TAILING_DO.get(doId);
      return stub.fetch(c.req.raw);
    });
    app.post("/logs/publish", authMiddleware, async (c) => {
      try {
        const logEntry = await c.req.text();
        const doId = c.env.LOG_TAILING_DO.idFromName("log-tailer");
        const stub = c.env.LOG_TAILING_DO.get(doId);
        await stub.fetch(new Request("http://do/publish", {
          method: "POST",
          body: logEntry
        }));
        return c.json({ success: true });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    app.post("/mcp", async (c) => {
      try {
        const body = await c.req.json();
        const { method, params } = body;
        switch (method) {
          case "tools/list":
            return c.json({
              tools: [
                {
                  name: "cloudflare_create_managed_token",
                  description: "Create a Cloudflare API token with intelligent management (stored securely, audited, TTL support)",
                  inputSchema: {
                    type: "object",
                    properties: {
                      name: { type: "string", description: "Token name" },
                      purpose: { type: "string", description: "What this token will be used for" },
                      permissions: { type: "array", description: "Permission IDs" },
                      ttl_days: { type: "number", description: "Days until expiration" }
                    },
                    required: ["name", "purpose", "permissions"]
                  }
                },
                {
                  name: "cloudflare_list_workers",
                  description: "List all Cloudflare Workers",
                  inputSchema: { type: "object", properties: {} }
                },
                {
                  name: "cloudflare_create_project",
                  description: "Create complete project with bindings and CI/CD",
                  inputSchema: {
                    type: "object",
                    properties: {
                      projectName: { type: "string" },
                      bindings: { type: "array", items: { type: "string" } },
                      githubRepo: { type: "string" },
                      githubOwner: { type: "string" }
                    },
                    required: ["projectName"]
                  }
                }
              ]
            });
          case "tools/call":
            const toolName = params.name;
            const toolParams = params.arguments;
            return c.json({
              content: [{
                type: "text",
                text: `Executed ${toolName} with params: ${JSON.stringify(toolParams)}`
              }]
            });
          default:
            return c.json({ error: "Unknown MCP method" }, 400);
        }
      } catch (error) {
        return c.json({ error: error.message }, 500);
      }
    });
    app.post("/agent", async (c) => {
      try {
        const { prompt } = await c.req.json();
        const cf = c.get("cf");
        const accountId = c.get("accountId");
        const promptLower = prompt.toLowerCase();
        const actions = [];
        let response = "";
        if (promptLower.includes("create") && promptLower.includes("token")) {
          response = `To create a token, I need to know:
1. What will this token be used for?
2. Which resources does it need access to?
3. Should it have an expiration (TTL)?

I can use the cloudflare-docs to determine the exact permissions needed. Please provide more details about the token's purpose.`;
        } else if (promptLower.includes("list") && promptLower.includes("worker")) {
          const workerPage = await cf.workers.scripts.list({ account_id: accountId });
          const workerItems = Array.isArray(workerPage.result) ? workerPage.result : Array.isArray(workerPage.items) ? workerPage.items : [];
          actions.push({ type: "list_workers", result: workerPage });
          response = `Found ${workerItems.length} workers in your account.`;
        } else {
          response = `I can help you manage your Cloudflare infrastructure. I can:

- Create managed API tokens (with secure storage and auditing)
- List and manage Workers, Pages, and storage resources
- Create complete project stacks with bindings
- Setup CI/CD pipelines
- And more...

What would you like to do?`;
        }
        return c.json({
          success: true,
          result: {
            message: response,
            actions
          }
        });
      } catch (error) {
        return c.json({ success: false, error: error.message }, 500);
      }
    });
    scheduled = /* @__PURE__ */ __name(async (controller, env, ctx) => {
      try {
        const cf = new cloudflare_default({ apiToken: env.CLOUDFLARE_ACCOUNT_TOKEN });
        const db = env.DB;
        const accountId = env.CLOUDFLARE_ACCOUNT_ID;
        const now = (/* @__PURE__ */ new Date()).toISOString();
        console.log(`Scheduled task started at ${now} for cron '${controller.cron}'`);
        if (controller.cron === "0 */12 * * *" || controller.cron === "0 0 * * *") {
          ctx.waitUntil(
            autoTuneThreshold(env).catch((err) => {
              console.error("Auto-tune threshold failed:", err);
            })
          );
        }
        if (controller.cron === "0 */6 * * *" || controller.cron === "0 0 * * *") {
          console.log("Running token health check and auto-heal...");
          ctx.waitUntil(
            (async () => {
              try {
                const tokenManager = new TokenManagerService(env);
                const report = await tokenManager.checkTokenHealth(true);
                console.log(`Token health check completed. Overall: ${report.overall_health}`);
                console.log(`Account token: ${report.account_token.is_valid ? "\u2705" : "\u274C"} valid, ${report.account_token.has_all_permissions ? "\u2705" : "\u26A0\uFE0F"} all permissions`);
                console.log(`User token: ${report.user_token.is_valid ? "\u2705" : "\u274C"} valid, ${report.user_token.has_all_permissions ? "\u2705" : "\u26A0\uFE0F"} all permissions`);
                if (report.auto_heal_results) {
                  if (report.auto_heal_results.account_token) {
                    const result = report.auto_heal_results.account_token;
                    console.log(`Account token heal: ${result.success ? "\u2705" : "\u274C"} ${result.message}`);
                    if (result.permissions_added.length > 0) {
                      console.log(`  Added permissions: ${result.permissions_added.join(", ")}`);
                    }
                  }
                  if (report.auto_heal_results.user_token) {
                    const result = report.auto_heal_results.user_token;
                    console.log(`User token heal: ${result.success ? "\u2705" : "\u274C"} ${result.message}`);
                    if (result.permissions_added.length > 0) {
                      console.log(`  Added permissions: ${result.permissions_added.join(", ")}`);
                    }
                  }
                }
                if (report.recommendations.length > 0) {
                  console.log("Recommendations:");
                  report.recommendations.forEach((rec) => console.log(`  ${rec}`));
                }
              } catch (tokenError) {
                console.error("Token health check failed:", tokenError);
              }
            })()
          );
        }
        if (controller.cron === "0 */6 * * *") {
          const expiredTokens = await db.prepare("SELECT * FROM managed_tokens WHERE expires_at < ? AND status = 'active'").bind(now).all();
          for (const token of expiredTokens.results || []) {
            try {
              await cf.user.tokens.delete(token.token_id);
              try {
                console.log(`Would delete secret ${token.secret_key} from store ${env.MANAGED_SECRETS_STORE}`);
              } catch (secretError) {
                console.error(`Failed to delete secret ${token.secret_key}:`, secretError);
              }
              await db.prepare("UPDATE managed_tokens SET status = 'expired' WHERE id = ?").bind(token.id).run();
              console.log(`Cleaned up expired token: ${token.token_name}`);
            } catch (error) {
              console.error(`Failed to cleanup token ${token.id}:`, error);
            }
          }
          console.log(`TTL cleanup completed. Processed ${expiredTokens.results?.length || 0} expired tokens.`);
          console.log("Scheduled health checks completed (unit tests now part of health monitoring)");
        }
        if (controller.cron === "0 0 * * *") {
          console.log("Running daily health check with auto-healing...");
          const loggingService = new LoggingService(env);
          try {
            const baseUrl = env.BASE_URL || `https://core-cloudflare-management-api.hacolby.workers.dev`;
            await loggingService.startSession({ requestType: "cron", requestPath: "scheduled:0 0 * * *" });
            const healthService = new HealthCheckService(env, baseUrl, env.CLIENT_AUTH_TOKEN, void 0, loggingService);
            const healthResult = await healthService.runHealthCheck();
            await healthService.saveHealthCheck(healthResult);
            console.log(`Daily health check completed. Status: ${healthResult.overall_status}, Healthy: ${healthResult.healthy_endpoints}/${healthResult.total_endpoints}`);
            if (healthResult.unhealthy_endpoints > 0) {
              console.log(`Triggering self-healing for ${healthResult.unhealthy_endpoints} failed endpoints...`);
              try {
                const { SelfHealingService: SelfHealingService2 } = await Promise.resolve().then(() => (init_self_healing(), self_healing_exports));
                const healingService = new SelfHealingService2(env, env.CLOUDFLARE_ACCOUNT_ID || "");
                const failedResults = await healthService.getTestResultsWithDefinitions(healthResult.check_group_id);
                const failedTests = failedResults.filter((r) => r.outcome === "fail").map((r) => ({
                  test_result_id: r.id,
                  test_id: r.health_test_id,
                  test_name: r.health_test?.name || "Unknown",
                  endpoint_path: r.health_test?.endpoint_path || "",
                  http_method: r.health_test?.http_method || "GET",
                  status: r.status,
                  status_text: r.status_text,
                  error_message: r.error_message,
                  response_body: r.response_body
                }));
                if (failedTests.length > 0) {
                  const healingResults = await healingService.analyzeAndHeal(healthResult.check_group_id, failedTests);
                  const successfulHeals = healingResults.filter((r) => r.status === "success").length;
                  console.log(`Self-healing completed: ${successfulHeals}/${failedTests.length} tests healed successfully`);
                }
              } catch (healError) {
                console.error("Self-healing failed:", healError);
              }
            }
            await loggingService.endSession(200);
          } catch (healthError) {
            console.error("Failed to run daily health check:", healthError);
            await loggingService.endSession(500, 0, healthError.message);
          }
        }
      } catch (error) {
        console.error("Error in scheduled handler:", error);
      }
    }, "scheduled");
    tail = /* @__PURE__ */ __name(async (events, env, ctx) => {
      try {
        const doId = env.LOG_TAILING_DO.idFromName("log-tailer");
        const stub = env.LOG_TAILING_DO.get(doId);
        for (const event of events) {
          const logEntry = JSON.stringify({
            timestamp: new Date(event.eventTimestamp || Date.now()).toISOString(),
            outcome: event.outcome,
            logs: event.logs,
            exceptions: event.exceptions
          });
          await stub.fetch(new Request("http://do/publish", {
            method: "POST",
            body: logEntry
          }));
        }
      } catch (error) {
        console.error("Error in tail handler:", error);
      }
    }, "tail");
    app.get("/ws", async (c) => {
      const upgradeHeader = c.req.header("Upgrade");
      if (upgradeHeader !== "websocket") {
        return c.json({ error: "Expected WebSocket upgrade" }, 426);
      }
      const { 0: client, 1: server } = new WebSocketPair();
      server.accept();
      server.addEventListener("message", (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === "ping") {
            server.send(JSON.stringify({ type: "pong", timestamp: Date.now() }));
          } else if (data.type === "health") {
            server.send(JSON.stringify({
              type: "health",
              status: "healthy",
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            }));
          } else {
            server.send(JSON.stringify({
              type: "error",
              message: "Unknown message type"
            }));
          }
        } catch (error) {
          server.send(JSON.stringify({
            type: "error",
            message: error.message
          }));
        }
      });
      server.addEventListener("close", () => {
      });
      return new Response(null, {
        status: 101,
        webSocket: client
      });
    });
    app.notFound((c) => {
      const path = new URL(c.req.url).pathname;
      if (path.startsWith("/api/")) {
        return c.json({
          success: false,
          error: "Endpoint not found",
          path,
          message: "This API endpoint does not exist. Check the OpenAPI documentation at /health/openapi.json"
        }, 404);
      }
      return c.html(`
    <!DOCTYPE html>
    <html>
      <head>
        <title>404 - Not Found</title>
        <style>
          body { font-family: system-ui; max-width: 600px; margin: 100px auto; padding: 20px; text-align: center; }
          h1 { color: #4f46e5; }
          a { color: #4f46e5; text-decoration: none; }
          a:hover { text-decoration: underline; }
        </style>
      </head>
      <body>
        <h1>404 - Page Not Found</h1>
        <p>The page <code>${path}</code> does not exist.</p>
        <p><a href="/">\u2190 Back to Home</a></p>
      </body>
    </html>
  `, 404);
    });
    src_default = app;
  }
});

// .wrangler/tmp/bundle-0SN9c2/middleware-loader.entry.ts
init_checked_fetch();
init_modules_watch_stub();

// .wrangler/tmp/bundle-0SN9c2/middleware-insertion-facade.js
init_checked_fetch();
init_modules_watch_stub();
init_src();

// node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_checked_fetch();
init_modules_watch_stub();
var drainBody = /* @__PURE__ */ __name(async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e) {
      console.error("Failed to drain the unused request body.", e);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_checked_fetch();
init_modules_watch_stub();
function reduceError(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
  };
}
__name(reduceError, "reduceError");
var jsonError = /* @__PURE__ */ __name(async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } catch (e) {
    const error = reduceError(e);
    return Response.json(error, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default = jsonError;

// .wrangler/tmp/bundle-0SN9c2/middleware-insertion-facade.js
init_src();
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = src_default;

// node_modules/wrangler/templates/middleware/common.ts
init_checked_fetch();
init_modules_watch_stub();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request, env, ctx, dispatch, middlewareChain) {
  const [head, ...tail2] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail2);
    }
  };
  return head(request, env, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-0SN9c2/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class ___Facade_ScheduledController__ {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  static {
    __name(this, "__Facade_ScheduledController__");
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof ___Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request, env, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request, env, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type, init) {
        if (type === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = /* @__PURE__ */ __name((request, env, ctx) => {
      this.env = env;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    }, "#fetchDispatcher");
    #dispatcher = /* @__PURE__ */ __name((type, init) => {
      if (type === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    }, "#dispatcher");
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  CloudflareManagerRPC,
  ContextCoachDO,
  LogTailingDO,
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default,
  scheduled,
  tail
};
//# sourceMappingURL=index.js.map
